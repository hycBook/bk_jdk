<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>多线程_基础篇 · Java相关学习记录</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="" name="description"/>
<meta content="GitBook 3.2.3" name="generator"/>
<meta content="narutohyc" name="author"/>
<link href="../gitbook/style.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-splitter/splitter.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchors/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-donate/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-code/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-search-plus/search.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-lightbox/css/lightbox.min.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-change_girls/girls.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-pageview-count/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-highlight/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-fontsettings/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-theme-comscore/test.css" rel="stylesheet"/>
<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<link href="../gitbook/images/apple-touch-icon-precomposed-152.png" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../gitbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="多线程_锁.html" rel="next"/>
<link href="多线程.html" rel="prev"/>
<link href="./chapters/res/other/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="./chapters/res/other/favicon.ico" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
<script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]};
    </script>
</head>
<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="输入并搜索" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="https://github.com/narutohyc" target="_blank">我的狗窝</a>
</li>
<li class="divider"></li>
<li class="chapter" data-level="1.1" data-path="../">
<a href="../">
<b>1.1.</b>
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="设计模式.html">
<a href="设计模式.html">
<b>1.2.</b>
                    
                    设计模式
            
                </a>
</li>
<li class="chapter" data-level="1.3" data-path="多线程.html">
<a href="多线程.html">
<b>1.3.</b>
                    
                    多线程
            
                </a>
<ul class="articles">
<li class="chapter active" data-level="1.3.1" data-path="多线程_基础篇.html">
<a href="多线程_基础篇.html">
<b>1.3.1.</b>
                    
                    多线程_基础篇
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="多线程_锁.html">
<a href="多线程_锁.html">
<b>1.3.2.</b>
                    
                    多线程_锁
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="多线程_JUC原子类.html">
<a href="多线程_JUC原子类.html">
<b>1.3.3.</b>
                    
                    多线程_JUC原子类
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="多线程_JUC锁集合.html">
<a href="多线程_JUC锁集合.html">
<b>1.3.4.</b>
                    
                    多线程_JUC锁集合
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="多线程_JUC集合.md">
<span>
<b>1.3.5.</b>
                    
                    多线程_JUC集合
            
                
            

            
        </span></li>
<li class="chapter" data-level="1.3.6" data-path="多线程_JUC线程池.html">
<a href="多线程_JUC线程池.html">
<b>1.3.6.</b>
                    
                    多线程_JUC线程池
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="多线程_生产者消费者.html">
<a href="多线程_生产者消费者.html">
<b>1.3.7.</b>
                    
                    多线程_生产者消费者
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="IDEA快捷键.html">
<a href="IDEA快捷键.html">
<b>1.4.</b>
                    
                    IDEA快捷键
            
                </a>
</li>
<li class="chapter" data-level="1.5" data-path="Spring注解.html">
<a href="Spring注解.html">
<b>1.5.</b>
                    
                    Spring注解
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="Spring注解_介绍.html">
<a href="Spring注解_介绍.html">
<b>1.5.1.</b>
                    
                    Spring注解_介绍
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="Spring注解_常用注解.html">
<a href="Spring注解_常用注解.html">
<b>1.5.2.</b>
                    
                    Spring注解_常用注解
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="Spring注解_Spring入门篇.html">
<a href="Spring注解_Spring入门篇.html">
<b>1.5.3.</b>
                    
                    Spring注解_Spring入门篇
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="Java基础.html">
<a href="Java基础.html">
<b>1.6.</b>
                    
                    Java基础
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="Java基础_集合.html">
<a href="Java基础_集合.html">
<b>1.6.1.</b>
                    
                    Java基础_集合
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="Java基础_泛型.html">
<a href="Java基础_泛型.html">
<b>1.6.2.</b>
                    
                    Java基础_泛型
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="Java基础_打jar包.html">
<a href="Java基础_打jar包.html">
<b>1.6.3.</b>
                    
                    Java基础_打jar包
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="Java基础_正则匹配.html">
<a href="Java基础_正则匹配.html">
<b>1.6.4.</b>
                    
                    Java基础_正则匹配
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="Java基础_反射机制.html">
<a href="Java基础_反射机制.html">
<b>1.6.5.</b>
                    
                    Java基础_反射机制
            
                </a>
</li>
<li class="chapter" data-level="1.6.6" data-path="Java基础_对象正反序列化.html">
<a href="Java基础_对象正反序列化.html">
<b>1.6.6.</b>
                    
                    Java基础_对象正反序列化
            
                </a>
</li>
<li class="chapter" data-level="1.6.7" data-path="Java基础_读取配置文件.html">
<a href="Java基础_读取配置文件.html">
<b>1.6.7.</b>
                    
                    Java基础_读取配置文件
            
                </a>
</li>
<li class="chapter" data-level="1.6.8" data-path="Java基础_解析与生成XML.html">
<a href="Java基础_解析与生成XML.html">
<b>1.6.8.</b>
                    
                    Java基础_解析与生成XML
            
                </a>
</li>
<li class="chapter" data-level="1.6.9" data-path="Java基础_后台服务器开发.html">
<a href="Java基础_后台服务器开发.html">
<b>1.6.9.</b>
                    
                    Java基础_后台服务器开发
            
                </a>
</li>
<li class="chapter" data-level="1.6.10" data-path="Java基础_四舍五入.html">
<a href="Java基础_四舍五入.html">
<b>1.6.10.</b>
                    
                    Java基础_四舍五入
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="Java进阶.html">
<a href="Java进阶.html">
<b>1.7.</b>
                    
                    Java进阶
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="Java进阶_反射.html">
<a href="Java进阶_反射.html">
<b>1.7.1.</b>
                    
                    Java进阶_反射
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="Java进阶_注解.html">
<a href="Java进阶_注解.html">
<b>1.7.2.</b>
                    
                    Java进阶_注解
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.8" data-path="MySQL.html">
<a href="MySQL.html">
<b>1.8.</b>
                    
                    MySQL
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.8.1" data-path="MySQL_基础.html">
<a href="MySQL_基础.html">
<b>1.8.1.</b>
                    
                    MySQL_基础
            
                </a>
</li>
<li class="chapter" data-level="1.8.2" data-path="MySQL_约束.html">
<a href="MySQL_约束.html">
<b>1.8.2.</b>
                    
                    MySQL_约束
            
                </a>
</li>
<li class="chapter" data-level="1.8.3" data-path="MySQL_多表查询.html">
<a href="MySQL_多表查询.html">
<b>1.8.3.</b>
                    
                    MySQL_多表查询
            
                </a>
</li>
<li class="chapter" data-level="1.8.4" data-path="MySQL_事务.html">
<a href="MySQL_事务.html">
<b>1.8.4.</b>
                    
                    MySQL_事务
            
                </a>
</li>
<li class="chapter" data-level="1.8.5" data-path="MySQL_数据库设计.html">
<a href="MySQL_数据库设计.html">
<b>1.8.5.</b>
                    
                    MySQL_数据库设计
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.9" data-path="JDBC.html">
<a href="JDBC.html">
<b>1.9.</b>
                    
                    JDBC
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.9.1" data-path="JDBC_JDBC基础.html">
<a href="JDBC_JDBC基础.html">
<b>1.9.1.</b>
                    
                    JDBC_JDBC基础
            
                </a>
</li>
<li class="chapter" data-level="1.9.2" data-path="JDBC_JDBC连接池.html">
<a href="JDBC_JDBC连接池.html">
<b>1.9.2.</b>
                    
                    JDBC_JDBC连接池
            
                </a>
</li>
<li class="chapter" data-level="1.9.3" data-path="JDBC_JDBCTemplate.html">
<a href="JDBC_JDBCTemplate.html">
<b>1.9.3.</b>
                    
                    JDBC_JDBCTemplate
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.10" data-path="Spark集群搭建.html">
<a href="Spark集群搭建.html">
<b>1.10.</b>
                    
                    Spark集群搭建
            
                </a>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            本书使用 GitBook 发布
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="..">多线程_基础篇</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div class="search-plus" id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon"></span><a href="#基础篇">1 基础篇</a></li><li><span class="title-icon"></span><a href="#实现多线程的两种方式">2 实现多线程的两种方式</a></li><li><span class="title-icon"></span><a href="#synchronized关键字">3 synchronized关键字</a></li><li><span class="title-icon"></span><a href="#线程等待与唤醒">4 线程等待与唤醒</a></li><li><span class="title-icon"></span><a href="#线程让步yield">5 线程让步yield()</a></li><li><span class="title-icon"></span><a href="#线程休眠sleep">6 线程休眠sleep()</a></li><li><span class="title-icon"></span><a href="#join-方法">7 join() 方法</a></li><li><span class="title-icon"></span><a href="#interrupt和线程终止方式">8 interrupt()和线程终止方式</a></li><li><span class="title-icon"></span><a href="#线程优先级和守护线程">9 线程优先级和守护线程</a></li><li><span class="title-icon"></span><a href="#生产消费者问题">10 生产消费者问题</a></li></ul></div><a href="#基础篇" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><p><a data-lightbox="5e9bdf2e-cc6b-4fd5-9284-a9e2e4851ebb" data-title="img" href="res/other/异世界蕾姆_1.png"><img alt="img" src="res/other/异世界蕾姆_1.png"/></a><a data-lightbox="68741d40-5273-4b49-af20-796ddb92d04f" data-title="异世界.png" href="https://upload-images.jianshu.io/upload_images/15675864-e39212ac990782cf.png" target="_blank"><img alt="异世界.png" src="https://upload-images.jianshu.io/upload_images/15675864-e39212ac990782cf.png"/></a></p>
<p><li><span class="title-icon"></span><a href="#基础篇">1 基础篇</a></li><li><span class="title-icon"></span><a href="#实现多线程的两种方式">2 实现多线程的两种方式</a></li><li><span class="title-icon"></span><a href="#synchronized关键字">3 synchronized关键字</a></li><li><span class="title-icon"></span><a href="#线程等待与唤醒">4 线程等待与唤醒</a></li><li><span class="title-icon"></span><a href="#线程让步yield">5 线程让步yield()</a></li><li><span class="title-icon"></span><a href="#线程休眠sleep">6 线程休眠sleep()</a></li><li><span class="title-icon"></span><a href="#join-方法">7 join() 方法</a></li><li><span class="title-icon"></span><a href="#interrupt和线程终止方式">8 interrupt()和线程终止方式</a></li><li><span class="title-icon"></span><a href="#线程优先级和守护线程">9 线程优先级和守护线程</a></li><li><span class="title-icon"></span><a href="#生产消费者问题">10 生产消费者问题</a></li></p>
<h1 id="基础篇">1 基础篇</h1>
<pre><code class="lang-cmd"><span class="hljs-number">1</span>. Java多线程系列目录(共<span class="hljs-number">43</span>篇)-转    
<span class="hljs-function">    https://<span class="hljs-title">www.jianshu.com</span>/<span class="hljs-title">p</span>/<span class="hljs-title">dca27f047923</span>
<span class="hljs-title">https</span>://<span class="hljs-title">www.cnblogs.com</span>/<span class="hljs-title">skywang12345</span>/<span class="hljs-title">p</span>/<span class="hljs-title">java_threads_category.html</span>
</span></code></pre>
<p>线程共包括以下5种状态：</p>
<ol>
<li><strong>新建状态(New) </strong>: 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>
<li><strong>就绪状态(Runnable)</strong>: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>
<li><strong>运行状态(Running)</strong>: 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>
<li><strong>阻塞状态(Blocked) </strong>: 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
(01) <strong>等待阻塞</strong> -- 通过调用线程的wait()方法，让线程等待某工作的完成。
(02) <strong>同步阻塞</strong> -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
(03) <strong>其他阻塞</strong> -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
<li><strong>死亡状态(Dead) </strong>: 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<p>扩展：
<strong>Object类</strong>，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。
<strong>Thread类</strong>，线程操作函数。例如sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。
<strong>synchronized</strong>关键字，区分为synchronized代码块和synchronized方法，让线程获取对象的同步锁。</p>
<p><a href="https://images0.cnblogs.com/blog/497634/201312/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg" target="_blank"></a><a data-lightbox="71ae4d0a-dd0e-472e-a0b3-6e121390f3dd" data-title="img" href="res/Java%20Thread/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg"><img alt="img" src="res/Java%20Thread/18152411-a974ea82ebc04e72bd874c3921f8bfec.jpg"/></a></p>
<h1 id="实现多线程的两种方式">2 实现多线程的两种方式</h1>
<pre><code class="lang-java"><span class="hljs-number">1</span>. Runnable 是一个接口，该接口中只包含了一个run()方法。
   Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> A())等方式新建线程。
<span class="hljs-number">2</span>. Thread 是一个类。Thread本身就实现了Runnable接口。Thread的作用，实现多线程。
</code></pre>
<p><strong>Thread和Runnable的异同点</strong></p>
<pre><code class="lang-java">Thread 和 Runnable 的相同点：都是“多线程的实现方式”。
Thread 和 Runnable 的不同点：
Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。
此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。<span class="hljs-comment">//通常，建议通过“Runnable”实现多线程！</span>
</code></pre>
<p><strong>Runnable的多线程示例</strong></p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">10</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ticket &gt; <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" 卖票：ticket"</span> + <span class="hljs-keyword">this</span>.ticket--);
            }
        }
    }
};

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        MyThread mt = <span class="hljs-keyword">new</span> MyThread();
        <span class="hljs-comment">// 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！</span>
        Thread t1 = <span class="hljs-keyword">new</span> Thread(mt);
        Thread t2 = <span class="hljs-keyword">new</span> Thread(mt);
        Thread t3 = <span class="hljs-keyword">new</span> Thread(mt);
        t1.start();
        t2.start();
        t3.start();
    }
}

<span class="hljs-comment">//结果说明：</span>
(<span class="hljs-number">01</span>) 和下面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。
(<span class="hljs-number">02</span>) 主线程main创建并启动<span class="hljs-number">3</span>个子线程，而且这<span class="hljs-number">3</span>个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这<span class="hljs-number">3</span>个子线程一共卖出了<span class="hljs-number">10</span>张票。这说明它们是共享了MyThread接口的。

Thread-<span class="hljs-number">1</span> 卖票：ticket10
Thread-<span class="hljs-number">2</span> 卖票：ticket9
Thread-<span class="hljs-number">0</span> 卖票：ticket9
Thread-<span class="hljs-number">2</span> 卖票：ticket7
Thread-<span class="hljs-number">1</span> 卖票：ticket8
Thread-<span class="hljs-number">2</span> 卖票：ticket5
Thread-<span class="hljs-number">0</span> 卖票：ticket6
Thread-<span class="hljs-number">2</span> 卖票：ticket3
Thread-<span class="hljs-number">1</span> 卖票：ticket4
Thread-<span class="hljs-number">2</span> 卖票：ticket1
Thread-<span class="hljs-number">0</span> 卖票：ticket2
</code></pre>
<p><strong>Thread的多线程示例</strong></p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ticket=<span class="hljs-number">5</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++){
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.ticket&gt;<span class="hljs-number">0</span>){
                System.out.println(<span class="hljs-keyword">this</span>.getName()+<span class="hljs-string">" 卖票：ticket"</span>+<span class="hljs-keyword">this</span>.ticket--);
            }
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">// 启动3个线程t1,t2,t3；每个线程各卖10张票！</span>
        MyThread t1=<span class="hljs-keyword">new</span> MyThread();
        MyThread t2=<span class="hljs-keyword">new</span> MyThread();
        MyThread t3=<span class="hljs-keyword">new</span> MyThread();
        t1.start();
        t2.start();
        t3.start();
    }
}

<span class="hljs-comment">//结果说明：</span>
(<span class="hljs-number">01</span>) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出<span class="hljs-number">10</span>张票。
(<span class="hljs-number">02</span>) 主线程main创建并启动<span class="hljs-number">3</span>个MyThread子线程。每个子线程都各自卖出了<span class="hljs-number">10</span>张票。

Thread-<span class="hljs-number">0</span> 卖票：ticket5
Thread-<span class="hljs-number">0</span> 卖票：ticket4
Thread-<span class="hljs-number">0</span> 卖票：ticket3
Thread-<span class="hljs-number">0</span> 卖票：ticket2
Thread-<span class="hljs-number">0</span> 卖票：ticket1
Thread-<span class="hljs-number">1</span> 卖票：ticket5
Thread-<span class="hljs-number">1</span> 卖票：ticket4
Thread-<span class="hljs-number">1</span> 卖票：ticket3
Thread-<span class="hljs-number">1</span> 卖票：ticket2
Thread-<span class="hljs-number">1</span> 卖票：ticket1
Thread-<span class="hljs-number">2</span> 卖票：ticket5
Thread-<span class="hljs-number">2</span> 卖票：ticket4
Thread-<span class="hljs-number">2</span> 卖票：ticket3
Thread-<span class="hljs-number">2</span> 卖票：ticket2
Thread-<span class="hljs-number">2</span> 卖票：ticket1
</code></pre>
<p><strong>Thread中start()和run()的区别 </strong></p>
<pre><code class="lang-java">start(): 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。
run(): run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！
</code></pre>
<h1 id="synchronized关键字">3 synchronized关键字</h1>
<p><strong>synchronized原理</strong></p>
<pre><code class="lang-java">在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。
当我们调用某对象的<span class="hljs-keyword">synchronized</span>方法时，就获取了该对象的同步锁。例如，<span class="hljs-keyword">synchronized</span>(obj)就获取了“obj这个对象”的同步锁。
不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。
</code></pre>
<p><strong>synchronized基本规则</strong></p>
<pre><code class="lang-java">第一条: 当一个线程访问“某对象”的“<span class="hljs-keyword">synchronized</span>方法”或者“<span class="hljs-keyword">synchronized</span>代码块”时，其他线程对“该对象”的该“<span class="hljs-keyword">synchronized</span>方法”或者“<span class="hljs-keyword">synchronized</span>代码块”的访问将被阻塞。
第二条: 当一个线程访问“某对象”的“<span class="hljs-keyword">synchronized</span>方法”或者“<span class="hljs-keyword">synchronized</span>代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。
第三条: 当一个线程访问“某对象”的“<span class="hljs-keyword">synchronized</span>方法”或者“<span class="hljs-keyword">synchronized</span>代码块”时，其他线程对“该对象”的其他的“<span class="hljs-keyword">synchronized</span>方法”或者“<span class="hljs-keyword">synchronized</span>代码块”的访问将被阻塞。
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 第一条</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">try</span> {  
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" loop "</span> + i);  
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
            }
        }  
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        Runnable demo = <span class="hljs-keyword">new</span> MyRunable();     <span class="hljs-comment">// 新建“Runnable对象”</span>
        Thread t1 = <span class="hljs-keyword">new</span> Thread(demo, <span class="hljs-string">"t1"</span>);  <span class="hljs-comment">// 新建“线程t1”, t1是基于demo这个Runnable对象</span>
        Thread t2 = <span class="hljs-keyword">new</span> Thread(demo, <span class="hljs-string">"t2"</span>);  <span class="hljs-comment">// 新建“线程t2”, t2是基于demo这个Runnable对象</span>
        t1.start();                          <span class="hljs-comment">// 启动“线程t1”</span>
        t2.start();                          <span class="hljs-comment">// 启动“线程t2” </span>
    } 
}

<span class="hljs-comment">// 结果说明：</span>
run()方法中存在“<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)代码块”，而且t1和t2都是基于<span class="hljs-string">"demo这个Runnable对象"</span>创建的线程。这就意味着，我们可以将<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)中的<span class="hljs-keyword">this</span>看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。

t1 loop <span class="hljs-number">0</span>
t1 loop <span class="hljs-number">1</span>
t1 loop <span class="hljs-number">2</span>
t1 loop <span class="hljs-number">3</span>
t1 loop <span class="hljs-number">4</span>
t2 loop <span class="hljs-number">0</span>
t2 loop <span class="hljs-number">1</span>
t2 loop <span class="hljs-number">2</span>
t2 loop <span class="hljs-number">3</span>
t2 loop <span class="hljs-number">4</span>
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 第一条_续</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">try</span> {  
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" loop "</span> + i);  
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
            }
        }  
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1_2</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        Thread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t1"</span>);  <span class="hljs-comment">// 新建“线程t1”</span>
        Thread t2 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t2"</span>);  <span class="hljs-comment">// 新建“线程t2”</span>
        t1.start();                      <span class="hljs-comment">// 启动“线程t1”</span>
        t2.start();                      <span class="hljs-comment">// 启动“线程t2” </span>
    } 
}

<span class="hljs-comment">// 代码说明：</span>
比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。
幸运的是，在“Demo1_2的run()方法”也调用了<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)，正如“Demo1_1的run()方法”也调用了<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)一样！

<span class="hljs-comment">// 结果说明：</span>
如果这个结果一点也不令你感到惊讶，那么我相信你对<span class="hljs-keyword">synchronized</span>和<span class="hljs-keyword">this</span>的认识已经比较深刻了。否则的话，请继续阅读这里的分析。
<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)中的<span class="hljs-keyword">this</span>是指“当前的类对象”，即<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。
对于Demo1_2中，<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)中的<span class="hljs-keyword">this</span>代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)时，获取的是不同对象的同步锁。对于Demo1_1对而言，<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)中的<span class="hljs-keyword">this</span>代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。

t1 loop <span class="hljs-number">0</span>
t2 loop <span class="hljs-number">0</span>
t1 loop <span class="hljs-number">1</span>
t2 loop <span class="hljs-number">1</span>
t1 loop <span class="hljs-number">2</span>
t2 loop <span class="hljs-number">2</span>
t1 loop <span class="hljs-number">3</span>
t2 loop <span class="hljs-number">3</span>
t1 loop <span class="hljs-number">4</span>
t2 loop <span class="hljs-number">4</span>
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 第二条</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Count</span> </span>{
    <span class="hljs-comment">// 含有synchronized同步块的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">synMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">try</span> {  
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" synMethod loop "</span> + i);  
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
            }
        }  
    }
    <span class="hljs-comment">// 非同步的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nonSynMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>);
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" nonSynMethod loop "</span> + i);  
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        <span class="hljs-keyword">final</span> Count count = <span class="hljs-keyword">new</span> Count();
        <span class="hljs-comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span>
        Thread t1 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        count.synMethod();
                    }
                }, <span class="hljs-string">"t1"</span>);
        <span class="hljs-comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span>
        Thread t2 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        count.nonSynMethod();
                    }
                }, <span class="hljs-string">"t2"</span>);  
        t1.start();  <span class="hljs-comment">// 启动t1</span>
        t2.start();  <span class="hljs-comment">// 启动t2</span>
    } 
}

<span class="hljs-comment">// 结果说明：</span>
主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。

t1 synMethod loop <span class="hljs-number">0</span>
t2 nonSynMethod loop <span class="hljs-number">0</span>
t1 synMethod loop <span class="hljs-number">1</span>
t2 nonSynMethod loop <span class="hljs-number">1</span>
t1 synMethod loop <span class="hljs-number">2</span>
t2 nonSynMethod loop <span class="hljs-number">2</span>
t1 synMethod loop <span class="hljs-number">3</span>
t2 nonSynMethod loop <span class="hljs-number">3</span>
t1 synMethod loop <span class="hljs-number">4</span>
t2 nonSynMethod loop <span class="hljs-number">4</span>
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 第三条</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Count</span> </span>{
    <span class="hljs-comment">// 含有synchronized同步块的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">synMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">try</span> {  
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" synMethod loop "</span> + i);  
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
            }
        }  
    }
    <span class="hljs-comment">// 也包含synchronized同步块的方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nonSynMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">try</span> {  
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                    Thread.sleep(<span class="hljs-number">100</span>);
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" nonSynMethod loop "</span> + i);  
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
            }
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        <span class="hljs-keyword">final</span> Count count = <span class="hljs-keyword">new</span> Count();
        <span class="hljs-comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span>
        Thread t1 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        count.synMethod();
                    }
                }, <span class="hljs-string">"t1"</span>);
        <span class="hljs-comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span>
        Thread t2 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        count.nonSynMethod();
                    }
                }, <span class="hljs-string">"t2"</span>);  
        t1.start();  <span class="hljs-comment">// 启动t1</span>
        t2.start();  <span class="hljs-comment">// 启动t2</span>
    } 
}

<span class="hljs-comment">// 结果说明：</span>
主线程中新建了两个子线程t1和t2。t1和t2运行时都调用<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)，这个<span class="hljs-keyword">this</span>是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。

t1 synMethod loop <span class="hljs-number">0</span>
t1 synMethod loop <span class="hljs-number">1</span>
t1 synMethod loop <span class="hljs-number">2</span>
t1 synMethod loop <span class="hljs-number">3</span>
t1 synMethod loop <span class="hljs-number">4</span>
t2 nonSynMethod loop <span class="hljs-number">0</span>
t2 nonSynMethod loop <span class="hljs-number">1</span>
t2 nonSynMethod loop <span class="hljs-number">2</span>
t2 nonSynMethod loop <span class="hljs-number">3</span>
t2 nonSynMethod loop <span class="hljs-number">4</span>
</code></pre>
<p><strong>synchronized方法 和 synchronized代码块</strong></p>
<pre><code class="lang-java"><span class="hljs-comment">// synchronized方法示例</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"synchronized methoed"</span>);
}
<span class="hljs-comment">// synchronized代码块</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
        System.out.println(<span class="hljs-string">"synchronized methoed"</span>);
    }
}
<span class="hljs-comment">// synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。</span>
<span class="hljs-comment">// synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。</span>
</code></pre>
<p><strong>实例锁和全局锁</strong></p>
<pre><code class="lang-java">实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。
<span class="hljs-comment">// 实例锁对应的就是synchronized关键字。</span>
全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。
<span class="hljs-comment">// 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</span>

pulbic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncA</span><span class="hljs-params">()</span></span>{}
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncB</span><span class="hljs-params">()</span></span>{}
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncA</span><span class="hljs-params">()</span></span>{}
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncB</span><span class="hljs-params">()</span></span>{}
}

假设，Something有两个实例x和y。分析下面<span class="hljs-number">4</span>组表达式获取的锁的情况。
(<span class="hljs-number">01</span>) (不能被同时访问)x.isSyncA()与x.isSyncB() 
(<span class="hljs-number">02</span>) (可以同时被访问)x.isSyncA()与y.isSyncA()
(<span class="hljs-number">03</span>) (不能被同时访问)x.cSyncA()与y.cSyncB()
(<span class="hljs-number">04</span>) (可以被同时访问)x.isSyncA()与Something.cSyncA()
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// (01) 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！</span>
<span class="hljs-comment">// LockTest1.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncA</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncA"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncB</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncB"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest1</span> </span>{
    Something x = <span class="hljs-keyword">new</span> Something();
    Something y = <span class="hljs-keyword">new</span> Something();
    <span class="hljs-comment">// 比较(01) x.isSyncA()与x.isSyncB() </span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 新建t11, t11会调用 x.isSyncA()</span>
        Thread t11 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        x.isSyncA();
                    }
                }, <span class="hljs-string">"t11"</span>);
        <span class="hljs-comment">// 新建t12, t12会调用 x.isSyncB()</span>
        Thread t12 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        x.isSyncB();
                    }
                }, <span class="hljs-string">"t12"</span>);  
        t11.start();  <span class="hljs-comment">// 启动t11</span>
        t12.start();  <span class="hljs-comment">// 启动t12</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        LockTest1 demo = <span class="hljs-keyword">new</span> LockTest1();
        demo.test1();
    }
}

t11 : isSyncA
t11 : isSyncA
t11 : isSyncA
t11 : isSyncA
t11 : isSyncA
t12 : isSyncB
t12 : isSyncB
t12 : isSyncB
t12 : isSyncB
t12 : isSyncB
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// (02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。</span>

<span class="hljs-comment">// LockTest2.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncA</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncA"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncB</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncB"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncA</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : cSyncA"</span>);
            } 
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncB</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : cSyncB"</span>);
            } 
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest2</span> </span>{
    Something x = <span class="hljs-keyword">new</span> Something();
    Something y = <span class="hljs-keyword">new</span> Something();
    <span class="hljs-comment">// 比较(02) x.isSyncA()与y.isSyncA()</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 新建t21, t21会调用 x.isSyncA()</span>
        Thread t21 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        x.isSyncA();
                    }
                }, <span class="hljs-string">"t21"</span>);
        <span class="hljs-comment">// 新建t22, t22会调用 x.isSyncB()</span>
        Thread t22 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        y.isSyncA();
                    }
                }, <span class="hljs-string">"t22"</span>);  
        t21.start();  <span class="hljs-comment">// 启动t21</span>
        t22.start();  <span class="hljs-comment">// 启动t22</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        LockTest2 demo = <span class="hljs-keyword">new</span> LockTest2();
        demo.test2();
    }
}

t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA
t21 : isSyncA
t22 : isSyncA
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// (03) 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时访问。</span>
<span class="hljs-comment">// LockTest3.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncA</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncA"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncB</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncB"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncA</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : cSyncA"</span>);
            } 
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncB</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : cSyncB"</span>);
            } 
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest3</span> </span>{
    Something x = <span class="hljs-keyword">new</span> Something();
    Something y = <span class="hljs-keyword">new</span> Something();
    <span class="hljs-comment">// 比较(03) x.cSyncA()与y.cSyncB()</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 新建t31, t31会调用 x.isSyncA()</span>
        Thread t31 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        x.cSyncA();
                    }
                }, <span class="hljs-string">"t31"</span>);
        <span class="hljs-comment">// 新建t32, t32会调用 x.isSyncB()</span>
        Thread t32 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        y.cSyncB();
                    }
                }, <span class="hljs-string">"t32"</span>);  
        t31.start();  <span class="hljs-comment">// 启动t31</span>
        t32.start();  <span class="hljs-comment">// 启动t32</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        LockTest3 demo = <span class="hljs-keyword">new</span> LockTest3();
        demo.test3();
    }
}

t31 : cSyncA
t31 : cSyncA
t31 : cSyncA
t31 : cSyncA
t31 : cSyncA
t32 : cSyncB
t32 : cSyncB
t32 : cSyncB
t32 : cSyncB
t32 : cSyncB
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// (04) 可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。</span>
<span class="hljs-comment">// LockTest4.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Something</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncA</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncA"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">isSyncB</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : isSyncB"</span>);
            }
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncA</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : cSyncA"</span>);
            } 
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cSyncB</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" : cSyncB"</span>);
            } 
        }<span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        }  
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest4</span> </span>{
    Something x = <span class="hljs-keyword">new</span> Something();
    Something y = <span class="hljs-keyword">new</span> Something();
    <span class="hljs-comment">// 比较(04) x.isSyncA()与Something.cSyncA()</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 新建t41, t41会调用 x.isSyncA()</span>
        Thread t41 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        x.isSyncA();
                    }
                }, <span class="hljs-string">"t41"</span>);
        <span class="hljs-comment">// 新建t42, t42会调用 x.isSyncB()</span>
        Thread t42 = <span class="hljs-keyword">new</span> Thread(
                <span class="hljs-keyword">new</span> Runnable() {
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                        Something.cSyncA();
                    }
                }, <span class="hljs-string">"t42"</span>);  
        t41.start();  <span class="hljs-comment">// 启动t41</span>
        t42.start();  <span class="hljs-comment">// 启动t42</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        LockTest4 demo = <span class="hljs-keyword">new</span> LockTest4();
        demo.test4();
    }
}

t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA
t41 : isSyncA
t42 : cSyncA
</code></pre>
<h1 id="线程等待与唤醒">4 线程等待与唤醒</h1>
<p><strong>wait(), notify(), notifyAll()等方法介绍</strong></p>
<p>Object类中关于等待/唤醒的API详细信息如下：
<strong>notify()</strong>  -- 唤醒在此对象监视器上等待的单个线程。
<strong>notifyAll()</strong>  -- 唤醒在此对象监视器上等待的所有线程。
<strong>wait()</strong> -- 当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。
<strong>wait(long timeout)</strong> -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
<strong>wait(long timeout, int nanos)</strong>  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<p><strong>wait()和notify()示例</strong></p>
<pre><code class="lang-java"><span class="hljs-comment">// WaitTest.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" call notify()"</span>);
            <span class="hljs-comment">// 唤醒当前的wait线程</span>
            notify();
        }
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>);
        <span class="hljs-keyword">synchronized</span>(t1) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 启动“线程t1”</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" start t1"</span>);
                t1.start();
                <span class="hljs-comment">// 主线程等待t1通过notify()唤醒。</span>
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" wait()"</span>);
                t1.wait();
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" continue"</span>);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

<span class="hljs-function">main start t1
main <span class="hljs-title">wait</span><span class="hljs-params">()</span>
t1 call <span class="hljs-title">notify</span><span class="hljs-params">()</span>
main <span class="hljs-keyword">continue</span>

<span class="hljs-comment">// 结果说明：</span>
如下图，说明了“主线程”和“线程t1”的流程。
<span class="hljs-params">(<span class="hljs-number">01</span>)</span> 注意，图中"主线程" 代表“主线程main”。"线程t1" 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。
<span class="hljs-params">(<span class="hljs-number">02</span>)</span> “主线程”通过 new <span class="hljs-title">ThreadA</span><span class="hljs-params">(<span class="hljs-string">"t1"</span>)</span> 新建“线程t1”。随后通过<span class="hljs-title">synchronized</span><span class="hljs-params">(t1)</span>获取“t1对象的同步锁”。然后调用t1.<span class="hljs-title">start</span><span class="hljs-params">()</span>启动“线程t1”。
<span class="hljs-params">(<span class="hljs-number">03</span>)</span> “主线程”执行t1.<span class="hljs-title">wait</span><span class="hljs-params">()</span> 释放“t1对象的锁”并且进入“等待<span class="hljs-params">(阻塞)</span>状态”。等待t1对象上的线程通过<span class="hljs-title">notify</span><span class="hljs-params">()</span> 或 <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>将其唤醒。
<span class="hljs-params">(<span class="hljs-number">04</span>)</span> “线程t1”运行之后，通过<span class="hljs-title">synchronized</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span>获取“当前对象的锁”；接着调用<span class="hljs-title">notify</span><span class="hljs-params">()</span>唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。
<span class="hljs-params">(<span class="hljs-number">05</span>)</span> “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。
</span></code></pre>
<p><a href="https://images0.cnblogs.com/blog/497634/201312/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png" target="_blank"></a><a data-lightbox="c73de1cf-248f-4cb1-9f03-fe9c5d01923d" data-title="img" href="res/Java%20Thread/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png"><img alt="img" src="res/Java%20Thread/18183712-f04899f92aaa43b6a33a85fecfa60a9d.png"/></a></p>
<p>jdk文档中关于wait的一段介绍：</p>
<pre><code class="lang-java"><span class="hljs-function">Causes the current thread to wait until another thread invokes the <span class="hljs-title">notify</span><span class="hljs-params">()</span> method or the <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span> method <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> object. 
In other words, <span class="hljs-keyword">this</span> method behaves exactly as <span class="hljs-keyword">if</span> it simply performs the call <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>.
The current thread must own <span class="hljs-keyword">this</span> object's monitor. The thread releases ownership of <span class="hljs-keyword">this</span> monitor and waits until another thread notifies threads waiting on <span class="hljs-keyword">this</span> object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.
引起“当前线程”等待，直到另外一个线程调用<span class="hljs-title">notify</span><span class="hljs-params">()</span>或<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>唤醒该线程。换句话说，这个方法和<span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>的效果一样！<span class="hljs-params">(补充，对于wait(<span class="hljs-keyword">long</span> millis)</span>方法，当millis为0时，表示无限等待，直到被<span class="hljs-title">notify</span><span class="hljs-params">()</span>或<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>唤醒)。
“当前线程”在调用<span class="hljs-title">wait</span><span class="hljs-params">()</span>时，必须拥有该对象的同步锁。该线程调用<span class="hljs-title">wait</span><span class="hljs-params">()</span>之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的<span class="hljs-title">notify</span><span class="hljs-params">()</span>或<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。
注意：jdk的解释中，说<span class="hljs-title">wait</span><span class="hljs-params">()</span>的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！
这也意味着，虽然t1.<span class="hljs-title">wait</span><span class="hljs-params">()</span>是通过“线程t1”调用的<span class="hljs-title">wait</span><span class="hljs-params">()</span>方法，但是调用t1.<span class="hljs-title">wait</span><span class="hljs-params">()</span>的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.<span class="hljs-title">wait</span><span class="hljs-params">()</span>。所以，此时的“当前线程”是“主线程main”！因此，t1.<span class="hljs-title">wait</span><span class="hljs-params">()</span>是让“主线程”等待，而不是“线程t1”！
</span></code></pre>
<p><strong>wait(long timeout)和notify()</strong></p>
<pre><code class="lang-java">wait(<span class="hljs-keyword">long</span> timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
<span class="hljs-comment">// WaitTimeoutTest.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" run "</span>);
        <span class="hljs-comment">// 死循环，不断运行。</span>
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)
            ;
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitTimeoutTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>);
        <span class="hljs-keyword">synchronized</span>(t1) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">// 启动“线程t1”</span>
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" start t1"</span>);
                t1.start();
                <span class="hljs-comment">// 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。</span>
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" call wait "</span>);
                t1.wait(<span class="hljs-number">3000</span>);
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" continue"</span>);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

main start t1
main call wait 
t1 run                  <span class="hljs-comment">// 大约3秒之后...输出“main continue”</span>
main <span class="hljs-keyword">continue</span>

<span class="hljs-comment">// 结果说明：</span>
如下图，说明了“主线程”和“线程t1”的流程。
(<span class="hljs-number">01</span>) 注意，图中<span class="hljs-string">"主线程"</span> 代表WaitTimeoutTest主线程(即，线程main)。<span class="hljs-string">"线程t1"</span> 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。
(<span class="hljs-number">02</span>) 主线程main执行t1.start()启动“线程t1”。
(<span class="hljs-number">03</span>) 主线程main执行t1.wait(<span class="hljs-number">3000</span>)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时<span class="hljs-number">3000</span>ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。
(<span class="hljs-number">04</span>) “线程t1”运行之后，进入了死循环，一直不断的运行。
(<span class="hljs-number">05</span>) 超时<span class="hljs-number">3000</span>ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。
</code></pre>
<p><a href="https://images0.cnblogs.com/blog/497634/201312/18183848-d4c16bf2760847afa4fede6a9d959083.png" target="_blank"></a><a data-lightbox="b17d41ca-1a3f-4f8d-bbb7-b801a92a02a3" data-title="img" href="res/Java%20Thread/18183848-d4c16bf2760847afa4fede6a9d959083.png"><img alt="img" src="res/Java%20Thread/18183848-d4c16bf2760847afa4fede6a9d959083.png"/></a></p>
<p><strong>wait() 和 notifyAll()</strong></p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifyAllTest</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>);
        ThreadA t2 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t2"</span>);
        ThreadA t3 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t3"</span>);
        t1.start();
        t2.start();
        t3.start();
        <span class="hljs-keyword">try</span> {
            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" sleep(3000)"</span>);
            Thread.sleep(<span class="hljs-number">3000</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        <span class="hljs-keyword">synchronized</span>(obj) {
            <span class="hljs-comment">// 主线程等待唤醒。</span>
            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" notifyAll()"</span>);
            obj.notifyAll();
        }
    }
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span></span>{
            <span class="hljs-keyword">super</span>(name);
        }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">synchronized</span> (obj) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 打印输出结果</span>
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" wait"</span>);
                    <span class="hljs-comment">// 唤醒当前的wait线程</span>
                    obj.wait();
                    <span class="hljs-comment">// 打印输出结果</span>
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" continue"</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

<span class="hljs-function">t1 wait
main <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">3000</span>)</span>
t3 wait
t2 wait
main <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>
t2 <span class="hljs-keyword">continue</span>
t3 <span class="hljs-keyword">continue</span>
t1 <span class="hljs-keyword">continue</span>

<span class="hljs-comment">// 结果说明：</span>
参考下面的流程图。 
<span class="hljs-params">(<span class="hljs-number">01</span>)</span> 主线程中新建并且启动了3个线程"t1", "t2"和"t3"。
<span class="hljs-params">(<span class="hljs-number">02</span>)</span> 主线程通过<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">3000</span>)</span>休眠3秒。在主线程休眠3秒的过程中，我们假设"t1", "t2"和"t3"这3个线程都运行了。以"t1"为例，当它运行的时候，它会执行obj.<span class="hljs-title">wait</span><span class="hljs-params">()</span>等待其它线程通过<span class="hljs-title">notify</span><span class="hljs-params">()</span>或额<span class="hljs-title">nofityAll</span><span class="hljs-params">()</span>来唤醒它；相同的道理，"t2"和"t3"也会等待其它线程通过<span class="hljs-title">nofity</span><span class="hljs-params">()</span>或<span class="hljs-title">nofityAll</span><span class="hljs-params">()</span>来唤醒它们。
<span class="hljs-params">(<span class="hljs-number">03</span>)</span> 主线程休眠3秒之后，接着运行。执行 obj.<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span> 唤醒obj上的等待线程，即唤醒"t1", "t2"和"t3"这3个线程。 紧接着，主线程的<span class="hljs-title">synchronized</span><span class="hljs-params">(obj)</span>运行完毕之后，主线程释放“obj锁”。这样，"t1", "t2"和"t3"就可以获取“obj锁”而继续运行了！
</span></code></pre>
<p><a href="https://images0.cnblogs.com/blog/497634/201312/18183923-95275c066212410f96181704a681f453.png" target="_blank"></a><a data-lightbox="140c8e2a-c231-4997-ab67-42cdf4b125f9" data-title="img" href="res/Java%20Thread/18183923-95275c066212410f96181704a681f453.png"><img alt="img" src="res/Java%20Thread/18183923-95275c066212410f96181704a681f453.png"/></a></p>
<p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>
<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！
OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>
<p>负责唤醒等待线程的那个线程(我们称为“<strong>唤醒线程</strong>”)，它只有在获取“该对象的同步锁”(<strong>这里的同步锁必须和等待线程的同步锁是同一个</strong>)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>
<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>
<h1 id="线程让步yield">5 线程让步yield()</h1>
<p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>
<pre><code class="lang-java"><span class="hljs-comment">// YieldTest.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span></span>{ 
        <span class="hljs-keyword">super</span>(name); 
    } 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{ 
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++){ 
            System.out.printf(<span class="hljs-string">"%s [%d]:%d\n"</span>, <span class="hljs-keyword">this</span>.getName(), <span class="hljs-keyword">this</span>.getPriority(), i); 
            <span class="hljs-comment">// i整除4时，调用yield</span>
            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>)
                Thread.yield();
        } 
    } 
} 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YieldTest</span></span>{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{ 
        ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>); 
        ThreadA t2 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t2"</span>); 
        t1.start(); 
        t2.start();
    } 
}

<span class="hljs-comment">// 结果说明：</span>
“线程t1”在能被<span class="hljs-number">4</span>整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。

t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">0</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">0</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">1</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">2</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">3</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">4</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">5</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">6</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">7</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">8</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">9</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">1</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">2</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">3</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">4</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">5</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">6</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">7</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">8</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">9</span>
</code></pre>
<p><strong>yield() 与 wait()的比较</strong></p>
<p><a href="http://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank">wait()</a>的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：
(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。
(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>
<pre><code class="lang-java"><span class="hljs-comment">// 下面通过示例演示yield()是不会释放锁的。</span>
<span class="hljs-comment">// YieldLockTest.java 的源码</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YieldLockTest</span></span>{ 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{ 
        ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>); 
        ThreadA t2 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t2"</span>); 
        t1.start(); 
        t2.start();
    } 
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span></span>{ 
            <span class="hljs-keyword">super</span>(name); 
        } 
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{ 
            <span class="hljs-comment">// 获取obj对象的同步锁</span>
            <span class="hljs-keyword">synchronized</span> (obj) {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++){ 
                    System.out.printf(<span class="hljs-string">"%s [%d]:%d\n"</span>, <span class="hljs-keyword">this</span>.getName(), <span class="hljs-keyword">this</span>.getPriority(), i); 
                    <span class="hljs-comment">// i整除4时，调用yield</span>
                    <span class="hljs-keyword">if</span> (i%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>)
                        Thread.yield();
                }
            }
        } 
    } 
}

<span class="hljs-comment">// 结果说明：</span>
主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即<span class="hljs-keyword">synchronized</span>(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！

t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">0</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">1</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">2</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">3</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">4</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">5</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">6</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">7</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">8</span>
t1 [<span class="hljs-number">5</span>]:<span class="hljs-number">9</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">0</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">1</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">2</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">3</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">4</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">5</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">6</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">7</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">8</span>
t2 [<span class="hljs-number">5</span>]:<span class="hljs-number">9</span>
</code></pre>
<h1 id="线程休眠sleep">6 线程休眠sleep()</h1>
<p>sleep() 定义在Thread.java中。
sleep() 的作用是让当前线程休眠，即当前线程会从“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" target="_blank">运行状态</a>”进入到“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" target="_blank">休眠(阻塞)状态</a>”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" target="_blank">阻塞状态</a>”变成“<a href="http://www.cnblogs.com/skywang12345/p/3479024.html" target="_blank">就绪状态</a>”，从而等待cpu的调度执行。</p>
<pre><code class="lang-java"><span class="hljs-comment">// SleepTest.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span></span>{ 
        <span class="hljs-keyword">super</span>(name); 
    } 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{ 
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++){ 
                System.out.printf(<span class="hljs-string">"%s: %d\n"</span>, <span class="hljs-keyword">this</span>.getName(), i); 
                <span class="hljs-comment">// i能被4整除时，休眠100毫秒</span>
                <span class="hljs-keyword">if</span> (i%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>)
                    Thread.sleep(<span class="hljs-number">100</span>);
            } 
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    } 
} 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SleepTest</span></span>{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{ 
        ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>); 
        t1.start(); 
    } 
}

<span class="hljs-comment">// 结果说明：</span>
程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被<span class="hljs-number">4</span>整除时，t1会通过Thread.sleep(<span class="hljs-number">100</span>)休眠<span class="hljs-number">100</span>毫秒。

t1: <span class="hljs-number">0</span>
t1: <span class="hljs-number">1</span>
t1: <span class="hljs-number">2</span>
t1: <span class="hljs-number">3</span>
t1: <span class="hljs-number">4</span>
t1: <span class="hljs-number">5</span>
t1: <span class="hljs-number">6</span>
t1: <span class="hljs-number">7</span>
t1: <span class="hljs-number">8</span>
t1: <span class="hljs-number">9</span>
</code></pre>
<p><strong>sleep() 与 wait()的比较</strong></p>
<p>wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。
但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。</p>
<pre><code class="lang-java"><span class="hljs-comment">// SleepLockTest.java的源码</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SleepLockTest</span></span>{ 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object obj = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{ 
        ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>); 
        ThreadA t2 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t2"</span>); 
        t1.start(); 
        t2.start();
    } 
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span></span>{ 
            <span class="hljs-keyword">super</span>(name); 
        } 
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{ 
            <span class="hljs-comment">// 获取obj对象的同步锁</span>
            <span class="hljs-keyword">synchronized</span> (obj) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span>; i++){ 
                        System.out.printf(<span class="hljs-string">"%s: %d\n"</span>, <span class="hljs-keyword">this</span>.getName(), i); 
                        <span class="hljs-comment">// i能被4整除时，休眠100毫秒</span>
                        <span class="hljs-keyword">if</span> (i%<span class="hljs-number">4</span> == <span class="hljs-number">0</span>)
                            Thread.sleep(<span class="hljs-number">100</span>);
                    }
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        } 
    } 
}

<span class="hljs-comment">// 结果说明：</span>
主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即<span class="hljs-keyword">synchronized</span>(obj)。在t1运行过程中，虽然它会调用Thread.sleep(<span class="hljs-number">100</span>)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！
注意，若我们注释掉<span class="hljs-keyword">synchronized</span> (obj)后再次执行该程序，t1和t2是可以相互切换的。

t1: <span class="hljs-number">0</span>
t1: <span class="hljs-number">1</span>
t1: <span class="hljs-number">2</span>
t1: <span class="hljs-number">3</span>
t1: <span class="hljs-number">4</span>
t1: <span class="hljs-number">5</span>
t1: <span class="hljs-number">6</span>
t1: <span class="hljs-number">7</span>
t1: <span class="hljs-number">8</span>
t1: <span class="hljs-number">9</span>
t2: <span class="hljs-number">0</span>
t2: <span class="hljs-number">1</span>
t2: <span class="hljs-number">2</span>
t2: <span class="hljs-number">3</span>
t2: <span class="hljs-number">4</span>
t2: <span class="hljs-number">5</span>
t2: <span class="hljs-number">6</span>
t2: <span class="hljs-number">7</span>
t2: <span class="hljs-number">8</span>
t2: <span class="hljs-number">9</span>
</code></pre>
<h1 id="join-方法">7 join() 方法</h1>
<p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。</p>
<pre><code class="lang-java"><span class="hljs-comment">// 主线程</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        Son s = <span class="hljs-keyword">new</span> Son();
        s.start();
        s.join();
        ...
    }
}
<span class="hljs-comment">// 子线程</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        ...
    }
}

<span class="hljs-comment">// 说明：</span>
上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。
在Father主线程中，通过<span class="hljs-keyword">new</span> Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！

<span class="hljs-comment">// 问题：</span>
虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(<span class="hljs-number">0</span>)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让<span class="hljs-string">"子线程等待才对(因为调用子线程对象s的wait方法嘛)"</span>？
答案：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// JoinTest.java的源码</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinTest</span></span>{ 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{ 
        <span class="hljs-keyword">try</span> {
            ThreadA t1 = <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>); <span class="hljs-comment">// 新建“线程t1”</span>
            t1.start();                     <span class="hljs-comment">// 启动“线程t1”</span>
            t1.join();                        <span class="hljs-comment">// 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”</span>
            System.out.printf(<span class="hljs-string">"%s finish\n"</span>, Thread.currentThread().getName()); 
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    } 

    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadA</span><span class="hljs-params">(String name)</span></span>{ 
            <span class="hljs-keyword">super</span>(name); 
        } 
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{ 
            System.out.printf(<span class="hljs-string">"%s start\n"</span>, <span class="hljs-keyword">this</span>.getName()); 
            <span class="hljs-comment">// 延时操作</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt;<span class="hljs-number">1000000</span>; i++) ;
            System.out.printf(<span class="hljs-string">"%s finish\n"</span>, <span class="hljs-keyword">this</span>.getName()); 
        } 
    } 
}

<span class="hljs-comment">// 结果说明：</span>
运行流程如图 
(<span class="hljs-number">01</span>) 在“主线程main”中通过 <span class="hljs-keyword">new</span> ThreadA(<span class="hljs-string">"t1"</span>) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。
(<span class="hljs-number">02</span>) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。

t1 start
t1 finish
main finish
</code></pre>
<p><a href="https://images0.cnblogs.com/blog/497634/201312/18184312-a72a58e2bda54b17bf669f325ecda377.png" target="_blank"></a><a data-lightbox="ab30e235-eacc-4745-b9aa-3ed788cc703d" data-title="img" href="res/Java%20Thread/18184312-a72a58e2bda54b17bf669f325ecda377.png"><img alt="img" src="res/Java%20Thread/18184312-a72a58e2bda54b17bf669f325ecda377.png"/></a></p>
<h1 id="interrupt和线程终止方式">8 interrupt()和线程终止方式</h1>
<pre><code class="lang-java"><span class="hljs-comment">// 关于interrupt()，java的djk文档描述如下：http://docs.oracle.com/javase/7/docs/api/</span>
Interrupts <span class="hljs-keyword">this</span> thread.
Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of <span class="hljs-keyword">this</span> thread is invoked, which may cause a SecurityException to be thrown.
<span class="hljs-function">If <span class="hljs-keyword">this</span> thread is blocked in an invocation of the <span class="hljs-title">wait</span><span class="hljs-params">()</span>, <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span>, or <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>)</span> methods of the Object class, or of the <span class="hljs-title">join</span><span class="hljs-params">()</span>, <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span>, <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>)</span>, <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span>, or <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>)</span>, methods of <span class="hljs-keyword">this</span> class, then its interrupt status will be cleared and it will receive an InterruptedException.
If <span class="hljs-keyword">this</span> thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.
If <span class="hljs-keyword">this</span> thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as <span class="hljs-keyword">if</span> the selector's wakeup method were invoked.
If none of the previous conditions hold then <span class="hljs-keyword">this</span> thread's interrupt status will be set.
Interrupting a thread that is not alive need not have any effect.

<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>的作用是中断本线程。
本线程中断自己是被允许的；其它线程调用本线程的<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>方法时，会通过<span class="hljs-title">checkAccess</span><span class="hljs-params">()</span>检查权限。这有可能抛出SecurityException异常。
如果本线程是处于阻塞状态：调用线程的<span class="hljs-title">wait</span><span class="hljs-params">()</span>, <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span>或<span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>)</span>会让它进入等待<span class="hljs-params">(阻塞)</span>状态，或者调用线程的<span class="hljs-title">join</span><span class="hljs-params">()</span>, <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span>, <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>)</span>, <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span>, <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>)</span>也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过<span class="hljs-title">wait</span><span class="hljs-params">()</span>进入阻塞状态，此时通过<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>中断该线程；调用<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>会立即将线程的中断标记设为“<span class="hljs-keyword">true</span>”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“<span class="hljs-keyword">false</span>”，同时，会产生一个InterruptedException的异常。
如果线程被阻塞在一个Selector选择器中，那么通过<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>中断它时；线程的中断标记会被设置为<span class="hljs-keyword">true</span>，并且它会立即从选择操作中返回。
如果不属于前面所说的情况，那么通过<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>中断线程时，它的中断标记会被设置为“<span class="hljs-keyword">true</span>”。
中断一个“已终止的线程”不会产生任何操作。
</span></code></pre>
<p><strong>终止线程的方式</strong></p>
<p>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！</p>
<p><strong>终止处于“阻塞状态”的线程</strong></p>
<pre><code class="lang-java">通常，我们通过“中断”方式终止处于“阻塞状态”的线程。
当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为<span class="hljs-keyword">true</span>。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下：

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            <span class="hljs-comment">// 执行任务...</span>
        }
    } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        <span class="hljs-comment">// 由于产生InterruptedException异常，退出while(true)循环，线程终止！</span>
    }
}

说明：在<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)之外，这样就退出了<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)循环！
注意：对InterruptedException的捕获务一般放在<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)循环体的外面，这样，在产生异常时就退出了<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)循环。否则，InterruptedException在<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)循环体之内，就需要额外的添加退出处理。
</code></pre>
<p><strong>终止处于“运行状态”的线程</strong></p>
<pre><code class="lang-java">通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。
<span class="hljs-comment">// (01) 通过“中断标记”终止线程。</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (!isInterrupted()) {
        <span class="hljs-comment">// 执行任务...</span>
    }
}
说明：isInterrupted()是判断线程的中断标记是不是为<span class="hljs-keyword">true</span>。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为<span class="hljs-keyword">true</span>，即isInterrupted()会返回<span class="hljs-keyword">true</span>。此时，就会退出<span class="hljs-keyword">while</span>循环。
注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为<span class="hljs-keyword">true</span>。

<span class="hljs-comment">// (02) 通过“额外添加标记”。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> flag= <span class="hljs-keyword">true</span>;
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopTask</span><span class="hljs-params">()</span> </span>{
    flag = <span class="hljs-keyword">false</span>;
}
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (flag) {
        <span class="hljs-comment">// 执行任务...</span>
    }
}
说明：线程中有一个flag标记，它的默认值是<span class="hljs-keyword">true</span>；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出<span class="hljs-keyword">while</span>循环。
注意：将flag定义为<span class="hljs-keyword">volatile</span>类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。


<span class="hljs-comment">// 综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 1. isInterrupted()保证，只要中断标记为true就终止线程。</span>
        <span class="hljs-keyword">while</span> (!isInterrupted()) {
            <span class="hljs-comment">// 执行任务...</span>
        }
    } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
        <span class="hljs-comment">// 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。</span>
    }
}
</code></pre>
<p><strong>终止线程的示例</strong></p>
<pre><code class="lang-java"><span class="hljs-comment">// 终止线程的示例</span>
<span class="hljs-comment">// interrupt()常常被用来终止“阻塞状态”线程。</span>
<span class="hljs-comment">// Demo1.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {  
            <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (!isInterrupted()) {
                Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                i++;
                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" ("</span>+<span class="hljs-keyword">this</span>.getState()+<span class="hljs-string">") loop "</span> + i);  
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {  
            System.out.println(Thread.currentThread().getName() +<span class="hljs-string">" ("</span>+<span class="hljs-keyword">this</span>.getState()+<span class="hljs-string">") catch InterruptedException."</span>);  
        }
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        <span class="hljs-keyword">try</span> {  
            Thread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t1"</span>);  <span class="hljs-comment">// 新建“线程t1”</span>
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is new."</span>);  
            t1.start();                      <span class="hljs-comment">// 启动“线程t1”</span>
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is started."</span>);  
            <span class="hljs-comment">// 主线程休眠300ms，然后主线程给t1发“中断”指令。</span>
            Thread.sleep(<span class="hljs-number">300</span>);
            t1.interrupt();
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is interrupted."</span>);
            <span class="hljs-comment">// 主线程休眠300ms，然后查看t1的状态。</span>
            Thread.sleep(<span class="hljs-number">300</span>);
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is interrupted now."</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {  
            e.printStackTrace();
        }
    } 
}

<span class="hljs-comment">// 结果说明：</span>
(<span class="hljs-number">01</span>) 主线程main中通过<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t1"</span>)创建线程t1，之后通过t1.start()启动线程t1。
(<span class="hljs-number">02</span>) t1启动之后，会不断的检查它的中断标记，如果中断标记为“<span class="hljs-keyword">false</span>”；则休眠<span class="hljs-number">100</span>ms。
(<span class="hljs-number">03</span>) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“<span class="hljs-keyword">false</span>”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体<span class="hljs-keyword">while</span>之外捕获的异常；因此循环被终止。

t1 (NEW) is <span class="hljs-keyword">new</span>.
t1 (RUNNABLE) is started.
t1 (RUNNABLE) loop <span class="hljs-number">1</span>
t1 (RUNNABLE) loop <span class="hljs-number">2</span>
t1 (TIMED_WAITING) is interrupted.
t1 (RUNNABLE) <span class="hljs-keyword">catch</span> InterruptedException.
t1 (TERMINATED) is interrupted now.
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 通过“额外添加标记”的方式终止“状态状态”的线程的示例</span>
<span class="hljs-comment">// Demo3.java的源码</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> flag= <span class="hljs-keyword">true</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopTask</span><span class="hljs-params">()</span> </span>{
        flag = <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (flag) {
                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 休眠100ms</span>
                    i++;
                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">" ("</span>+<span class="hljs-keyword">this</span>.getState()+<span class="hljs-string">") loop "</span> + i);  
                }
            } <span class="hljs-keyword">catch</span> (InterruptedException ie) {  
                System.out.println(Thread.currentThread().getName() +<span class="hljs-string">" ("</span>+<span class="hljs-keyword">this</span>.getState()+<span class="hljs-string">") catch InterruptedException."</span>);  
            }
        }  
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        <span class="hljs-keyword">try</span> {  
            MyThread t1 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t1"</span>);  <span class="hljs-comment">// 新建“线程t1”</span>
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is new."</span>);  
            t1.start();                      <span class="hljs-comment">// 启动“线程t1”</span>
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is started."</span>);  
            <span class="hljs-comment">// 主线程休眠300ms，然后主线程给t1发“中断”指令。</span>
            Thread.sleep(<span class="hljs-number">300</span>);
            t1.stopTask();
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is interrupted."</span>);
            <span class="hljs-comment">// 主线程休眠300ms，然后查看t1的状态。</span>
            Thread.sleep(<span class="hljs-number">300</span>);
            System.out.println(t1.getName() +<span class="hljs-string">" ("</span>+t1.getState()+<span class="hljs-string">") is interrupted now."</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {  
            e.printStackTrace();
        }
    } 
}

t1 (NEW) is <span class="hljs-keyword">new</span>.
t1 (RUNNABLE) is started.
t1 (RUNNABLE) loop <span class="hljs-number">1</span>
t1 (RUNNABLE) loop <span class="hljs-number">2</span>
t1 (TIMED_WAITING) is interrupted.
t1 (RUNNABLE) loop <span class="hljs-number">3</span>
t1 (TERMINATED) is interrupted now.
</code></pre>
<p>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。</p>
<p>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；</p>
<p>而isInterrupted()仅仅返回中断标记。</p>
<h1 id="线程优先级和守护线程">9 线程优先级和守护线程</h1>
<p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。</p>
<p>java 中有两种线程：<strong>用户线程</strong>和<strong>守护线程</strong>。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。
用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。</p>
<p>JDK 中关于线程优先级和守护线程的介绍如下：</p>
<pre><code class="lang-java">Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a <span class="hljs-keyword">new</span> Thread object, the <span class="hljs-keyword">new</span> thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread <span class="hljs-keyword">if</span> and only <span class="hljs-keyword">if</span> the creating thread is a daemon.

When a Java Virtual Machine starts up, there is usually a single non-<span class="hljs-function">daemon <span class="hljs-title">thread</span> <span class="hljs-params">(which typically calls the method named main of some designated class)</span>. The Java Virtual Machine continues to execute threads until either of the following occurs:

The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.
All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. 
Marks <span class="hljs-keyword">this</span> thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.

每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。

当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过<span class="hljs-title">main</span><span class="hljs-params">()</span>方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：
<span class="hljs-params">(<span class="hljs-number">01</span>)</span> 调用了<span class="hljs-title">exit</span><span class="hljs-params">()</span>方法，并且<span class="hljs-title">exit</span><span class="hljs-params">()</span>有权限被正常执行。
<span class="hljs-params">(<span class="hljs-number">02</span>)</span> 所有的“非守护线程”都死了<span class="hljs-params">(即JVM中仅仅只有“守护线程”)</span>。

每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。
</span></code></pre>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) {
            System.out.println(Thread.currentThread().getName()
                    +<span class="hljs-string">"("</span>+Thread.currentThread().getPriority()+ <span class="hljs-string">")"</span>
                    +<span class="hljs-string">", loop "</span>+i);
        }
    } 
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        System.out.println(Thread.currentThread().getName()
                +<span class="hljs-string">"("</span>+Thread.currentThread().getPriority()+ <span class="hljs-string">")"</span>);
        Thread t1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t1"</span>);    <span class="hljs-comment">// 新建t1</span>
        Thread t2=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t2"</span>);    <span class="hljs-comment">// 新建t2</span>
        t1.setPriority(<span class="hljs-number">1</span>);                <span class="hljs-comment">// 设置t1的优先级为1</span>
        t2.setPriority(<span class="hljs-number">10</span>);                <span class="hljs-comment">// 设置t2的优先级为10</span>
        t1.start();                        <span class="hljs-comment">// 启动t1</span>
        t2.start();                        <span class="hljs-comment">// 启动t2</span>
    }  
}

<span class="hljs-comment">// 结果说明：</span>
(<span class="hljs-number">01</span>) 主线程main的优先级是<span class="hljs-number">5</span>。
(<span class="hljs-number">02</span>) t1的优先级被设为<span class="hljs-number">1</span>，而t2的优先级被设为<span class="hljs-number">10</span>。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。

main(<span class="hljs-number">5</span>)
t1(<span class="hljs-number">1</span>), loop <span class="hljs-number">0</span>
t2(<span class="hljs-number">10</span>), loop <span class="hljs-number">0</span>
t1(<span class="hljs-number">1</span>), loop <span class="hljs-number">1</span>
t2(<span class="hljs-number">10</span>), loop <span class="hljs-number">1</span>
t1(<span class="hljs-number">1</span>), loop <span class="hljs-number">2</span>
t2(<span class="hljs-number">10</span>), loop <span class="hljs-number">2</span>
t1(<span class="hljs-number">1</span>), loop <span class="hljs-number">3</span>
t2(<span class="hljs-number">10</span>), loop <span class="hljs-number">3</span>
t1(<span class="hljs-number">1</span>), loop <span class="hljs-number">4</span>
t2(<span class="hljs-number">10</span>), loop <span class="hljs-number">4</span>
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 守护线程的示例</span>
<span class="hljs-comment">// Demo.java</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) {
                Thread.sleep(<span class="hljs-number">3</span>);
                System.out.println(<span class="hljs-keyword">this</span>.getName() +<span class="hljs-string">"(isDaemon="</span>+<span class="hljs-keyword">this</span>.isDaemon()+ <span class="hljs-string">")"</span> +<span class="hljs-string">", loop "</span>+i);
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
        }
    } 
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDaemon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDaemon</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10000</span>; i++) {
                Thread.sleep(<span class="hljs-number">1</span>);
                System.out.println(<span class="hljs-keyword">this</span>.getName() +<span class="hljs-string">"(isDaemon="</span>+<span class="hljs-keyword">this</span>.isDaemon()+ <span class="hljs-string">")"</span> +<span class="hljs-string">", loop "</span>+i);
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
        }
    } 
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        System.out.println(Thread.currentThread().getName()
                +<span class="hljs-string">"(isDaemon="</span>+Thread.currentThread().isDaemon()+ <span class="hljs-string">")"</span>);
        Thread t1=<span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"t1"</span>);    <span class="hljs-comment">// 新建t1</span>
        Thread t2=<span class="hljs-keyword">new</span> MyDaemon(<span class="hljs-string">"t2"</span>);    <span class="hljs-comment">// 新建t2</span>
        t2.setDaemon(<span class="hljs-keyword">true</span>);                <span class="hljs-comment">// 设置t2为守护线程</span>
        t1.start();                        <span class="hljs-comment">// 启动t1</span>
        t2.start();                        <span class="hljs-comment">// 启动t2</span>
    }  
}

<span class="hljs-comment">// 结果说明：</span>
(<span class="hljs-number">01</span>) 主线程main是用户线程，它创建的子线程t1也是用户线程。
(<span class="hljs-number">02</span>) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。

main(isDaemon=<span class="hljs-keyword">false</span>)
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">0</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">1</span>
t1(isDaemon=<span class="hljs-keyword">false</span>), loop <span class="hljs-number">0</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">2</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">3</span>
t1(isDaemon=<span class="hljs-keyword">false</span>), loop <span class="hljs-number">1</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">4</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">5</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">6</span>
t1(isDaemon=<span class="hljs-keyword">false</span>), loop <span class="hljs-number">2</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">7</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">8</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">9</span>
t1(isDaemon=<span class="hljs-keyword">false</span>), loop <span class="hljs-number">3</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">10</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">11</span>
t1(isDaemon=<span class="hljs-keyword">false</span>), loop <span class="hljs-number">4</span>
t2(isDaemon=<span class="hljs-keyword">true</span>), loop <span class="hljs-number">12</span>
</code></pre>
<h1 id="生产消费者问题">10 生产消费者问题</h1>
<p>生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括<strong>“生产者”、“消费者”、“仓库”和“产品”</strong>。他们之间的关系如下：
(01) 生产者仅仅在仓储未满时候生产，仓满则停止生产。
(02) 消费者仅仅在仓储有产品时候才能消费，仓空则等待。
(03) 当消费者发现仓储没产品可消费时候会通知生产者生产。
(04) 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</p>
<pre><code class="lang-java"><span class="hljs-comment">// 通过wait()/notify()方式实现该模型(后面在学习了线程池相关内容之后，再通过其它方式实现生产/消费者模型)。</span>
<span class="hljs-comment">// Demo1.java</span>
<span class="hljs-comment">// 仓库</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Depot</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-comment">// 仓库的容量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;        <span class="hljs-comment">// 仓库的实际数量</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Depot</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>{
        <span class="hljs-keyword">this</span>.capacity = capacity;
        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>{
        <span class="hljs-keyword">try</span> {
             <span class="hljs-comment">// left 表示“想要生产的数量”(有可能生产量太多，需多此生产)</span>
            <span class="hljs-keyword">int</span> left = val;
            <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 库存已满时，等待“消费者”消费产品。</span>
                <span class="hljs-keyword">while</span> (size &gt;= capacity)
                    wait();
                <span class="hljs-comment">// 获取“实际生产的数量”(即库存中新增的数量)</span>
                <span class="hljs-comment">// 如果“库存”+“想要生产的数量”&gt;“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库)</span>
                <span class="hljs-comment">// 否则“实际增量”=“想要生产的数量”</span>
                <span class="hljs-keyword">int</span> inc = (size+left)&gt;capacity ? (capacity-size) : left;
                size += inc;
                left -= inc;
                System.out.printf(<span class="hljs-string">"%s produce(%3d) --&gt; left=%3d, inc=%3d, size=%3d\n"</span>, 
                        Thread.currentThread().getName(), val, left, inc, size);
                <span class="hljs-comment">// 通知“消费者”可以消费了。</span>
                notifyAll();
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
        }
    } 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费)</span>
            <span class="hljs-keyword">int</span> left = val;
            <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-comment">// 库存为0时，等待“生产者”生产产品。</span>
                <span class="hljs-keyword">while</span> (size &lt;= <span class="hljs-number">0</span>)
                    wait();
                <span class="hljs-comment">// 获取“实际消费的数量”(即库存中实际减少的数量)</span>
                <span class="hljs-comment">// 如果“库存”&lt;“客户要消费的数量”，则“实际消费量”=“库存”；</span>
                <span class="hljs-comment">// 否则，“实际消费量”=“客户要消费的数量”。</span>
                <span class="hljs-keyword">int</span> dec = (size&lt;left) ? size : left;
                size -= dec;
                left -= dec;
                System.out.printf(<span class="hljs-string">"%s consume(%3d) &lt;-- left=%3d, dec=%3d, size=%3d\n"</span>, 
                        Thread.currentThread().getName(), val, left, dec, size);
                notifyAll();
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"capacity:"</span>+capacity+<span class="hljs-string">", actual size:"</span>+size;
    }
} 

<span class="hljs-comment">// 生产者</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>{
    <span class="hljs-keyword">private</span> Depot depot;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(Depot depot)</span> </span>{
        <span class="hljs-keyword">this</span>.depot = depot;
    }
    <span class="hljs-comment">// 消费产品：新建一个线程向仓库中生产产品。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> val)</span> </span>{
        <span class="hljs-keyword">new</span> Thread() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                depot.produce(val);
            }
        }.start();
    }
}

<span class="hljs-comment">// 消费者</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>{
    <span class="hljs-keyword">private</span> Depot depot;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(Depot depot)</span> </span>{
        <span class="hljs-keyword">this</span>.depot = depot;
    }
    <span class="hljs-comment">// 消费产品：新建一个线程从仓库中消费产品。</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> val)</span> </span>{
        <span class="hljs-keyword">new</span> Thread() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                depot.consume(val);
            }
        }.start();
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{  
        Depot mDepot = <span class="hljs-keyword">new</span> Depot(<span class="hljs-number">100</span>);
        Producer mPro = <span class="hljs-keyword">new</span> Producer(mDepot);
        Customer mCus = <span class="hljs-keyword">new</span> Customer(mDepot);
        mPro.produce(<span class="hljs-number">60</span>);
        mPro.produce(<span class="hljs-number">120</span>);
        mCus.consume(<span class="hljs-number">90</span>);
        mCus.consume(<span class="hljs-number">150</span>);
        mPro.produce(<span class="hljs-number">110</span>);
    }
}

<span class="hljs-comment">// 说明：</span>
(<span class="hljs-number">01</span>) Producer是“生产者”类，它与“仓库(depot)”关联。当调用“生产者”的produce()方法时，它会新建一个线程并向“仓库”中生产产品。
(<span class="hljs-number">02</span>) Customer是“消费者”类，它与“仓库(depot)”关联。当调用“消费者”的consume()方法时，它会新建一个线程并消费“仓库”中的产品。
(<span class="hljs-number">03</span>) Depot是“仓库”类，仓库中记录“仓库的容量(capacity)”以及“仓库中当前产品数目(size)”。
    “仓库”类的生产方法produce()和消费方法consume()方法都是<span class="hljs-keyword">synchronized</span>方法，进入<span class="hljs-keyword">synchronized</span>方法体，意味着这个线程获取到了该“仓库”对象的同步锁。这也就是说，同一时间，生产者和消费者线程只能有一个能运行。通过同步锁，实现了对“残酷”的互斥访问。
    对于生产方法produce()而言：当仓库满时，生产者线程等待，需要等待消费者消费产品之后，生产线程才能生产；生产者线程生产完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“消费者线程”，即我们所说的“通知消费者进行消费”。
    对于消费方法consume()而言：当仓库为空时，消费者线程等待，需要等待生产者生产产品之后，消费者线程才能消费；消费者线程消费完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“生产者线程”，即我们所说的“通知生产者进行生产”。

Thread-<span class="hljs-number">0</span> produce( <span class="hljs-number">60</span>) --&gt; left=  <span class="hljs-number">0</span>, inc= <span class="hljs-number">60</span>, size= <span class="hljs-number">60</span>
Thread-<span class="hljs-number">4</span> produce(<span class="hljs-number">110</span>) --&gt; left= <span class="hljs-number">70</span>, inc= <span class="hljs-number">40</span>, size=<span class="hljs-number">100</span>
Thread-<span class="hljs-number">2</span> consume( <span class="hljs-number">90</span>) &lt;-- left=  <span class="hljs-number">0</span>, dec= <span class="hljs-number">90</span>, size= <span class="hljs-number">10</span>
Thread-<span class="hljs-number">3</span> consume(<span class="hljs-number">150</span>) &lt;-- left=<span class="hljs-number">140</span>, dec= <span class="hljs-number">10</span>, size=  <span class="hljs-number">0</span>
Thread-<span class="hljs-number">1</span> produce(<span class="hljs-number">120</span>) --&gt; left= <span class="hljs-number">20</span>, inc=<span class="hljs-number">100</span>, size=<span class="hljs-number">100</span>
Thread-<span class="hljs-number">3</span> consume(<span class="hljs-number">150</span>) &lt;-- left= <span class="hljs-number">40</span>, dec=<span class="hljs-number">100</span>, size=  <span class="hljs-number">0</span>
Thread-<span class="hljs-number">4</span> produce(<span class="hljs-number">110</span>) --&gt; left=  <span class="hljs-number">0</span>, inc= <span class="hljs-number">70</span>, size= <span class="hljs-number">70</span>
Thread-<span class="hljs-number">3</span> consume(<span class="hljs-number">150</span>) &lt;-- left=  <span class="hljs-number">0</span>, dec= <span class="hljs-number">40</span>, size= <span class="hljs-number">30</span>
Thread-<span class="hljs-number">1</span> produce(<span class="hljs-number">120</span>) --&gt; left=  <span class="hljs-number">0</span>, inc= <span class="hljs-number">20</span>, size= <span class="hljs-number">50</span>
</code></pre>
<p></p><footer class="page-footer"><span class="copyright">Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-03-04 02:09:53
</span></footer><hr/><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el: "#vcomments",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false})</script><p></p>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 多线程" class="navigation navigation-prev" href="多线程.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: 多线程_锁" class="navigation navigation-next" href="多线程_锁.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"多线程_基础篇","level":"1.3.1","depth":2,"next":{"title":"多线程_锁","level":"1.3.2","depth":2,"path":"chapters/多线程_锁.md","ref":"chapters/多线程_锁.md","articles":[]},"previous":{"title":"多线程","level":"1.3","depth":1,"path":"chapters/多线程.md","ref":"chapters/多线程.md","articles":[{"title":"多线程_基础篇","level":"1.3.1","depth":2,"path":"chapters/多线程_基础篇.md","ref":"chapters/多线程_基础篇.md","articles":[]},{"title":"多线程_锁","level":"1.3.2","depth":2,"path":"chapters/多线程_锁.md","ref":"chapters/多线程_锁.md","articles":[]},{"title":"多线程_JUC原子类","level":"1.3.3","depth":2,"path":"chapters/多线程_JUC原子类.md","ref":"chapters/多线程_JUC原子类.md","articles":[]},{"title":"多线程_JUC锁集合","level":"1.3.4","depth":2,"path":"chapters/多线程_JUC锁集合.md","ref":"chapters/多线程_JUC锁集合.md","articles":[]},{"title":"多线程_JUC集合","level":"1.3.5","depth":2,"path":"chapters/多线程_JUC集合.md","ref":"chapters/多线程_JUC集合.md","articles":[]},{"title":"多线程_JUC线程池","level":"1.3.6","depth":2,"path":"chapters/多线程_JUC线程池.md","ref":"chapters/多线程_JUC线程池.md","articles":[]},{"title":"多线程_生产者消费者","level":"1.3.7","depth":2,"path":"chapters/多线程_生产者消费者.md","ref":"chapters/多线程_生产者消费者.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["-sharing","splitter","expandable-chapters-small","anchors","github","github-buttons","donate","sharing-plus","anchor-navigation-ex","mathjax","mermaid-gb3","tbfed-pagefooter","code","favicon","search-plus","-lunr","-search","lightbox","change_girls","theme-comscore","valine","pageview-count","favicon-absolute"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright © narutohyc.com 2022","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/narutohyc"},"splitter":{},"change_girls":{"time":10,"urls":["https://plc.jj20.com/up/allimg/1115/012122143136/220121143136-2.jpg","https://plc.jj20.com/up/allimg/1115/111R1094405/21111P94405-1.jpg"]},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"donate":{"alipay":"https://i.loli.net/2021/01/12/Cdunm9AoBcHF5MI.png","alipayText":"支付宝打赏","button":"赏","title":"","wechat":"https://i.loli.net/2021/01/12/gmzASfCciIFXTyr.png","wechatText":"微信打赏"},"favicon-absolute":{"appleTouchIconMore":{},"appleTouchIconPrecomposed152":"./chapters/res/other/favicon.ico","appleTouchIconPrecomposedMore":{},"favicon":"./chapters/res/other/favicon.ico"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"favicon":{},"lightbox":{"jquery":true,"sameUuid":false},"theme-comscore":{},"pageview-count":{},"github-buttons":{"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]},"mathjax":{"forceSVG":false,"version":"2.6-latest"},"expandable-chapters-small":{},"sharing":{"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"],"douban":true,"facebook":true,"weibo":true,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":false,"google":true,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{},"valine":{"avatar":"","lang":"zh-CN","pageSize":10,"placeholder":"Just go go","recordIP":false,"appId":"jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz","appKey":"FOXMptWOHC7cU1FxXt0LJj4o"},"search-plus":{}},"theme":"default","author":"narutohyc","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Java相关学习记录","language":"zh-hans","links":{"sidebar":{"我的狗窝":"https://github.com/narutohyc"}},"gitbook":"*","description":"记录 Java 的学习和一些技巧的使用"},"file":{"path":"chapters/多线程_基础篇.md","mtime":"2022-03-04T02:09:53.903Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-03-04T02:11:26.042Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>
<script src="../gitbook/gitbook.js"></script>
<script src="../gitbook/theme.js"></script>
<script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
<script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
<script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
<script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="../gitbook/gitbook-plugin-lightbox/js/lightbox.min.js"></script>
<script src="../gitbook/gitbook-plugin-change_girls/girls.js"></script>
<script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>
</body>
</html>
