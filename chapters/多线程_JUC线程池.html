<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>多线程_JUC线程池 · Java相关学习记录</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="" name="description"/>
<meta content="GitBook 3.2.3" name="generator"/>
<meta content="narutohyc" name="author"/>
<link href="../gitbook/style.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-splitter/splitter.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchors/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-donate/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-code/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-search-plus/search.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-lightbox/css/lightbox.min.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-change_girls/girls.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-pageview-count/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-highlight/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-fontsettings/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-theme-comscore/test.css" rel="stylesheet"/>
<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<link href="../gitbook/images/apple-touch-icon-precomposed-152.png" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../gitbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="多线程_生产者消费者.html" rel="next"/>
<link href="多线程_ JUC集合.html" rel="prev"/>
<link href="./chapters/res/other/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="./chapters/res/other/favicon.ico" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
<script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]};
    </script>
</head>
<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="输入并搜索" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="https://github.com/narutohyc" target="_blank">我的狗窝</a>
</li>
<li class="divider"></li>
<li class="chapter" data-level="1.1" data-path="../">
<a href="../">
<b>1.1.</b>
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="设计模式.html">
<a href="设计模式.html">
<b>1.2.</b>
                    
                    设计模式
            
                </a>
</li>
<li class="chapter" data-level="1.3" data-path="多线程.md">
<span>
<b>1.3.</b>
                    
                    多线程
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="多线程_基础篇.html">
<a href="多线程_基础篇.html">
<b>1.3.1.</b>
                    
                    多线程_基础篇
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="多线程_锁.html">
<a href="多线程_锁.html">
<b>1.3.2.</b>
                    
                    多线程_锁
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="多线程_JUC原子类.html">
<a href="多线程_JUC原子类.html">
<b>1.3.3.</b>
                    
                    多线程_JUC原子类
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="多线程_JUC锁集合 .html">
<a href="多线程_JUC锁集合 .html">
<b>1.3.4.</b>
                    
                    多线程_JUC锁集合 
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="多线程_ JUC集合.html">
<a href="多线程_ JUC集合.html">
<b>1.3.5.</b>
                    
                    多线程_ JUC集合
            
                </a>
</li>
<li class="chapter active" data-level="1.3.6" data-path="多线程_JUC线程池.html">
<a href="多线程_JUC线程池.html">
<b>1.3.6.</b>
                    
                    多线程_JUC线程池
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="多线程_生产者消费者.html">
<a href="多线程_生产者消费者.html">
<b>1.3.7.</b>
                    
                    多线程_生产者消费者
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.4" data-path="IDEA快捷键.html">
<a href="IDEA快捷键.html">
<b>1.4.</b>
                    
                    IDEA快捷键
            
                </a>
</li>
<li class="chapter" data-level="1.5" data-path="Spring注解.md">
<span>
<b>1.5.</b>
                    
                    Spring注解
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="Spring注解_介绍.html">
<a href="Spring注解_介绍.html">
<b>1.5.1.</b>
                    
                    Spring注解_介绍
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="Spring注解_常用注解.html">
<a href="Spring注解_常用注解.html">
<b>1.5.2.</b>
                    
                    Spring注解_常用注解
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="Spring注解_Spring入门篇.html">
<a href="Spring注解_Spring入门篇.html">
<b>1.5.3.</b>
                    
                    Spring注解_Spring入门篇
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.6" data-path="Java基础.md">
<span>
<b>1.6.</b>
                    
                    Java基础
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="Java基础_集合.html">
<a href="Java基础_集合.html">
<b>1.6.1.</b>
                    
                    Java基础_集合
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="Java基础_泛型.html">
<a href="Java基础_泛型.html">
<b>1.6.2.</b>
                    
                    Java基础_泛型
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="Java基础_打jar包.html">
<a href="Java基础_打jar包.html">
<b>1.6.3.</b>
                    
                    Java基础_打jar包
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="Java基础_正则匹配.html">
<a href="Java基础_正则匹配.html">
<b>1.6.4.</b>
                    
                    Java基础_正则匹配
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="Java基础_反射机制.html">
<a href="Java基础_反射机制.html">
<b>1.6.5.</b>
                    
                    Java基础_反射机制
            
                </a>
</li>
<li class="chapter" data-level="1.6.6" data-path="Java基础_对象正反序列化.html">
<a href="Java基础_对象正反序列化.html">
<b>1.6.6.</b>
                    
                    Java基础_对象正反序列化
            
                </a>
</li>
<li class="chapter" data-level="1.6.7" data-path="Java基础_读取配置文件.html">
<a href="Java基础_读取配置文件.html">
<b>1.6.7.</b>
                    
                    Java基础_读取配置文件
            
                </a>
</li>
<li class="chapter" data-level="1.6.8" data-path="Java基础_解析与生成XML.html">
<a href="Java基础_解析与生成XML.html">
<b>1.6.8.</b>
                    
                    Java基础_解析与生成XML
            
                </a>
</li>
<li class="chapter" data-level="1.6.9" data-path="Java基础_后台服务器开发.html">
<a href="Java基础_后台服务器开发.html">
<b>1.6.9.</b>
                    
                    Java基础_后台服务器开发
            
                </a>
</li>
<li class="chapter" data-level="1.6.10" data-path="Java基础_四舍五入.html">
<a href="Java基础_四舍五入.html">
<b>1.6.10.</b>
                    
                    Java基础_四舍五入
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.7" data-path="Java进阶.md">
<span>
<b>1.7.</b>
                    
                    Java进阶
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="Java进阶_反射.html">
<a href="Java进阶_反射.html">
<b>1.7.1.</b>
                    
                    Java进阶_反射
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="Java进阶_注解.html">
<a href="Java进阶_注解.html">
<b>1.7.2.</b>
                    
                    Java进阶_注解
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.8" data-path="MySQL.md">
<span>
<b>1.8.</b>
                    
                    MySQL
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.8.1" data-path="MySQL_基础.html">
<a href="MySQL_基础.html">
<b>1.8.1.</b>
                    
                    MySQL_基础
            
                </a>
</li>
<li class="chapter" data-level="1.8.2" data-path="MySQL_约束.html">
<a href="MySQL_约束.html">
<b>1.8.2.</b>
                    
                    MySQL_约束
            
                </a>
</li>
<li class="chapter" data-level="1.8.3" data-path="MySQL_多表查询.html">
<a href="MySQL_多表查询.html">
<b>1.8.3.</b>
                    
                    MySQL_多表查询
            
                </a>
</li>
<li class="chapter" data-level="1.8.4" data-path="MySQL_事务.html">
<a href="MySQL_事务.html">
<b>1.8.4.</b>
                    
                    MySQL_事务
            
                </a>
</li>
<li class="chapter" data-level="1.8.5" data-path="MySQL_数据库设计.html">
<a href="MySQL_数据库设计.html">
<b>1.8.5.</b>
                    
                    MySQL_数据库设计
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.9" data-path="JDBC.md">
<span>
<b>1.9.</b>
                    
                    JDBC
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.9.1" data-path="JDBC_JDBC基础.html">
<a href="JDBC_JDBC基础.html">
<b>1.9.1.</b>
                    
                    JDBC_JDBC基础
            
                </a>
</li>
<li class="chapter" data-level="1.9.2" data-path="JDBC_JDBC连接池.html">
<a href="JDBC_JDBC连接池.html">
<b>1.9.2.</b>
                    
                    JDBC_JDBC连接池
            
                </a>
</li>
<li class="chapter" data-level="1.9.3" data-path="JDBC_JDBCTemplate.html">
<a href="JDBC_JDBCTemplate.html">
<b>1.9.3.</b>
                    
                    JDBC_JDBCTemplate
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.10" data-path="Spark集群搭建.html">
<a href="Spark集群搭建.html">
<b>1.10.</b>
                    
                    Spark集群搭建
            
                </a>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            本书使用 GitBook 发布
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="..">多线程_JUC线程池</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div class="search-plus" id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon"></span><a href="#juc线程池">1 JUC线程池</a></li><ul><li><span class="title-icon"></span><a href="#线程池示例">1.1 线程池示例</a></li></ul><li><span class="title-icon"></span><a href="#线程池原理上">2 线程池原理(上)</a></li><ul><li><span class="title-icon"></span><a href="#threadpoolexecutor简介">2.1 ThreadPoolExecutor简介</a></li><li><span class="title-icon"></span><a href="#线程池调度">2.2 线程池调度</a></li><li><span class="title-icon"></span><a href="#线程池示例_1">2.3 线程池示例</a></li><li><span class="title-icon"></span><a href="#创建线程池">2.4 创建线程池</a></li><li><span class="title-icon"></span><a href="#添加任务到线程池">2.5 添加任务到线程池</a></li><li><span class="title-icon"></span><a href="#关闭线程池">2.6 关闭线程池</a></li></ul><li><span class="title-icon"></span><a href="#线程池原理下">3 线程池原理(下)</a></li><ul><li><span class="title-icon"></span><a href="#线程状态切换">3.1 线程状态切换</a></li><li><span class="title-icon"></span><a href="#拒绝策略">3.2 拒绝策略</a></li><li><span class="title-icon"></span><a href="#discardpolicy-示例">3.3 DiscardPolicy 示例</a></li><li><span class="title-icon"></span><a href="#discardoldestpolicy-示例">3.4 DiscardOldestPolicy 示例</a></li><li><span class="title-icon"></span><a href="#abortpolicy-示例">3.5 AbortPolicy 示例</a></li><li><span class="title-icon"></span><a href="#callerrunspolicy-示例">3.6 CallerRunsPolicy 示例</a></li></ul><li><span class="title-icon"></span><a href="#callable和future">4 Callable和Future</a></li><ul><li><span class="title-icon"></span><a href="#callable和future的基本用法">4.1 Callable和Future的基本用法</a></li></ul></ul></div><a href="#juc线程池" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><p><a data-lightbox="e4cb41b9-aa29-444d-8761-9a9e5fa7ab14" data-title="img" href="res/other/异世界蕾姆_1.png"><img alt="img" src="res/other/异世界蕾姆_1.png"/></a></p>
<p><li><span class="title-icon"></span><a href="#juc线程池">1 JUC线程池</a></li><ul><li><span class="title-icon"></span><a href="#线程池示例">1.1 线程池示例</a></li></ul><li><span class="title-icon"></span><a href="#线程池原理上">2 线程池原理(上)</a></li><ul><li><span class="title-icon"></span><a href="#threadpoolexecutor简介">2.1 ThreadPoolExecutor简介</a></li><li><span class="title-icon"></span><a href="#线程池调度">2.2 线程池调度</a></li><li><span class="title-icon"></span><a href="#线程池示例_1">2.3 线程池示例</a></li><li><span class="title-icon"></span><a href="#创建线程池">2.4 创建线程池</a></li><li><span class="title-icon"></span><a href="#添加任务到线程池">2.5 添加任务到线程池</a></li><li><span class="title-icon"></span><a href="#关闭线程池">2.6 关闭线程池</a></li></ul><li><span class="title-icon"></span><a href="#线程池原理下">3 线程池原理(下)</a></li><ul><li><span class="title-icon"></span><a href="#线程状态切换">3.1 线程状态切换</a></li><li><span class="title-icon"></span><a href="#拒绝策略">3.2 拒绝策略</a></li><li><span class="title-icon"></span><a href="#discardpolicy-示例">3.3 DiscardPolicy 示例</a></li><li><span class="title-icon"></span><a href="#discardoldestpolicy-示例">3.4 DiscardOldestPolicy 示例</a></li><li><span class="title-icon"></span><a href="#abortpolicy-示例">3.5 AbortPolicy 示例</a></li><li><span class="title-icon"></span><a href="#callerrunspolicy-示例">3.6 CallerRunsPolicy 示例</a></li></ul><li><span class="title-icon"></span><a href="#callable和future">4 Callable和Future</a></li><ul><li><span class="title-icon"></span><a href="#callable和future的基本用法">4.1 Callable和Future的基本用法</a></li></ul></p>
<h1 id="juc线程池">1 JUC线程池</h1>
<p><a href="https://images0.cnblogs.com/blog/497634/201401/07231601-3ee0f7defe5847289e6e308d1d312ed1.jpg" target="_blank"></a><a data-lightbox="ad076817-9638-49e0-ba67-7dcb65fd80d9" data-title="img" href="res/Java%20Thread/07231601-3ee0f7defe5847289e6e308d1d312ed1.jpg"><img alt="img" src="res/Java%20Thread/07231601-3ee0f7defe5847289e6e308d1d312ed1.jpg"/></a></p>
<pre><code class="lang-java"><span class="hljs-number">1</span>. Executor
它是<span class="hljs-string">"执行者"</span>接口，它是来执行任务的。准确的说，Executor提供了execute()接口来执行已提交的 Runnable 任务的对象。Executor存在的目的是提供一种将<span class="hljs-string">"任务提交"</span>与<span class="hljs-string">"任务如何运行"</span>分离开来的机制。
它只包含一个函数接口：
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span>

2. ExecutorService
ExecutorService继承于Executor。它是"执行者服务"接口，它是为"执行者接口Executor"服务而存在的；准确的话，ExecutorService提供了"将任务提交给执行者的接口<span class="hljs-params">(submit方法)</span>"，"让执行者执行任务<span class="hljs-params">(invokeAll, invokeAny方法)</span>"的接口等等。

3. AbstractExecutorService
AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。
AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。
AbstractExecutorService函数列表
由于它的函数列表和ExecutorService一样，这里就不再重复列举了。

4. ThreadPoolExecutor
ThreadPoolExecutor就是大名鼎鼎的"线程池"。它继承于AbstractExecutorService抽象类。

5. ScheduledExecutorService
ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了"延时"和"周期执行"功能的ExecutorService。
ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。

6. ScheduledThreadPoolExecutor
ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了"延时"和"周期执行"功能的ScheduledExecutorService。
ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。

7. Executors
Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。
</span></code></pre>
<h2 id="线程池示例">1.1 线程池示例</h2>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolDemo1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">// 创建一个可重用固定线程数的线程池</span>
        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);
        <span class="hljs-comment">// 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span>
        Thread ta = <span class="hljs-keyword">new</span> MyThread();
        Thread tb = <span class="hljs-keyword">new</span> MyThread();
        Thread tc = <span class="hljs-keyword">new</span> MyThread();
        Thread td = <span class="hljs-keyword">new</span> MyThread();
        Thread te = <span class="hljs-keyword">new</span> MyThread();
        <span class="hljs-comment">// 将线程放入池中进行执行</span>
        pool.execute(ta);
        pool.execute(tb);
        pool.execute(tc);
        pool.execute(td);
        pool.execute(te);
        <span class="hljs-comment">// 关闭线程池</span>
        pool.shutdown();
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">" is running."</span>);
    }
}

运行结果：
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> is running.

结果说明：
主线程中创建了线程池pool，线程池的容量是<span class="hljs-number">2</span>。即，线程池中最多能同时运行<span class="hljs-number">2</span>个线程。
紧接着，将ta,tb,tc,td,te这<span class="hljs-number">3</span>个线程添加到线程池中运行。
最后，通过shutdown()关闭线程池。
</code></pre>
<h1 id="线程池原理上">2 线程池原理(上)</h1>
<h2 id="threadpoolexecutor简介">2.1 ThreadPoolExecutor简介</h2>
<p>ThreadPoolExecutor是线程池类。对于线程池，可以通俗的将它理解为"存放一定数量线程的一个线程集合。线程池允许若个线程同时允许，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。"</p>
<pre><code class="lang-java"><span class="hljs-comment">// 阻塞队列。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;
<span class="hljs-comment">// 互斥锁</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();
<span class="hljs-comment">// 线程集合。一个Worker对应一个线程。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();
<span class="hljs-comment">// “终止条件”，与“mainLock”绑定。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition termination = mainLock.newCondition();
<span class="hljs-comment">// 线程池中线程数量曾经达到过的最大值。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> largestPoolSize;
<span class="hljs-comment">// 已完成任务数量</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> completedTaskCount;
<span class="hljs-comment">// ThreadFactory对象，用于创建线程。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;
<span class="hljs-comment">// 拒绝策略的处理句柄。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;
<span class="hljs-comment">// 保持线程存活时间。</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> keepAliveTime;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> allowCoreThreadTimeOut;
<span class="hljs-comment">// 核心池大小</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> corePoolSize;
<span class="hljs-comment">// 最大池大小</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> maximumPoolSize;
</code></pre>
<p><strong>workers</strong>
    workers是HashSet<work>类型，即它是一个Worker集合。而一个Worker对应一个线程，也就是说线程池通过workers包含了"一个线程集合"。当Worker对应的线程池启动时，它会执行线程池中的任务；当执行完一个任务后，它会从线程池的阻塞队列中取出一个阻塞的任务来继续运行。
    wokers的作用是，线程池通过它实现了"允许多个线程同时运行"。</work></p>
<p><strong>workQueue</strong>
    workQueue是BlockingQueue类型，即它是一个阻塞队列。当线程池中的线程数超过它的容量的时候，线程会进入阻塞队列进行阻塞等待。
    通过workQueue，线程池实现了阻塞功能。</p>
<p><strong>mainLock</strong>
    mainLock是互斥锁，通过mainLock实现了对线程池的互斥访问。</p>
<p><strong>corePoolSize和maximumPoolSize</strong>
    corePoolSize是"核心池大小"，maximumPoolSize是"最大池大小"。它们的作用是调整"线程池中实际运行的线程的数量"。
    例如，当新任务提交给线程池时(通过execute方法)。
          -- 如果此时，线程池中运行的线程数量&lt; corePoolSize，则创建新线程来处理请求。
          -- 如果此时，线程池中运行的线程数量&gt; corePoolSize，但是却&lt; maximumPoolSize；则仅当阻塞队列满时才创建新线程。
          如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。在大多数情况下，核心池大小和最大池大小的值是在创建线程池设置的；但是，也可以使用 setCorePoolSize(int) 和 setMaximumPoolSize(int) 进行动态更改。</p>
<p><strong>poolSize</strong>
    poolSize是当前线程池的实际大小，即线程池中任务的数量。</p>
<p><strong>allowCoreThreadTimeOut和keepAliveTime</strong>
    allowCoreThreadTimeOut表示是否允许"线程在空闲状态时，仍然能够存活"；而keepAliveTime是当线程池处于空闲状态的时候，超过keepAliveTime时间之后，空闲的线程会被终止。</p>
<p><strong>threadFactory</strong>
    threadFactory是ThreadFactory对象。它是一个线程工厂类，"线程池通过ThreadFactory创建线程"。</p>
<p><strong>handler</strong>
    handler是RejectedExecutionHandler类型。它是"线程池拒绝策略"的句柄，也就是说"当某任务添加到线程池中，而线程池拒绝该任务时，线程池会通过handler进行相应的处理"。</p>
<p>综上所说，线程池通过workers来管理"线程集合"，每个线程在启动后，会执行线程池中的任务；当一个任务执行完后，它会从线程池的阻塞队列中取出任务来继续运行。阻塞队列是管理线程池任务的队列，当添加到线程池中的任务超过线程池的容量时，该任务就会进入阻塞队列进行等待。</p>
<h2 id="线程池调度">2.2 线程池调度</h2>
<p><a data-lightbox="8c734a5d-887f-4020-918e-f3fe54161846" data-title="07233652-f7ae34a572fc475bbc2c489da97fbf03.jpg (res/Java%20Thread/07233652-f7ae34a572fc475bbc2c489da97fbf03.jpg)" href="https://images0.cnblogs.com/blog/497634/201401/07233652-f7ae34a572fc475bbc2c489da97fbf03.jpg" target="_blank"><img alt="07233652-f7ae34a572fc475bbc2c489da97fbf03.jpg (res/Java%20Thread/07233652-f7ae34a572fc475bbc2c489da97fbf03.jpg)" src="https://images0.cnblogs.com/blog/497634/201401/07233652-f7ae34a572fc475bbc2c489da97fbf03.jpg"/></a></p>
<p><a data-lightbox="7b0c32c2-0242-4c64-b748-c1acb8b4b698" data-title="img" href="https://images0.cnblogs.com/blog/497634/201401/07233814-6b62871a4a0f447fb71993602f71058a.jpg" target="_blank"><img alt="img" src="https://images0.cnblogs.com/blog/497634/201401/07233814-6b62871a4a0f447fb71993602f71058a.jpg"/></a></p>
<p><strong>说明</strong>：
    在"图-01"中，线程池中有N个任务。"任务1", "任务2", "任务3"这3个任务在执行，而"任务3"到"任务N"在阻塞队列中等待。正在执行的任务，在workers集合中，workers集合包含3个Worker，每一个Worker对应一个Thread线程，Thread线程每次处理一个任务。
    当workers集合中处理完某一个任务之后，会从阻塞队列中取出一个任务来继续执行，如图-02所示。图-02表示"任务1"处理完毕之后，线程池将"任务4"从阻塞队列中取出，放到workers中进行处理。</p>
<h2 id="线程池示例_1">2.3 线程池示例</h2>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolDemo1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">// 创建一个可重用固定线程数的线程池</span>
        ExecutorService pool = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);
        <span class="hljs-comment">// 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口</span>
        Thread ta = <span class="hljs-keyword">new</span> MyThread();
        Thread tb = <span class="hljs-keyword">new</span> MyThread();
        Thread tc = <span class="hljs-keyword">new</span> MyThread();
        Thread td = <span class="hljs-keyword">new</span> MyThread();
        Thread te = <span class="hljs-keyword">new</span> MyThread();
        <span class="hljs-comment">// 将线程放入池中进行执行</span>
        pool.execute(ta);
        pool.execute(tb);
        pool.execute(tc);
        pool.execute(td);
        pool.execute(te);
        <span class="hljs-comment">// 关闭线程池</span>
        pool.shutdown();
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">" is running."</span>);
    }
}

运行结果：

pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> is running.
pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> is running.

示例中，包括了线程池的创建，将任务添加到线程池中，关闭线程池这<span class="hljs-number">3</span>个主要的步骤。
</code></pre>
<h2 id="创建线程池">2.4 创建线程池</h2>
<pre><code class="lang-java"><span class="hljs-number">1</span>. newFixedThreadPool()
newFixedThreadPool()在Executors.java中定义，源码如下：
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,
                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,
                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());
}
说明：newFixedThreadPool(<span class="hljs-keyword">int</span> nThreads)的作用是创建一个线程池，线程池的容量是nThreads。
    newFixedThreadPool()在调用ThreadPoolExecutor()时，会传递一个LinkedBlockingQueue()对象，而LinkedBlockingQueue是单向链表实现的阻塞队列。在线程池中，就是通过该阻塞队列来实现<span class="hljs-string">"当线程池中任务数量超过允许的任务数量时，部分任务会阻塞等待"</span>。

<span class="hljs-number">2</span>. ThreadPoolExecutor()
ThreadPoolExecutor()在ThreadPoolExecutor.java中定义，源码如下：
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,
                          <span class="hljs-keyword">int</span> maximumPoolSize,
                          <span class="hljs-keyword">long</span> keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>{
    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
说明：该函数实际上是调用ThreadPoolExecutor的另外一个构造函数。
说明：在ThreadPoolExecutor()的构造函数中，进行的是初始化工作。
corePoolSize, maximumPoolSize, unit, keepAliveTime和workQueue这些变量的值是已知的，它们都是通过newFixedThreadPool()传递而来。下面看看threadFactory和handler对象。

<span class="hljs-number">2.1</span> ThreadFactory
线程池中的ThreadFactory是一个线程工厂，线程池创建线程都是通过线程工厂对象(threadFactory)来完成的。
上面所说的threadFactory对象，是通过 Executors.defaultThreadFactory()返回的。
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadFactory <span class="hljs-title">defaultThreadFactory</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultThreadFactory();
}
defaultThreadFactory()返回DefaultThreadFactory对象。
说明：ThreadFactory的作用就是提供创建线程的功能的线程工厂。
    它是通过newThread()提供创建线程功能的，下面简单说说newThread()。newThread()创建的线程对应的任务是Runnable对象，它创建的线程都是“非守护线程”而且“线程优先级都是Thread.NORM_PRIORITY”。

<span class="hljs-number">2.2</span> RejectedExecutionHandler
handler是ThreadPoolExecutor中拒绝策略的处理句柄。所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。
线程池默认会采用的是defaultHandler策略，即AbortPolicy策略。在AbortPolicy策略中，线程池拒绝任务时会抛出异常。
</code></pre>
<h2 id="添加任务到线程池">2.5 添加任务到线程池</h2>
<pre><code class="lang-java"><span class="hljs-number">1</span>. execute()
说明：execute()的作用是将任务添加到线程池中执行。它会分为<span class="hljs-number">3</span>种情况进行处理：
    情况<span class="hljs-number">1</span> -- 如果<span class="hljs-string">"线程池中任务数量"</span> &lt; <span class="hljs-string">"核心池大小"</span>时，即线程池中少于corePoolSize个任务；此时就新建一个线程，并将该任务添加到线程中进行执行。
    情况<span class="hljs-number">2</span> -- 如果<span class="hljs-string">"线程池中任务数量"</span> &gt;= <span class="hljs-string">"核心池大小"</span>，并且<span class="hljs-string">"线程池是允许状态"</span>；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认<span class="hljs-string">"线程池的状态"</span>，如果<span class="hljs-string">"第2次读到的线程池状态"</span>和<span class="hljs-string">"第1次读到的线程池状态"</span>不同，则从阻塞队列中删除该任务。
    情况<span class="hljs-number">3</span> -- 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。

<span class="hljs-number">2</span>. addWorker()
说明：addWorker(Runnable firstTask, <span class="hljs-keyword">boolean</span> core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。
    core为<span class="hljs-keyword">true</span>的话，则以corePoolSize为界限，若<span class="hljs-string">"线程池中已有任务数量&gt;=corePoolSize"</span>，则返回<span class="hljs-keyword">false</span>；core为<span class="hljs-keyword">false</span>的话，则以maximumPoolSize为界限，若<span class="hljs-string">"线程池中已有任务数量&gt;=maximumPoolSize"</span>，则返回<span class="hljs-keyword">false</span>。
    addWorker()会先通过<span class="hljs-keyword">for</span>循环不断尝试更新ctl状态，ctl记录了<span class="hljs-string">"线程池中任务数量和线程池状态"</span>。
    更新成功之后，再通过<span class="hljs-keyword">try</span>模块来将任务添加到线程池中，并启动任务所在的线程。
    从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。(<span class="hljs-number">01</span>) 通过将Worker对象添加到<span class="hljs-string">"线程的workers集合"</span>中，从而实现将任务添加到线程池中。 (<span class="hljs-number">02</span>) 通过启动Worker对应的Thread线程，则执行该任务。

<span class="hljs-number">3</span>. submit()
补充说明一点，submit()实际上也是通过调用execute()实现的
</code></pre>
<h2 id="关闭线程池">2.6 关闭线程池</h2>
<pre><code class="lang-java">说明：shutdown()的作用是关闭线程池。
</code></pre>
<h1 id="线程池原理下">3 线程池原理(下)</h1>
<pre><code>线程有5种状态：新建状态，就绪状态，运行状态，阻塞状态，死亡状态。线程池也有5种状态；然而，线程池不同于线程，线程池的5种状态是：Running, SHUTDOWN, STOP, TIDYING, TERMINATED。
</code></pre><pre><code class="lang-java">线程池状态定义代码如下：
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN = <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP = <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING = <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED = <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>{ <span class="hljs-keyword">return</span> rs | wc; }

说明：
ctl是一个AtomicInteger类型的原子对象。ctl记录了<span class="hljs-string">"线程池中的任务数量"</span>和<span class="hljs-string">"线程池状态"</span><span class="hljs-number">2</span>个信息。
ctl共包括<span class="hljs-number">32</span>位。其中，高<span class="hljs-number">3</span>位表示<span class="hljs-string">"线程池状态"</span>，低<span class="hljs-number">29</span>位表示<span class="hljs-string">"线程池中的任务数量"</span>。
RUNNING    -- 对应的高<span class="hljs-number">3</span>位值是<span class="hljs-number">111</span>。
SHUTDOWN   -- 对应的高<span class="hljs-number">3</span>位值是<span class="hljs-number">000</span>。
STOP       -- 对应的高<span class="hljs-number">3</span>位值是<span class="hljs-number">001</span>。
TIDYING    -- 对应的高<span class="hljs-number">3</span>位值是<span class="hljs-number">010</span>。
TERMINATED -- 对应的高<span class="hljs-number">3</span>位值是<span class="hljs-number">011</span>。
</code></pre>
<h2 id="线程状态切换">3.1 线程状态切换</h2>
<p><a data-lightbox="f980ef3a-69bc-41d1-82cc-f73960091f4f" data-title="img" href="res/Java%20Thread/08000847-0a9caed4d6914485b2f56048c668251a.jpg"><img alt="img" src="res/Java%20Thread/08000847-0a9caed4d6914485b2f56048c668251a.jpg"/></a></p>
<p><strong>RUNNING</strong></p>
<p>(01) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态！
道理很简单，在ctl的初始化代码中(如下)，就将它初始化为RUNNING状态，并且"任务数量"初始化为0。</p>
<pre><code class="lang-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>))
</code></pre>
<p><strong>SHUTDOWN</strong></p>
<p>(01) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
(02) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。</p>
<p><strong>STOP</strong></p>
<p>(01) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
(02) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p><strong>TIDYING</strong>
(01) 状态说明：当所有的任务已终止，ctl记录的"任务数量"为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
(02) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。
    当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</p>
<p><strong>TEMINATED</strong>
(01) 状态说明：线程池彻底终止，就变成TERMINATED状态。
(02) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<h2 id="拒绝策略">3.2 拒绝策略</h2>
<p>线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。
当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。</p>
<p>线程池共包括4种拒绝策略，它们分别是：<strong>AbortPolicy</strong>, <strong>CallerRunsPolicy</strong>, <strong>DiscardOldestPolicy</strong>和<strong>DiscardPolicy</strong>。</p>
<pre><code class="lang-java">AbortPolicy         -- 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。
CallerRunsPolicy    -- 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。
DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。
DiscardPolicy       -- 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。
</code></pre>
<p>线程池默认的处理策略是AbortPolicy！</p>
<h2 id="discardpolicy-示例">3.3 DiscardPolicy 示例</h2>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor.DiscardPolicy;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardPolicyDemo</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREADS_SIZE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">// 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。</span>
        ThreadPoolExecutor pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="hljs-number">0</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY));
        <span class="hljs-comment">// 设置线程池的拒绝策略为"丢弃"</span>
        pool.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());
        <span class="hljs-comment">// 新建10个任务，并将它们添加到线程池中。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            Runnable myrun = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">"task-"</span>+i);
            pool.execute(myrun);
        }
        <span class="hljs-comment">// 关闭线程池</span>
        pool.shutdown();
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" is running."</span>);
            Thread.sleep(<span class="hljs-number">100</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}

运行结果：
task-<span class="hljs-number">0</span> is running.
task-<span class="hljs-number">1</span> is running.

结果说明：线程池pool的<span class="hljs-string">"最大池大小"</span>和<span class="hljs-string">"核心池大小"</span>都为<span class="hljs-number">1</span>(THREADS_SIZE)，这意味着<span class="hljs-string">"线程池能同时运行的任务数量最大只能是1"</span>。
线程池pool的阻塞队列是ArrayBlockingQueue，ArrayBlockingQueue是一个有界的阻塞队列，ArrayBlockingQueue的容量为<span class="hljs-number">1</span>。这也意味着线程池的阻塞队列只能有一个线程池阻塞等待。
根据<span class="hljs-string">""</span>中分析的execute()代码可知：线程池中共运行了<span class="hljs-number">2</span>个任务。第<span class="hljs-number">1</span>个任务直接放到Worker中，通过线程去执行；第<span class="hljs-number">2</span>个任务放到阻塞队列中等待。其他的任务都被丢弃了！
</code></pre>
<h2 id="discardoldestpolicy-示例">3.4 DiscardOldestPolicy 示例</h2>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestPolicyDemo</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREADS_SIZE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">// 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。</span>
        ThreadPoolExecutor pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="hljs-number">0</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY));
        <span class="hljs-comment">// 设置线程池的拒绝策略为"DiscardOldestPolicy"</span>
        pool.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());

        <span class="hljs-comment">// 新建10个任务，并将它们添加到线程池中。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            Runnable myrun = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">"task-"</span>+i);
            pool.execute(myrun);
        }
        <span class="hljs-comment">// 关闭线程池</span>
        pool.shutdown();
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" is running."</span>);
            Thread.sleep(<span class="hljs-number">200</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}

运行结果：
task-<span class="hljs-number">0</span> is running.
task-<span class="hljs-number">9</span> is running.

结果说明：将<span class="hljs-string">"线程池的拒绝策略"</span>由DiscardPolicy修改为DiscardOldestPolicy之后，当有任务添加到线程池被拒绝时，线程池会丢弃阻塞队列中末尾的任务，然后将被拒绝的任务添加到末尾。
</code></pre>
<h2 id="abortpolicy-示例">3.5 AbortPolicy 示例</h2>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor.AbortPolicy;
<span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicyDemo</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREADS_SIZE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{

        <span class="hljs-comment">// 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。</span>
        ThreadPoolExecutor pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="hljs-number">0</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY));
        <span class="hljs-comment">// 设置线程池的拒绝策略为"抛出异常"</span>
        pool.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());

        <span class="hljs-keyword">try</span> {

            <span class="hljs-comment">// 新建10个任务，并将它们添加到线程池中。</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
                Runnable myrun = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">"task-"</span>+i);
                pool.execute(myrun);
            }
        } <span class="hljs-keyword">catch</span> (RejectedExecutionException e) {
            e.printStackTrace();
            <span class="hljs-comment">// 关闭线程池</span>
            pool.shutdown();
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" is running."</span>);
            Thread.sleep(<span class="hljs-number">200</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}

(某一次)运行结果：
java.util.concurrent.RejectedExecutionException
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="hljs-number">1774</span>)
    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="hljs-number">768</span>)
    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="hljs-number">656</span>)
    at AbortPolicyDemo.main(AbortPolicyDemo.java:<span class="hljs-number">27</span>)
task-<span class="hljs-number">0</span> is running.
task-<span class="hljs-number">1</span> is running.

结果说明：将<span class="hljs-string">"线程池的拒绝策略"</span>由DiscardPolicy修改为AbortPolicy之后，当有任务添加到线程池被拒绝时，会抛出RejectedExecutionException。
</code></pre>
<h2 id="callerrunspolicy-示例">3.6 CallerRunsPolicy 示例</h2>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;
<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;
<span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallerRunsPolicyDemo</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> THREADS_SIZE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">1</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">// 创建线程池。线程池的"最大池大小"和"核心池大小"都为1(THREADS_SIZE)，"线程池"的阻塞队列容量为1(CAPACITY)。</span>
        ThreadPoolExecutor pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, <span class="hljs-number">0</span>, TimeUnit.SECONDS,
                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(CAPACITY));
        <span class="hljs-comment">// 设置线程池的拒绝策略为"CallerRunsPolicy"</span>
        pool.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());
        <span class="hljs-comment">// 新建10个任务，并将它们添加到线程池中。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            Runnable myrun = <span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-string">"task-"</span>+i);
            pool.execute(myrun);
        }
        <span class="hljs-comment">// 关闭线程池</span>
        pool.shutdown();
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">" is running."</span>);
            Thread.sleep(<span class="hljs-number">100</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
    }
}

(某一次)运行结果：
task-<span class="hljs-number">2</span> is running.
task-<span class="hljs-number">3</span> is running.
task-<span class="hljs-number">4</span> is running.
task-<span class="hljs-number">5</span> is running.
task-<span class="hljs-number">6</span> is running.
task-<span class="hljs-number">7</span> is running.
task-<span class="hljs-number">8</span> is running.
task-<span class="hljs-number">9</span> is running.
task-<span class="hljs-number">0</span> is running.
task-<span class="hljs-number">1</span> is running.

结果说明：将<span class="hljs-string">"线程池的拒绝策略"</span>由DiscardPolicy修改为CallerRunsPolicy之后，当有任务添加到线程池被拒绝时，线程池会将被拒绝的任务添加到<span class="hljs-string">"线程池正在运行的线程"</span>中取运行。
</code></pre>
<h1 id="callable和future">4 Callable和Future</h1>
<p>Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable用于产生结果，Future用于获取结果。</p>
<pre><code class="lang-java"><span class="hljs-number">1</span>. Callable
Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。
为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。
Callable的源码如下：
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>{
    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;
}
说明：从中我们可以看出Callable支持泛型。

<span class="hljs-number">2</span>. Futurejava
Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。
说明：Future用于表示异步计算的结果。它的实现类是FutureTask，在讲解FutureTask之前，我们先看看Callable, Future, FutureTask它们之间的关系图，如下：
</code></pre>
<p><a data-lightbox="88ac01ea-af39-4b00-b5d0-ead10933d72e" data-title="img" href="res/Java%20Thread/111156106192237.jpg"><img alt="img" src="res/Java%20Thread/111156106192237.jpg"/></a></p>
<pre><code class="lang-java">说明：
(<span class="hljs-number">01</span>) RunnableFuture是一个接口，它继承了Runnable和Future这两个接口。RunnableFuture的源码如下：
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;
}
(<span class="hljs-number">02</span>) FutureTask实现了RunnableFuture接口。所以，我们也说它实现了Future接口。
</code></pre>
<h2 id="callable和future的基本用法">4.1 Callable和Future的基本用法</h2>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;
<span class="hljs-keyword">import</span> java.util.concurrent.Future;
<span class="hljs-keyword">import</span> java.util.concurrent.Executors;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>{
    <span class="hljs-meta">@Override</span> 
    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">int</span> sum    = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 执行任务</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++)
            sum += i;
        <span class="hljs-comment">//return sum; </span>
        <span class="hljs-keyword">return</span> Integer.valueOf(sum);
    } 
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTest1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> 
        <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException</span>{
        <span class="hljs-comment">//创建一个线程池</span>
        ExecutorService pool = Executors.newSingleThreadExecutor();
        <span class="hljs-comment">//创建有返回值的任务</span>
        Callable c1 = <span class="hljs-keyword">new</span> MyCallable();
        <span class="hljs-comment">//执行任务并获取Future对象 </span>
        Future f1 = pool.submit(c1);
        <span class="hljs-comment">// 输出结果</span>
        System.out.println(f1.get()); 
        <span class="hljs-comment">//关闭线程池 </span>
        pool.shutdown(); 
    }
}

运行结果：
<span class="hljs-number">4950</span>
结果说明：
　　在主线程main中，通过newSingleThreadExecutor()新建一个线程池。接着创建Callable对象c1，然后再通过pool.submit(c1)将c1提交到线程池中进行处理，并且将返回的结果保存到Future对象f1中。然后，我们通过f1.get()获取Callable中保存的结果；最后通过pool.shutdown()关闭线程池。
</code></pre>
<pre><code class="lang-java"><span class="hljs-number">1</span>. submit()
submit()在java/util/concurrent/AbstractExecutorService.java中实现
说明：submit()通过newTaskFor(task)创建了RunnableFuture对象ftask。它的源码如下：
<span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">RunnableFuture&lt;T&gt; <span class="hljs-title">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FutureTask&lt;T&gt;(callable);
}

<span class="hljs-number">2</span>. FutureTask的构造函数
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> </span>{
    <span class="hljs-keyword">if</span> (callable == <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
    <span class="hljs-comment">// callable是一个Callable对象</span>
    <span class="hljs-keyword">this</span>.callable = callable;
    <span class="hljs-comment">// state记录FutureTask的状态</span>
    <span class="hljs-keyword">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span>
}

<span class="hljs-number">3</span>. FutureTask的run()方法
我们继续回到submit()的源码中。
在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法；ftask的run()方法在java/util/concurrent/FutureTask.java中实现，
说明：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。
</code></pre>
<p></p><footer class="page-footer"><span class="copyright">Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-02-16 06:01:22
</span></footer><hr/><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el: "#vcomments",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false})</script><p></p>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 多线程_ JUC集合" class="navigation navigation-prev" href="多线程_ JUC集合.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: 多线程_生产者消费者" class="navigation navigation-next" href="多线程_生产者消费者.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"多线程_JUC线程池","level":"1.3.6","depth":2,"next":{"title":"多线程_生产者消费者","level":"1.3.7","depth":2,"path":"chapters/多线程_生产者消费者.md","ref":"chapters/多线程_生产者消费者.md","articles":[]},"previous":{"title":"多线程_ JUC集合","level":"1.3.5","depth":2,"path":"chapters/多线程_ JUC集合.md","ref":"chapters/多线程_ JUC集合.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-sharing","splitter","expandable-chapters-small","anchors","github","github-buttons","donate","sharing-plus","anchor-navigation-ex","mathjax","mermaid-gb3","tbfed-pagefooter","code","favicon","search-plus","-lunr","-search","lightbox","change_girls","theme-comscore","valine","pageview-count","favicon-absolute"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright © narutohyc.com 2022","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/narutohyc"},"splitter":{},"change_girls":{"time":10,"urls":["https://plc.jj20.com/up/allimg/1115/012122143136/220121143136-2.jpg","https://plc.jj20.com/up/allimg/1115/111R1094405/21111P94405-1.jpg"]},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"donate":{"alipay":"https://i.loli.net/2021/01/12/Cdunm9AoBcHF5MI.png","alipayText":"支付宝打赏","button":"赏","title":"","wechat":"https://i.loli.net/2021/01/12/gmzASfCciIFXTyr.png","wechatText":"微信打赏"},"favicon-absolute":{"appleTouchIconMore":{},"appleTouchIconPrecomposed152":"./chapters/res/other/favicon.ico","appleTouchIconPrecomposedMore":{},"favicon":"./chapters/res/other/favicon.ico"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"favicon":{},"lightbox":{"jquery":true,"sameUuid":false},"theme-comscore":{},"pageview-count":{},"github-buttons":{"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]},"mathjax":{"forceSVG":false,"version":"2.6-latest"},"expandable-chapters-small":{},"sharing":{"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"],"douban":true,"facebook":true,"weibo":true,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":false,"google":true,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{},"valine":{"avatar":"","lang":"zh-CN","pageSize":10,"placeholder":"Just go go","recordIP":false,"appId":"jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz","appKey":"FOXMptWOHC7cU1FxXt0LJj4o"},"search-plus":{}},"theme":"default","author":"narutohyc","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Java相关学习记录","language":"zh-hans","links":{"sidebar":{"我的狗窝":"https://github.com/narutohyc"}},"gitbook":"*","description":"记录 Java 的学习和一些技巧的使用"},"file":{"path":"chapters/多线程_JUC线程池.md","mtime":"2022-02-16T06:01:22.093Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-02-16T06:03:00.612Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>
<script src="../gitbook/gitbook.js"></script>
<script src="../gitbook/theme.js"></script>
<script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
<script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
<script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
<script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="../gitbook/gitbook-plugin-lightbox/js/lightbox.min.js"></script>
<script src="../gitbook/gitbook-plugin-change_girls/girls.js"></script>
<script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>
</body>
</html>
