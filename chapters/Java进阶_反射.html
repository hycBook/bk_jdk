<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>Java进阶_反射 · Java相关学习记录</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="" name="description"/>
<meta content="GitBook 3.2.3" name="generator"/>
<meta content="narutohyc" name="author"/>
<link href="../gitbook/style.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-splitter/splitter.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchors/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-donate/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-code/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-search-plus/search.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-lightbox/css/lightbox.min.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-change_girls/girls.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-pageview-count/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-highlight/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-fontsettings/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-theme-comscore/test.css" rel="stylesheet"/>
<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<link href="../gitbook/images/apple-touch-icon-precomposed-152.png" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../gitbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="Java进阶_注解.html" rel="next"/>
<link href="Java进阶.md" rel="prev"/>
<link href="./chapters/res/other/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="./chapters/res/other/favicon.ico" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
<script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]};
    </script>
</head>
<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="输入并搜索" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="https://github.com/narutohyc" target="_blank">我的狗窝</a>
</li>
<li class="divider"></li>
<li class="chapter" data-level="1.1" data-path="../">
<a href="../">
<b>1.1.</b>
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="设计模式.html">
<a href="设计模式.html">
<b>1.2.</b>
                    
                    设计模式
            
                </a>
</li>
<li class="chapter" data-level="1.3" data-path="多线程.md">
<span>
<b>1.3.</b>
                    
                    多线程
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="多线程_基础篇.html">
<a href="多线程_基础篇.html">
<b>1.3.1.</b>
                    
                    多线程_基础篇
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="多线程_锁.html">
<a href="多线程_锁.html">
<b>1.3.2.</b>
                    
                    多线程_锁
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="多线程_JUC原子类.html">
<a href="多线程_JUC原子类.html">
<b>1.3.3.</b>
                    
                    多线程_JUC原子类
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="多线程_JUC锁集合 .html">
<a href="多线程_JUC锁集合 .html">
<b>1.3.4.</b>
                    
                    多线程_JUC锁集合 
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="多线程_ JUC集合.html">
<a href="多线程_ JUC集合.html">
<b>1.3.5.</b>
                    
                    多线程_ JUC集合
            
                </a>
</li>
<li class="chapter" data-level="1.3.6" data-path="多线程_JUC线程池.html">
<a href="多线程_JUC线程池.html">
<b>1.3.6.</b>
                    
                    多线程_JUC线程池
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="多线程_生产者消费者.html">
<a href="多线程_生产者消费者.html">
<b>1.3.7.</b>
                    
                    多线程_生产者消费者
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.4" data-path="IDEA快捷键.html">
<a href="IDEA快捷键.html">
<b>1.4.</b>
                    
                    IDEA快捷键
            
                </a>
</li>
<li class="chapter" data-level="1.5" data-path="Spring注解.md">
<span>
<b>1.5.</b>
                    
                    Spring注解
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="Spring注解_介绍.html">
<a href="Spring注解_介绍.html">
<b>1.5.1.</b>
                    
                    Spring注解_介绍
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="Spring注解_常用注解.html">
<a href="Spring注解_常用注解.html">
<b>1.5.2.</b>
                    
                    Spring注解_常用注解
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="Spring注解_Spring入门篇.html">
<a href="Spring注解_Spring入门篇.html">
<b>1.5.3.</b>
                    
                    Spring注解_Spring入门篇
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.6" data-path="Java基础.md">
<span>
<b>1.6.</b>
                    
                    Java基础
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="Java基础_集合.html">
<a href="Java基础_集合.html">
<b>1.6.1.</b>
                    
                    Java基础_集合
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="Java基础_泛型.html">
<a href="Java基础_泛型.html">
<b>1.6.2.</b>
                    
                    Java基础_泛型
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="Java基础_打jar包.html">
<a href="Java基础_打jar包.html">
<b>1.6.3.</b>
                    
                    Java基础_打jar包
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="Java基础_正则匹配.html">
<a href="Java基础_正则匹配.html">
<b>1.6.4.</b>
                    
                    Java基础_正则匹配
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="Java基础_反射机制.html">
<a href="Java基础_反射机制.html">
<b>1.6.5.</b>
                    
                    Java基础_反射机制
            
                </a>
</li>
<li class="chapter" data-level="1.6.6" data-path="Java基础_对象正反序列化.html">
<a href="Java基础_对象正反序列化.html">
<b>1.6.6.</b>
                    
                    Java基础_对象正反序列化
            
                </a>
</li>
<li class="chapter" data-level="1.6.7" data-path="Java基础_读取配置文件.html">
<a href="Java基础_读取配置文件.html">
<b>1.6.7.</b>
                    
                    Java基础_读取配置文件
            
                </a>
</li>
<li class="chapter" data-level="1.6.8" data-path="Java基础_解析与生成XML.html">
<a href="Java基础_解析与生成XML.html">
<b>1.6.8.</b>
                    
                    Java基础_解析与生成XML
            
                </a>
</li>
<li class="chapter" data-level="1.6.9" data-path="Java基础_后台服务器开发.html">
<a href="Java基础_后台服务器开发.html">
<b>1.6.9.</b>
                    
                    Java基础_后台服务器开发
            
                </a>
</li>
<li class="chapter" data-level="1.6.10" data-path="Java基础_四舍五入.html">
<a href="Java基础_四舍五入.html">
<b>1.6.10.</b>
                    
                    Java基础_四舍五入
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.7" data-path="Java进阶.md">
<span>
<b>1.7.</b>
                    
                    Java进阶
            
                
            

            
            <ul class="articles">
<li class="chapter active" data-level="1.7.1" data-path="Java进阶_反射.html">
<a href="Java进阶_反射.html">
<b>1.7.1.</b>
                    
                    Java进阶_反射
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="Java进阶_注解.html">
<a href="Java进阶_注解.html">
<b>1.7.2.</b>
                    
                    Java进阶_注解
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.8" data-path="MySQL.md">
<span>
<b>1.8.</b>
                    
                    MySQL
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.8.1" data-path="MySQL_基础.html">
<a href="MySQL_基础.html">
<b>1.8.1.</b>
                    
                    MySQL_基础
            
                </a>
</li>
<li class="chapter" data-level="1.8.2" data-path="MySQL_约束.html">
<a href="MySQL_约束.html">
<b>1.8.2.</b>
                    
                    MySQL_约束
            
                </a>
</li>
<li class="chapter" data-level="1.8.3" data-path="MySQL_多表查询.html">
<a href="MySQL_多表查询.html">
<b>1.8.3.</b>
                    
                    MySQL_多表查询
            
                </a>
</li>
<li class="chapter" data-level="1.8.4" data-path="MySQL_事务.html">
<a href="MySQL_事务.html">
<b>1.8.4.</b>
                    
                    MySQL_事务
            
                </a>
</li>
<li class="chapter" data-level="1.8.5" data-path="MySQL_数据库设计.html">
<a href="MySQL_数据库设计.html">
<b>1.8.5.</b>
                    
                    MySQL_数据库设计
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.9" data-path="JDBC.md">
<span>
<b>1.9.</b>
                    
                    JDBC
            
                
            

            
            <ul class="articles">
<li class="chapter" data-level="1.9.1" data-path="JDBC_JDBC基础.html">
<a href="JDBC_JDBC基础.html">
<b>1.9.1.</b>
                    
                    JDBC_JDBC基础
            
                </a>
</li>
<li class="chapter" data-level="1.9.2" data-path="JDBC_JDBC连接池.html">
<a href="JDBC_JDBC连接池.html">
<b>1.9.2.</b>
                    
                    JDBC_JDBC连接池
            
                </a>
</li>
<li class="chapter" data-level="1.9.3" data-path="JDBC_JDBCTemplate.html">
<a href="JDBC_JDBCTemplate.html">
<b>1.9.3.</b>
                    
                    JDBC_JDBCTemplate
            
                </a>
</li>
</ul>
</span></li>
<li class="chapter" data-level="1.10" data-path="Spark集群搭建.html">
<a href="Spark集群搭建.html">
<b>1.10.</b>
                    
                    Spark集群搭建
            
                </a>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            本书使用 GitBook 发布
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="..">Java进阶_反射</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div class="search-plus" id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon"></span><a href="#反射概念">1 反射概念</a></li><ul><li><span class="title-icon"></span><a href="#基本概念">1.1 基本概念</a></li><li><span class="title-icon"></span><a href="#代码的三个阶段">1.2 代码的三个阶段</a></li></ul><li><span class="title-icon"></span><a href="#java内存">2 Java内存</a></li><ul><li><span class="title-icon"></span><a href="#类加载过程">2.1 类加载过程</a></li><li><span class="title-icon"></span><a href="#类加载与classloader">2.2 类加载与ClassLoader</a></li><li><span class="title-icon"></span><a href="#类初始化时机">2.3 类初始化时机</a></li><li><span class="title-icon"></span><a href="#类加载器的作用">2.4 类加载器的作用</a></li><li><span class="title-icon"></span><a href="#自定义网络类加载">2.5 自定义网络类加载</a></li></ul><li><span class="title-icon"></span><a href="#class对象获取方式">3 Class对象获取方式</a></li><li><span class="title-icon"></span><a href="#反操作泛型">4 反操作泛型</a></li><li><span class="title-icon"></span><a href="#class对象功能">5 Class对象功能</a></li><ul><li><span class="title-icon"></span><a href="#获取功能">5.1 获取功能</a></li><li><span class="title-icon"></span><a href="#field：成员变量">5.2 Field：成员变量</a></li><li><span class="title-icon"></span><a href="#constructor构造方法">5.3 Constructor:构造方法</a></li></ul><li><span class="title-icon"></span><a href="#method：方法对象">6 Method：方法对象</a></li><ul><li><span class="title-icon"></span><a href="#getname方法">6.1 getName方法</a></li><li><span class="title-icon"></span><a href="#关于获取成员方法们的另外两个方法">6.2 关于获取成员方法们的另外两个方法</a></li></ul></ul></div><a href="#反射概念" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><p><a data-lightbox="a4394cc8-5a06-4bcd-abe4-84ebae9ccab5" data-title="img" href="res/other/异世界蕾姆_1.png"><img alt="img" src="res/other/异世界蕾姆_1.png"/></a></p>
<p><li><span class="title-icon"></span><a href="#反射概念">1 反射概念</a></li><ul><li><span class="title-icon"></span><a href="#基本概念">1.1 基本概念</a></li><li><span class="title-icon"></span><a href="#代码的三个阶段">1.2 代码的三个阶段</a></li></ul><li><span class="title-icon"></span><a href="#java内存">2 Java内存</a></li><ul><li><span class="title-icon"></span><a href="#类加载过程">2.1 类加载过程</a></li><li><span class="title-icon"></span><a href="#类加载与classloader">2.2 类加载与ClassLoader</a></li><li><span class="title-icon"></span><a href="#类初始化时机">2.3 类初始化时机</a></li><li><span class="title-icon"></span><a href="#类加载器的作用">2.4 类加载器的作用</a></li><li><span class="title-icon"></span><a href="#自定义网络类加载">2.5 自定义网络类加载</a></li></ul><li><span class="title-icon"></span><a href="#class对象获取方式">3 Class对象获取方式</a></li><li><span class="title-icon"></span><a href="#反操作泛型">4 反操作泛型</a></li><li><span class="title-icon"></span><a href="#class对象功能">5 Class对象功能</a></li><ul><li><span class="title-icon"></span><a href="#获取功能">5.1 获取功能</a></li><li><span class="title-icon"></span><a href="#field：成员变量">5.2 Field：成员变量</a></li><li><span class="title-icon"></span><a href="#constructor构造方法">5.3 Constructor:构造方法</a></li></ul><li><span class="title-icon"></span><a href="#method：方法对象">6 Method：方法对象</a></li><ul><li><span class="title-icon"></span><a href="#getname方法">6.1 getName方法</a></li><li><span class="title-icon"></span><a href="#关于获取成员方法们的另外两个方法">6.2 关于获取成员方法们的另外两个方法</a></li></ul></p>
<blockquote>
<p><a href="https://www.bilibili.com/video/av56351262" target="_blank">【黑马程序员-Java语言高级部分9.2】Java 反射</a></p>
<p><a href="https://note.youdao.com/ynoteshare1/index.html?id=128508bf6a04968eced81ede9ac1b304&amp;type=note" target="_blank">反射机制笔记</a></p>
<p><a href="https://www.bilibili.com/video/av55440782" target="_blank">【狂神说Java】注解和反射</a></p>
<p><a href="https://www.bilibili.com/video/av48959453?p=9" target="_blank">JAVA注解与反射和类的加载机制第十六个专题</a></p>
</blockquote>
<h1 id="反射概念">1 反射概念</h1>
<h2 id="基本概念">1.1 基本概念</h2>
<blockquote>
<p><strong>框架</strong>：半成品软件，可以在框架的基础上进行软件开发，简化编码。</p>
<p>学习框架并不需要了解反射，但是要是想自己写一个框架，那么就要对反射机制有很深入的了解。</p>
<p><code>反射机制</code>：将类的各个组成部分封装为其他对象，这就是反射机制。</p>
<p>反射的好处：</p>
<blockquote>
<ul>
<li>可以在程序运行过程中，操作这些对象。</li>
<li>可以解耦，提高程序的可扩展性。</li>
<li>假设我们使用的是new这种形式进行对象的实例化。此时如果在项目的某一个小模块中我们的一个实例类丢失了，那么在编译期间就会报错，以导致整个项目无法启动。</li>
<li>对于反射创建对象Class.forName("全类名");这种形式，我们在编译期需要的仅仅只是一个字符串（全类名），在编译期不会报错，这样其他的模块就可以正常的运行，而不会因为一个模块的问题导致整个项目崩溃。这就是Spring框架中<code>IOC控制反转</code>的本质。</li>
</ul>
</blockquote>
<p><code>Reflection(反射)</code>是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（<strong>一个类只有一个Class对象</strong>），这个对象就包含了完整的类的结构信息。</p>
<p>我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p>
<p><a data-lightbox="36343dbd-8930-42ea-917c-a225638358a5" data-title="image-20200309213141544" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309213141544.png"><img alt="image-20200309213141544" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309213141544.png"/></a></p>
</blockquote>
<h2 id="代码的三个阶段">1.2 代码的三个阶段</h2>
<blockquote>
<p><code>Source</code>源代码阶段：*.java被编译成*.class字节码文件。</p>
<p><code>Class</code>类对象阶段：*.class字节码文件被类加载器加载进内存，并将其封装成Class对象（用于在内存中描述字节码文件），Class对象将原字节码文件中的成员变量抽取出来封装成数组Field[]，将原字节码文件中的构造函数抽取出来封装成数组Construction[]，在将成员方法封装成Method[]。</p>
<ul>
<li><p>RunTime运行时阶段：创建对象的过程new。</p>
<p><a data-lightbox="9dba695d-d5f1-4327-9896-9d5fd11aef52" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.bmp"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5.bmp"/></a></p>
</li>
</ul>
</blockquote>
<h1 id="java内存">2 Java内存</h1>
<blockquote>
<p><code>堆</code>: 存放new的对象和数组，被所有的线程共享，不会存放别的对象引用</p>
<p><code>栈</code>: 存放基本变量类型(会包含这个基本类型的具体数值)，引用对象的变量(会存放这个引用在堆里面的具体地址)</p>
<p><code>方法区</code>: 可以被所有的线程共享，包含了所有的class和static变量</p>
</blockquote>
<h2 id="类加载过程">2.1 类加载过程</h2>
<blockquote>
<p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p>
<p><a data-lightbox="d24df889-e3fb-4b0e-8f34-368eb466625c" data-title="image-20200309215702460" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309215702460.png"><img alt="image-20200309215702460" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309215702460.png"/></a></p>
</blockquote>
<h2 id="类加载与classloader">2.2 类加载与ClassLoader</h2>
<blockquote>
<p> <strong>加载</strong>：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象。
   <strong>链接</strong>：将Java类的二进制代码合并到JVM的运行状态之中的过程。</p>
<blockquote>
<p>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</p>
<p>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。
解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。
初始化：执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。</clinit></clinit></p>
<p>类构造器是构造类信息的，不是构造该类对象的构造器。
当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></p>
</blockquote>
</blockquote>
<h2 id="类初始化时机">2.3 类初始化时机</h2>
<blockquote>
<p><code>类主动引用</code>（一定会发生类的初始化）</p>
<blockquote>
<p>当虚拟机启动，先初始化main方法所在的类</p>
<p>new一个类的对象</p>
<p>调用类的静态成员（除了final常量）和静态方法</p>
<p>使用java.lang.reflect包的方法对类进行反射调用</p>
<p>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</p>
</blockquote>
<p><code>类被动引用</code>（不会发生类的初始化）</p>
<blockquote>
<p>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</p>
<p>通过数组定义类引用，不会触发此类的初始化</p>
<p>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</p>
</blockquote>
</blockquote>
<h2 id="类加载器的作用">2.4 类加载器的作用</h2>
<blockquote>
<p> <strong>类加载的作用</strong>：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时
   数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。
   <strong>类缓存</strong>：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象
   <a data-lightbox="71dddbd5-ff90-444e-86c9-2b86c92db642" data-title="image-20200309220115775" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309220115775.png"><img alt="image-20200309220115775" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309220115775.png"/></a></p>
<p> <strong>类加载器作用</strong>是用来把类(class)装载进内存的。</p>
<p>   JVM规范定义了如下类型的类的加载器。</p>
<p> <a data-lightbox="1391ea81-a6ac-405b-ac05-345db0aa033e" data-title="image-20200309220200871" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309220200871.png"><img alt="image-20200309220200871" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309220200871.png"/></a></p>
<pre><code class="lang-java">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(string[] args)</span></span>{
       <span class="hljs-comment">// 获取系统类的加载器 </span>
       ClassLoader systemClassloader = ClassLoader.getsystemclassloade(); 
       System.out.println(systemclassLoader); 
       <span class="hljs-comment">// 获取系统类加载器的父类加载器-一&gt;扩展类加载器 </span>
       ClassLoader parent = systemclassLoader.getParent(); 
       System.out.println(parent); 
       <span class="hljs-comment">// 获取扩展类加载器的父类加载器--&gt;根加载器（C/c++） </span>
       ClassLoader parent1=parent.getParent();
       System.out.println(parent1);
       <span class="hljs-comment">// 测试当前类是哪个加载器加载的 </span>
       ClassLoader classLoader = Class.forName(<span class="hljs-string">"com.reflection.Test"</span>).getClassLoader(); 
       System.out.println(classLoader); 
       <span class="hljs-comment">// 测试JDK内置的类是谁加载的</span>
       classLoader = Class.forName(<span class="hljs-string">"java.lang.object"</span>).getclassLoader(); 
       system.out.println(classloader);
   }
</code></pre>
<p> <a data-lightbox="0164d15d-c06e-4b39-8a5c-7f36c90d9531" data-title="image-20200309220415790" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309220415790.png"><img alt="image-20200309220415790" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309220415790.png"/></a></p>
<p> <a data-lightbox="3e5f88ed-eca3-46f9-a037-7a7ac81ce1c2" data-title="image-20200310194313313" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200310194313313.png"><img alt="image-20200310194313313" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200310194313313.png"/></a></p>
</blockquote>
<h2 id="自定义网络类加载">2.5 自定义网络类加载</h2>
<blockquote>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;
<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-comment">/**
* 自定义网络类加载器
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>{
   <span class="hljs-keyword">private</span> String filePath;
   <span class="hljs-keyword">private</span> String fileExtention = <span class="hljs-string">".class"</span>;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NetworkClassLoader</span><span class="hljs-params">(String filePath)</span> </span>{
       <span class="hljs-keyword">this</span>.filePath = filePath;
   }
   <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">findClass</span><span class="hljs-params">(String name)</span> </span>{
       System.out.println(<span class="hljs-string">"findClass name="</span> + name);
       <span class="hljs-keyword">byte</span>[] bArr = <span class="hljs-keyword">null</span>;
       <span class="hljs-keyword">try</span> {
              bArr = loadClassData(name);
       } <span class="hljs-keyword">catch</span> (IOException e) {
           e.printStackTrace();
       }
       <span class="hljs-keyword">return</span> defineClass(name, bArr, <span class="hljs-number">0</span>, bArr.length);
   }
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] loadClassData(String name) <span class="hljs-keyword">throws</span> IOException {
   <span class="hljs-comment">// name = "annotatonreflection.NetworkClassLoader";</span>
       name = name.replace(<span class="hljs-string">"."</span>, <span class="hljs-string">"/"</span>);
       name += fileExtention;
       File file = <span class="hljs-keyword">new</span> File(filePath, name);
       FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);
       ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();
       <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>;
       <span class="hljs-keyword">while</span> ((len = fileInputStream.read()) != -<span class="hljs-number">1</span>) {
           byteArrayOutputStream.write(len);
       }
       <span class="hljs-keyword">return</span> byteArrayOutputStream.toByteArray();
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
       NetworkClassLoader classLoader = <span class="hljs-keyword">new</span> NetworkClassLoader(<span class="hljs-string">"CDesktop"</span>);
       <span class="hljs-keyword">try</span> {
           Class clazz = classLoader.loadClass(<span class="hljs-string">"annotatonreflection.Person"</span>);
           Object obj = clazz.newInstance();
           System.out.println(obj);
           <span class="hljs-comment">// System.out.println(clazz.getClassLoader());</span>
           ClassLoader classLoader2 = clazz.getClassLoader();
           <span class="hljs-keyword">while</span> (classLoader2 != <span class="hljs-keyword">null</span>) {
               System.out.println(classLoader2);
               classLoader2 = classLoader2.getParent();
           }
           System.out.println(<span class="hljs-string">"引导类加载器"</span>+classLoader2); <span class="hljs-comment">//引导类加载器是null</span>
       } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
           e.printStackTrace();
       } <span class="hljs-keyword">catch</span> (InstantiationException e) {
           e.printStackTrace();
       } <span class="hljs-keyword">catch</span> (IllegalAccessException e) {
           e.printStackTrace();
       }
   }    
}
</code></pre>
</blockquote>
<h1 id="class对象获取方式">3 Class对象获取方式</h1>
<blockquote>
<p>获取Class对象的<code>三种方式</code>对应着java代码在计算机中的<code>三个阶段</code></p>
<ol>
<li><p><code>Source</code>源代码阶段: Class.forName("全类名")：将字节码文件加载进内存，返回Class对象</p>
<p>多用于配置文件，将类名定义在配置文件中。读取文件，加载类。 </p>
</li>
<li><p><code>Class</code>类对象阶段: 类名.class：通过类名的属性class获取</p>
<p>多用于参数的传递 </p>
</li>
<li><p><code>Runtime</code>运行时阶段: 对象.getClass()：getClass()方法是定义在Objec类中的方法</p>
<p>多用于对象的获取字节码的方式  </p>
</li>
</ol>
<p><strong>结论</strong>: 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，无论通过哪一种方式获取的Class对象都是同一个。</p>
<blockquote>
<ul>
<li><p>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。</p>
<p>Class clazz=Person.class；</p>
</li>
<li><p>已知某个类的实例，调用该实例的getClass（）方法获取Class对象</p>
<p>Class clazz=person.getClass()；</p>
</li>
<li><p>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p>
<p>Class clazz=Class.forName("demo01.Student");</p>
</li>
<li><p>内置基本数据类型可以直接用类名.Type</p>
</li>
<li><p>还可以利用ClassLoader我们之后讲解</p>
</li>
</ul>
</blockquote>
<p>哪些类型可以有Class对象？</p>
<blockquote>
<p>class: 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。</p>
<p>interface: 接口</p>
<p>[]: 数组</p>
<p>enum: 枚举</p>
<p>annotation: 注解@interface</p>
<p>primitive type: 基本数据类型</p>
<p>void</p>
</blockquote>
<pre><code class="lang-java"><span class="hljs-comment">//所有关型Class </span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>{ 
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(string[] args)</span></span>{ 
       Class c1 = Object.class; <span class="hljs-comment">// 类</span>
       Class c2 = Comparable.class; <span class="hljs-comment">// 接口</span>
       <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c3</span> </span>= String[].class; <span class="hljs-comment">// 一维数组 </span>
       Class c4 = <span class="hljs-keyword">int</span>[][].class; <span class="hljs-comment">// 二维数组 </span>
       Class c5 = Override.class; <span class="hljs-comment">// 注解 </span>
       Class c6 = ElementType.class; <span class="hljs-comment">// 枚举 </span>
       Class c7 = Integer.class; <span class="hljs-comment">// 基本数据类型</span>
       Class c8 = <span class="hljs-keyword">void</span>.class; <span class="hljs-comment">// void </span>
       Class c9 = Class.class; <span class="hljs-comment">// class </span>
       System.out.println(c1); 
       System.out.println(c2); 
       System.out.println(c3); 
       System.out.println(c4); 
       System.out.println(c5); 
       System.out.println(c6); 
       System.out.println(c7); 
       System.out.println(c8); 
       System.out.println(c9); 
       <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; 
       <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>]; 
       system.out.println(a.getclass().hashcode(); 
   }
}
</code></pre>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>{
     <span class="hljs-comment">// 方式一：Class.forName("全类名");</span>
     Class cls1 = Class.forName(<span class="hljs-string">"com.test.domain.Person"</span>);   <span class="hljs-comment">//P erson自定义实体类</span>
     System.out.println(<span class="hljs-string">"cls1 = "</span> + cls1);

     <span class="hljs-comment">// 方式二：类名.class</span>
     Class cls2 = Person.class;
     System.out.println(<span class="hljs-string">"cls2 = "</span> + cls2);

     <span class="hljs-comment">// 方式三：对象.getClass();</span>
     Person person = <span class="hljs-keyword">new</span> Person();        
     Class cls3 = person.getClass();
     System.out.println(<span class="hljs-string">"cls3 = "</span> + cls3);

     <span class="hljs-comment">// == 比较三个对象</span>
     System.out.println(<span class="hljs-string">"cls1 == cls2 : "</span> + (cls1 == cls2));    <span class="hljs-comment">//true</span>
     System.out.println(<span class="hljs-string">"cls1 == cls3 : "</span> + (cls1 == cls3));    <span class="hljs-comment">//true</span>

        <span class="hljs-comment">// 方式四：基本内置类型的包装类都有一个Type属性 </span>
        Class c4=Integer.TYPE;
        System.out.printin(c4); 
        <span class="hljs-comment">// 获得父类类型 </span>
        Class c5=c1.getsuperclass(); 
        System.out.printin(c5);
}
</code></pre>
<p><a data-lightbox="8186384e-9fcd-42d0-a166-ea66a2c7271a" data-title="image-20200309213256005" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309213256005.png"><img alt="image-20200309213256005" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309213256005.png"/></a></p>
</blockquote>
<h1 id="反操作泛型">4 反操作泛型</h1>
<blockquote>
<blockquote>
<p>Method和Field、Constructor对象都有setAccessible）方法。</p>
<p>setAccessible作用是启动和禁用访问安全检查的开关。</p>
<p>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</p>
<p>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</p>
<p>使得原本无法访问的私有成员也可以访问</p>
<p>参数值为false则指示反射的对象应该实施Java语言访问检查</p>
<pre><code class="lang-java">   public class Test { 
       public void testel(Map&lt;String,User&gt; map,List&lt;User&gt; list){ 
           System.out.println(""testo1"); 
       }
       public Map&lt;string,User&gt;testo2(){ 
           System.out.println("testo2"); 
           return null; 
       }
       public static void main(String[] args) throws NoSuchMethodException { 
           Method method=Test11.class.getMethod("teste1",Map.class,List.class); 
           Type[] genericParameterTypes=method.getGenericParameterTypes();
           for(Type genericParameterType:genericParameterTypes){
               System.out.println("#"+genericParameterType); 
               if(genericParameterType instanceof ParameterizedType){ 
                   Type[] actualTypeArguments=((ParameterizedType)genericParameterType).getActualTypeArguments(); 
                   for (Type actualTypeArgument:actualTypeArguments){ 
                       System.out.println(actualTypeArgument);
                       method=Test11.class.getMethod(name:"testo2",.…parameterTypes:null); 
                       Type genericReturnType=method.getGenericReturnType(); 
                       if(genericReturnType instanceof ParameterizedType){ 
                           Type[]actualTypeArguments=((ParameterizedType) genericReturnType).getActualTypeArguments(); 
                           for(Type actualTypeArgument:actualTypeArguments){ 
                               System.out.println(actualTypeArgument);                                             }
                       }
                   }
               }
           }
       }
   }
</code></pre>
</blockquote>
<p> <a data-lightbox="7bfd56c5-4b68-4bb6-a260-335931d0f12f" data-title="image-20200309223405261" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309223405261.png"><img alt="image-20200309223405261" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/image-20200309223405261.png"/></a></p>
</blockquote>
<h1 id="class对象功能">5 Class对象功能</h1>
<h2 id="获取功能">5.1 获取功能</h2>
<blockquote>
<p>1）获取成员变量们</p>
<pre><code class="lang-java">Field[] getFields() ：获取所有<span class="hljs-keyword">public</span>修饰的成员变量
<span class="hljs-function">Field <span class="hljs-title">getField</span><span class="hljs-params">(String name)</span>   获取指定名称的 <span class="hljs-keyword">public</span>修饰的成员变量

Field[] <span class="hljs-title">getDeclaredFields</span><span class="hljs-params">()</span>  获取所有的成员变量，不考虑修饰符
Field <span class="hljs-title">getDeclaredField</span><span class="hljs-params">(String name)</span>
</span></code></pre>
<p>2）获取构造方法们</p>
<pre><code class="lang-java">Constructor&lt;?&gt;[] getConstructors()  
<span class="hljs-function">Constructor&lt;T&gt; <span class="hljs-title">getConstructor</span><span class="hljs-params">(类&lt;?&gt;... parameterTypes)</span>  

Constructor&lt;?&gt;[] <span class="hljs-title">getDeclaredConstructors</span><span class="hljs-params">()</span>  
Constructor&lt;T&gt; <span class="hljs-title">getDeclaredConstructor</span><span class="hljs-params">(类&lt;?&gt;... parameterTypes)</span>
</span></code></pre>
<p>3）获取成员方法们</p>
<pre><code class="lang-java">Method[] getMethods()  
<span class="hljs-function">Method <span class="hljs-title">getMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span>  

Method[] <span class="hljs-title">getDeclaredMethods</span><span class="hljs-params">()</span>  
Method <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span>
</span></code></pre>
<p>4）获取全类名和简单类名</p>
<pre><code class="lang-java"><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span>
</span></code></pre>
</blockquote>
<h2 id="field：成员变量">5.2 Field：成员变量</h2>
<blockquote>
<p><strong>设置值</strong>: void set(Object obj, Object value)</p>
<p><strong>获取值</strong>: get(Object obj)</p>
<p>忽略访问权限修饰符的安全检查 setAccessible(true): <code>暴力反射</code></p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> lombok.Getter;
<span class="hljs-keyword">import</span> lombok.Setter;
<span class="hljs-keyword">import</span> lombok.ToString;

<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
   <span class="hljs-keyword">public</span> String a;        <span class="hljs-comment">//最大范围public</span>
       <span class="hljs-keyword">protected</span> String b;     <span class="hljs-comment">//受保护类型</span>
       String c;               <span class="hljs-comment">//默认的访问权限</span>
       <span class="hljs-keyword">private</span> String d;       <span class="hljs-comment">//私有类型</span>
   }
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 测试getFields和getField(String name)方法</span>
**
* 获取成员变量
*   Field[] getFields()
*   <span class="hljs-function">Field <span class="hljs-title">getField</span><span class="hljs-params">(String name)</span>
*/
@Test
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
  <span class="hljs-comment">// 0. 获取Person的Class对象</span>
  Class personClass = Person.class;

   <span class="hljs-comment">// 1. Field[] getFields()获取所有public修饰的成员变量</span>
  Field[] fields = personClass.getFields();
   <span class="hljs-keyword">for</span>(Field field : fields){
       System.out.println(field);
   }
   System.out.println(<span class="hljs-string">"============================="</span>);
   <span class="hljs-comment">// 2. Field getField(String name)</span>
   Field a = personClass.getField(<span class="hljs-string">"a"</span>);

   <span class="hljs-comment">// 3. 获取成员变量a 的值 [也只能获取公有的，获取私有的或者不存在的字符会抛出异常]</span>
  Person p = <span class="hljs-keyword">new</span> Person();
   Object value = a.get(p);
   System.out.println(<span class="hljs-string">"value = "</span> + value);

   <span class="hljs-comment">// 4 设置属性a的值</span>
  a.set(p,<span class="hljs-string">"张三"</span>);
   System.out.println(p);
}
</code></pre>
<p><a data-lightbox="73a8aad6-d09f-4a0e-85dd-2ef09c61cc2c" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard.png"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard.png"/></a></p>
<pre><code class="lang-java"><span class="hljs-comment">// 测试getDeclaredFields和getDeclaredField(String name)方法</span>
<span class="hljs-comment">/**
*  Field[] getDeclaredFields()
*  Field getDeclaredField(String name)
*/</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflect3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
  Class personClass = Person.class;
   <span class="hljs-comment">// Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符</span>
  Field[] declaredFields = personClass.getDeclaredFields();
   <span class="hljs-keyword">for</span>(Field filed : declaredFields){
       System.out.println(filed);
   }
   System.out.println(<span class="hljs-string">"==================================="</span>);
   <span class="hljs-comment">// Field getDeclaredField(String name)</span>
   Field d = personClass.getDeclaredField(<span class="hljs-string">"d"</span>);     <span class="hljs-comment">//private String d;</span>
   Person p = <span class="hljs-keyword">new</span> Person();

   <span class="hljs-comment">// Object value1 = d.get(p);    //会抛出异常</span>
  <span class="hljs-comment">// System.out.println("value1 = " + value1);    </span>
   <span class="hljs-comment">//对于私有变量虽然能会获取到，但不能直接set和get</span>

  <span class="hljs-comment">//忽略访问权限修饰符的安全检查</span>
   d.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//暴力反射</span>
   Object value2 = d.get(p);
   System.out.println(<span class="hljs-string">"value2 = "</span> + value2);
}
</code></pre>
<p><a data-lightbox="1998e4f4-4c86-4aa6-8ec0-79ad3cda903e" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757303499.png"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757303499.png"/></a></p>
<p>没有忽略访问修饰符直接访问抛出的异常</p>
<p><a data-lightbox="8a73eb02-d12f-40b6-9911-12d66d03d3cf" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757311152.png"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757311152.png"/></a></p>
</blockquote>
<h2 id="constructor构造方法">5.3 Constructor:构造方法</h2>
<blockquote>
<p><strong>创建对象</strong>：T newInstance(Object... initargs)</p>
<p>注意：如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> lombok.Getter;
<span class="hljs-keyword">import</span> lombok.Setter;
<span class="hljs-keyword">import</span> lombok.ToString;

<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
       <span class="hljs-keyword">private</span> String name;
       <span class="hljs-keyword">private</span> Integer age;
   <span class="hljs-comment">//无参构造函数</span>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>{}
       <span class="hljs-comment">//单个参数的构造函数，且为私有构造方法</span>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span></span>{}
       <span class="hljs-comment">//有参构造函数</span>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, Integer age)</span> </span>{
          <span class="hljs-keyword">this</span>.name = name;
          <span class="hljs-keyword">this</span>.age = age; }
}
</code></pre>
<pre><code>````java
/**
</code></pre><ul>
<li><p>获取构造方法们</p>
<ul>
<li>Constructor&lt;?&gt;[] getConstructors()</li>
<li>Constructor<t> getConstructor(类&lt;?&gt;... parameterTypes)
*/
@Test
public void reflect4() throws Exception {
Class personClass = Person.class;</t></li>
</ul>
<p>//Constructor&lt;?&gt;[] getConstructors()
Constructor[] constructors = personClass.getConstructors();
for(Constructor constructor : constructors){<br/> // Constructor 对象reflect包下的 import java.lang.reflect.Constructor;
  System.out.println(constructor);
}
System.out.println("==========================================");</p>
<p>// 获取无参构造函数 注意：Person类中必须要有无参的构造函数，不然抛出异常
Constructor constructor1 = personClass.getConstructor();
System.out.println("constructor1 = " + constructor1);
// 获取到构造函数后可以用于创建对象
Object person1 = constructor1.newInstance();
// Constructor类内提供了初始化方法newInstance();方法
System.out.println("person1 = " + person1);
System.out.println("==========================================");</p>
<p>// 获取有参的构造函数<br/>// public Person(String name, Integer age) 
// 参数类型顺序要与构造函数内一致，且参数类型为字节码类型
Constructor constructor2 = personClass.getConstructor(String.class,Integer.class);
System.out.println("constructor2 = " + constructor2);</p>
<p>// 创建对象
Object person2 = constructor2.newInstance("张三", 23);<br/>// 获取的是有参的构造方法，就必须要给参数
System.out.println(person2);
System.out.println("=========================================");</p>
<p>// 对于一般的无参构造函数，我们都不会先获取无参构造器之后在进行初始化。
// 而是直接调用Class类内的newInstance()方法
Object person3 = personClass.newInstance();
System.out.println("person3 = " + person3);
// 我们之前使用的 Class.forName("").newInstance
// 其本质上就是调用了类内的无参构造函数来完成实例化的
// 以后在使用  Class.forName("").newInstance; 反射创建对象时，一定要保证类内有无参构造函数
}
````</p>
</li>
</ul>
<p><a data-lightbox="6710fd2f-2da2-4b48-a9b0-55c8d09d5652" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757474373.png"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757474373.png"/></a></p>
<p><strong>对于getDeclaredConstructor方法和getDeclaredConstructors方法</strong></p>
<p>getDeclaredConstructor方法可以获取到任何访问权限的构造器，而getConstructor方法只能获取public修饰的构造器。此外在构造器的对象内也有setAccessible(true);方法，并设置成true就可以操作了。</p>
<p>​    关于为什么要使用private访问权限的构造器，使用这个构造器不就不能外部访问了嘛，不也就无法进行实例化对象了吗？无法在类的外部实例化对象正是私有构造器的意义所在，在单例模式下经常使用，整个项目只有一个对象，外部无法实例化对象，可以在类内的进行实例化并通过静态方法返回（由于实例化的对象是静态的，故只有一个对象，也就是单例的）。</p>
<p>网上说这就是单例模式中的饿汉模式，不管是否调用，都创建一个对象。</p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo</span></span>{
   <span class="hljs-comment">// 私有化构造方法</span>
   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo</span><span class="hljs-params">()</span></span>{
   }
   <span class="hljs-comment">// 创建一个对象  类内实例化（静态的对象）</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo singleton = <span class="hljs-keyword">new</span> SingletonDemo();
   <span class="hljs-comment">// 提供public方法供外部访问，返回这个创建的对象</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>{
       <span class="hljs-keyword">return</span> singleton;
   }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
       SingletonDemo s1 = SingletonDemo.getInstance();
       <span class="hljs-comment">//输出对象的地址，如果有地址存在，则说明对象创建成功并获取到</span>
       System.out.println(s1);
          SingletonDemo s2 = SingletonDemo.getInstance();
       <span class="hljs-comment">//如果结果为true，则说明是同一个对象</span>
       System.out.println(s1==s2);    <span class="hljs-comment">//输出结果为true</span>
   }
}
</code></pre>
</blockquote>
<h1 id="method：方法对象">6 Method：方法对象</h1>
<blockquote>
<p><strong>执行方法</strong>：Object invoke(Object obj, Object... args)</p>
<p><strong>获取方法名称</strong>：String getName();</p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> lombok.Getter;
<span class="hljs-keyword">import</span> lombok.Setter;
<span class="hljs-keyword">import</span> lombok.ToString;

<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
   <span class="hljs-keyword">private</span> String name;
       <span class="hljs-keyword">private</span> Integer age;
       <span class="hljs-comment">//无参构造函数</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>{}
       <span class="hljs-comment">//有参构造函数</span>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, Integer age)</span> </span>{
      <span class="hljs-keyword">this</span>.name = name;
          <span class="hljs-keyword">this</span>.age = age;}
   <span class="hljs-comment">//无参方法</span>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>{
          System.out.println(<span class="hljs-string">"eat..."</span>);
        }
        <span class="hljs-comment">//重载有参方法</span>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String food)</span></span>{
      System.out.println(<span class="hljs-string">"eat..."</span>+food);
       }
   }
</code></pre>
<p><strong>invoke方法</strong></p>
<pre><code class="lang-java">    <span class="hljs-comment">/**
   * 获取成员方法们：
*  Method[] getMethods()
*  Method getMethod(String name, 类&lt;?&gt;... parameterTypes)
*/</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflect5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
  Class personClass = Person.class;

   <span class="hljs-comment">// 获取指定名称的方法    </span>
   Method eat_method1 = personClass.getMethod(<span class="hljs-string">"eat"</span>);
   <span class="hljs-comment">// 执行方法</span>
   Person person = <span class="hljs-keyword">new</span> Person();
  Object rtValue = eat_method1.invoke(person);
   <span class="hljs-comment">//如果方法有返回值类型可以获取到，没有就为null</span>
   <span class="hljs-comment">// 输出返回值 eat方法没有返回值，故输出null</span>
  System.out.println(<span class="hljs-string">"rtValue = "</span> + rtValue);
   System.out.println(<span class="hljs-string">"--------------------------------------------"</span>);

   <span class="hljs-comment">// 获取有参的构造函数  有两个参数 第一个方法名 第二个参数列表 ，不同的参数是不同的方法（重载）</span>
   Method eat_method2 = personClass.getMethod(<span class="hljs-string">"eat"</span>, String.class);
   <span class="hljs-comment">//执行方法</span>
   eat_method2.invoke(person,<span class="hljs-string">"饭"</span>);
   System.out.println(<span class="hljs-string">"============================================"</span>);

   <span class="hljs-comment">//获取方法列表</span>
  Method[] methods = personClass.getMethods();
   <span class="hljs-keyword">for</span>(Method method : methods){     
       <span class="hljs-comment">//注意：获取到的方法名称不仅仅是我们在Person类内看到的方法</span>
       System.out.println(method);   
       <span class="hljs-comment">//继承下来的方法也会被获取到（当然前提是public修饰的）</span>
  }
}
</code></pre>
<p><a data-lightbox="6b2143cf-08dc-49d3-a3a5-6bdbb0289e90" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757833119.png"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757833119.png"/></a></p>
</blockquote>
<h2 id="getname方法">6.1 getName方法</h2>
<blockquote>
<p>getName()方法获取的方法名是仅仅就是方法名（不带全类名），且不带有参数列表。</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflect6</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>{
       Class personClass = Person.class;
       Method[] methods = personClass.getMethods();
       <span class="hljs-keyword">for</span>(Method method : methods){
           System.out.println(method);
           <span class="hljs-comment">// 获取方法名</span>
           String name = method.getName();  
           System.out.println(name);   
       }
}
</code></pre>
<p><a data-lightbox="fdf4e6ec-8c4c-46b7-a959-766bfffe03e3" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757870418.png"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/clipboard-1583757870418.png"/></a></p>
<p><strong>获取类名</strong></p>
<p>getClass()方法是Object类的方法，需要注意一点获取的类名是<strong>全类名</strong>（带有路径）</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reflect7</span><span class="hljs-params">()</span></span>{
     Class personClass = Person.class;
     String className = personClass.getName();
     System.out.println(className);
}
</code></pre>
<p><a data-lightbox="45a23903-efac-4d3c-9954-9bd8b3acd03f" data-title="img" href="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/clipboard-1583757948090.png"><img alt="img" src="res/Java%E8%BF%9B%E9%98%B6_%E5%8F%8D%E5%B0%84/clipboard-1583757948090.png"/></a></p>
</blockquote>
<h2 id="关于获取成员方法们的另外两个方法">6.2 关于获取成员方法们的另外两个方法</h2>
<blockquote>
<p>同之前的叙述一样，带有Declared关键字的方法这两个方法，可以获取到任意修饰符的方法。同样的提供了setAccessible(true);方法进行暴力反射。</p>
<p>   Method和Field、Constructor对象都有setAccessible）方法。</p>
<p>setAccessible作用是启动和禁用访问安全检查的开关。</p>
<p>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</p>
<p>   提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</p>
<p>使得原本无法访问的私有成员也可以访问&gt;参数值为false则指示反射的对象应该实施Java语言访问检查</p>
<p><strong>综上说述：对于反射机制来说，在反射面前没有公有私有，都可以通过暴力反射解决。</strong></p>
<pre><code class="lang-java">Method[] getDeclaredMethods()  
<span class="hljs-function">Method <span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span>
method.<span class="hljs-title">setAccessible</span><span class="hljs-params">(<span class="hljs-keyword">true</span>)</span></span>;   <span class="hljs-comment">//暴力反射</span>
</code></pre>
</blockquote>
<p></p><footer class="page-footer"><span class="copyright">Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-02-18 01:01:52
</span></footer><hr/><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el: "#vcomments",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false})</script><p></p>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: Java进阶" class="navigation navigation-prev" href="Java进阶.md">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: Java进阶_注解" class="navigation navigation-next" href="Java进阶_注解.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Java进阶_反射","level":"1.7.1","depth":2,"next":{"title":"Java进阶_注解","level":"1.7.2","depth":2,"path":"chapters/Java进阶_注解.md","ref":"chapters/Java进阶_注解.md","articles":[]},"previous":{"title":"Java进阶","level":"1.7","depth":1,"path":"chapters/Java进阶.md","ref":"chapters/Java进阶.md","articles":[{"title":"Java进阶_反射","level":"1.7.1","depth":2,"path":"chapters/Java进阶_反射.md","ref":"chapters/Java进阶_反射.md","articles":[]},{"title":"Java进阶_注解","level":"1.7.2","depth":2,"path":"chapters/Java进阶_注解.md","ref":"chapters/Java进阶_注解.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["-sharing","splitter","expandable-chapters-small","anchors","github","github-buttons","donate","sharing-plus","anchor-navigation-ex","mathjax","mermaid-gb3","tbfed-pagefooter","code","favicon","search-plus","-lunr","-search","lightbox","change_girls","theme-comscore","valine","pageview-count","favicon-absolute"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright © narutohyc.com 2022","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/narutohyc"},"splitter":{},"change_girls":{"time":10,"urls":["https://plc.jj20.com/up/allimg/1115/012122143136/220121143136-2.jpg","https://plc.jj20.com/up/allimg/1115/111R1094405/21111P94405-1.jpg"]},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"donate":{"alipay":"https://i.loli.net/2021/01/12/Cdunm9AoBcHF5MI.png","alipayText":"支付宝打赏","button":"赏","title":"","wechat":"https://i.loli.net/2021/01/12/gmzASfCciIFXTyr.png","wechatText":"微信打赏"},"favicon-absolute":{"appleTouchIconMore":{},"appleTouchIconPrecomposed152":"./chapters/res/other/favicon.ico","appleTouchIconPrecomposedMore":{},"favicon":"./chapters/res/other/favicon.ico"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"favicon":{},"lightbox":{"jquery":true,"sameUuid":false},"theme-comscore":{},"pageview-count":{},"github-buttons":{"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]},"mathjax":{"forceSVG":false,"version":"2.6-latest"},"expandable-chapters-small":{},"sharing":{"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"],"douban":true,"facebook":true,"weibo":true,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":false,"google":true,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{},"valine":{"avatar":"","lang":"zh-CN","pageSize":10,"placeholder":"Just go go","recordIP":false,"appId":"jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz","appKey":"FOXMptWOHC7cU1FxXt0LJj4o"},"search-plus":{}},"theme":"default","author":"narutohyc","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Java相关学习记录","language":"zh-hans","links":{"sidebar":{"我的狗窝":"https://github.com/narutohyc"}},"gitbook":"*","description":"记录 Java 的学习和一些技巧的使用"},"file":{"path":"chapters/Java进阶_反射.md","mtime":"2022-02-18T01:01:52.733Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-02-18T01:03:20.321Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>
<script src="../gitbook/gitbook.js"></script>
<script src="../gitbook/theme.js"></script>
<script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
<script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
<script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
<script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="../gitbook/gitbook-plugin-lightbox/js/lightbox.min.js"></script>
<script src="../gitbook/gitbook-plugin-change_girls/girls.js"></script>
<script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>
</body>
</html>
