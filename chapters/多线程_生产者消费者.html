<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>多线程_生产者消费者 · Java相关学习记录</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="" name="description"/>
<meta content="GitBook 3.2.3" name="generator"/>
<meta content="narutohyc" name="author"/>
<link href="../gitbook/style.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-splitter/splitter.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchors/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-donate/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-code/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-search-plus/search.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-lightbox/css/lightbox.min.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-change_girls/girls.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-pageview-count/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-highlight/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-fontsettings/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-theme-comscore/test.css" rel="stylesheet"/>
<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<link href="../gitbook/images/apple-touch-icon-precomposed-152.png" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../gitbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="IDEA快捷键.html" rel="next"/>
<link href="多线程_JUC线程池.html" rel="prev"/>
<link href="./chapters/res/other/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="./chapters/res/other/favicon.ico" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
<script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]};
    </script>
</head>
<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="输入并搜索" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="https://github.com/narutohyc" target="_blank">我的狗窝</a>
</li>
<li class="divider"></li>
<li class="chapter" data-level="1.1" data-path="../">
<a href="../">
<b>1.1.</b>
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="设计模式.html">
<a href="设计模式.html">
<b>1.2.</b>
                    
                    设计模式
            
                </a>
</li>
<li class="chapter" data-level="1.3" data-path="多线程.html">
<a href="多线程.html">
<b>1.3.</b>
                    
                    多线程
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="多线程_基础篇.html">
<a href="多线程_基础篇.html">
<b>1.3.1.</b>
                    
                    多线程_基础篇
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="多线程_锁.html">
<a href="多线程_锁.html">
<b>1.3.2.</b>
                    
                    多线程_锁
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="多线程_JUC原子类.html">
<a href="多线程_JUC原子类.html">
<b>1.3.3.</b>
                    
                    多线程_JUC原子类
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="多线程_JUC锁集合.html">
<a href="多线程_JUC锁集合.html">
<b>1.3.4.</b>
                    
                    多线程_JUC锁集合
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="多线程_JUC集合.md">
<span>
<b>1.3.5.</b>
                    
                    多线程_JUC集合
            
                
            

            
        </span></li>
<li class="chapter" data-level="1.3.6" data-path="多线程_JUC线程池.html">
<a href="多线程_JUC线程池.html">
<b>1.3.6.</b>
                    
                    多线程_JUC线程池
            
                </a>
</li>
<li class="chapter active" data-level="1.3.7" data-path="多线程_生产者消费者.html">
<a href="多线程_生产者消费者.html">
<b>1.3.7.</b>
                    
                    多线程_生产者消费者
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="IDEA快捷键.html">
<a href="IDEA快捷键.html">
<b>1.4.</b>
                    
                    IDEA快捷键
            
                </a>
</li>
<li class="chapter" data-level="1.5" data-path="Spring注解.html">
<a href="Spring注解.html">
<b>1.5.</b>
                    
                    Spring注解
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="Spring注解_介绍.html">
<a href="Spring注解_介绍.html">
<b>1.5.1.</b>
                    
                    Spring注解_介绍
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="Spring注解_常用注解.html">
<a href="Spring注解_常用注解.html">
<b>1.5.2.</b>
                    
                    Spring注解_常用注解
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="Spring注解_Spring入门篇.html">
<a href="Spring注解_Spring入门篇.html">
<b>1.5.3.</b>
                    
                    Spring注解_Spring入门篇
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="Java基础.html">
<a href="Java基础.html">
<b>1.6.</b>
                    
                    Java基础
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="Java基础_集合.html">
<a href="Java基础_集合.html">
<b>1.6.1.</b>
                    
                    Java基础_集合
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="Java基础_泛型.html">
<a href="Java基础_泛型.html">
<b>1.6.2.</b>
                    
                    Java基础_泛型
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="Java基础_打jar包.html">
<a href="Java基础_打jar包.html">
<b>1.6.3.</b>
                    
                    Java基础_打jar包
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="Java基础_正则匹配.html">
<a href="Java基础_正则匹配.html">
<b>1.6.4.</b>
                    
                    Java基础_正则匹配
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="Java基础_反射机制.html">
<a href="Java基础_反射机制.html">
<b>1.6.5.</b>
                    
                    Java基础_反射机制
            
                </a>
</li>
<li class="chapter" data-level="1.6.6" data-path="Java基础_对象正反序列化.html">
<a href="Java基础_对象正反序列化.html">
<b>1.6.6.</b>
                    
                    Java基础_对象正反序列化
            
                </a>
</li>
<li class="chapter" data-level="1.6.7" data-path="Java基础_读取配置文件.html">
<a href="Java基础_读取配置文件.html">
<b>1.6.7.</b>
                    
                    Java基础_读取配置文件
            
                </a>
</li>
<li class="chapter" data-level="1.6.8" data-path="Java基础_解析与生成XML.html">
<a href="Java基础_解析与生成XML.html">
<b>1.6.8.</b>
                    
                    Java基础_解析与生成XML
            
                </a>
</li>
<li class="chapter" data-level="1.6.9" data-path="Java基础_后台服务器开发.html">
<a href="Java基础_后台服务器开发.html">
<b>1.6.9.</b>
                    
                    Java基础_后台服务器开发
            
                </a>
</li>
<li class="chapter" data-level="1.6.10" data-path="Java基础_四舍五入.html">
<a href="Java基础_四舍五入.html">
<b>1.6.10.</b>
                    
                    Java基础_四舍五入
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="Java进阶.html">
<a href="Java进阶.html">
<b>1.7.</b>
                    
                    Java进阶
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="Java进阶_反射.html">
<a href="Java进阶_反射.html">
<b>1.7.1.</b>
                    
                    Java进阶_反射
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="Java进阶_注解.html">
<a href="Java进阶_注解.html">
<b>1.7.2.</b>
                    
                    Java进阶_注解
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.8" data-path="MySQL.html">
<a href="MySQL.html">
<b>1.8.</b>
                    
                    MySQL
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.8.1" data-path="MySQL_基础.html">
<a href="MySQL_基础.html">
<b>1.8.1.</b>
                    
                    MySQL_基础
            
                </a>
</li>
<li class="chapter" data-level="1.8.2" data-path="MySQL_约束.html">
<a href="MySQL_约束.html">
<b>1.8.2.</b>
                    
                    MySQL_约束
            
                </a>
</li>
<li class="chapter" data-level="1.8.3" data-path="MySQL_多表查询.html">
<a href="MySQL_多表查询.html">
<b>1.8.3.</b>
                    
                    MySQL_多表查询
            
                </a>
</li>
<li class="chapter" data-level="1.8.4" data-path="MySQL_事务.html">
<a href="MySQL_事务.html">
<b>1.8.4.</b>
                    
                    MySQL_事务
            
                </a>
</li>
<li class="chapter" data-level="1.8.5" data-path="MySQL_数据库设计.html">
<a href="MySQL_数据库设计.html">
<b>1.8.5.</b>
                    
                    MySQL_数据库设计
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.9" data-path="JDBC.html">
<a href="JDBC.html">
<b>1.9.</b>
                    
                    JDBC
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.9.1" data-path="JDBC_JDBC基础.html">
<a href="JDBC_JDBC基础.html">
<b>1.9.1.</b>
                    
                    JDBC_JDBC基础
            
                </a>
</li>
<li class="chapter" data-level="1.9.2" data-path="JDBC_JDBC连接池.html">
<a href="JDBC_JDBC连接池.html">
<b>1.9.2.</b>
                    
                    JDBC_JDBC连接池
            
                </a>
</li>
<li class="chapter" data-level="1.9.3" data-path="JDBC_JDBCTemplate.html">
<a href="JDBC_JDBCTemplate.html">
<b>1.9.3.</b>
                    
                    JDBC_JDBCTemplate
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.10" data-path="Spark集群搭建.html">
<a href="Spark集群搭建.html">
<b>1.10.</b>
                    
                    Spark集群搭建
            
                </a>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            本书使用 GitBook 发布
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="..">多线程_生产者消费者</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div class="search-plus" id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon"></span><a href="#生产者消费者">1 生产者消费者</a></li><li><span class="title-icon"></span><a href="#synchronized版本">2 synchronized版本</a></li><li><span class="title-icon"></span><a href="#lockcondition的同步">3 lock+condition的同步</a></li><li><span class="title-icon"></span><a href="#blockingqueue版实现">4 BlockingQueue版实现</a></li><li><span class="title-icon"></span><a href="#disruptor方式">5 Disruptor方式</a></li><ul><li><span class="title-icon"></span><a href="#提高消费者的响应时间：选择合适的策略">5.1 提高消费者的响应时间：选择合适的策略</a></li><li><span class="title-icon"></span><a href="#cpu-cache的优化：解决伪共享问题">5.2 CPU Cache的优化：解决伪共享问题</a></li></ul><li><span class="title-icon"></span><a href="#并行流水线">6 并行流水线</a></li></ul></div><a href="#生产者消费者" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><p><a data-lightbox="7150bb29-0349-4633-b0aa-e38f94a2bb6a" data-title="img" href="../res/other/异世界蕾姆_1.png"><img alt="img" src="../res/other/异世界蕾姆_1.png"/></a></p>
<p><li><span class="title-icon"></span><a href="#生产者消费者">1 生产者消费者</a></li><li><span class="title-icon"></span><a href="#synchronized版本">2 synchronized版本</a></li><li><span class="title-icon"></span><a href="#lockcondition的同步">3 lock+condition的同步</a></li><li><span class="title-icon"></span><a href="#blockingqueue版实现">4 BlockingQueue版实现</a></li><li><span class="title-icon"></span><a href="#disruptor方式">5 Disruptor方式</a></li><ul><li><span class="title-icon"></span><a href="#提高消费者的响应时间：选择合适的策略">5.1 提高消费者的响应时间：选择合适的策略</a></li><li><span class="title-icon"></span><a href="#cpu-cache的优化：解决伪共享问题">5.2 CPU Cache的优化：解决伪共享问题</a></li></ul><li><span class="title-icon"></span><a href="#并行流水线">6 并行流水线</a></li></p>
<h1 id="生产者消费者">1 生产者消费者</h1>
<pre><code class="lang-java"><span class="hljs-number">1</span>. Java生产者消费者的三种实现
    https:<span class="hljs-comment">//blog.csdn.net/xindoo/article/details/80004003</span>
</code></pre>
<pre><code class="lang-java">Java生产者消费者是最基础的线程同步问题，java岗面试中还是很容易遇到的，之前没写过多线程的代码，面试中被问到很尬啊，面完回来恶补下。在网上查到大概有<span class="hljs-number">5</span>种生产者消费者的写法，分别如下。

用<span class="hljs-keyword">synchronized</span>对存储加锁，然后用object原生的wait() 和 notify()做同步。
用concurrent.locks.Lock，然后用condition的await() 和signal()做同步。
直接使用concurrent.BlockingQueue。
使用PipedInputStream/PipedOutputStream。
使用信号量semaphore。
</code></pre>
<h1 id="synchronized版本">2 synchronized版本</h1>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.LinkedList;
<span class="hljs-keyword">import</span> java.util.Queue;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerAndConsumer</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEN = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            producer();
        }
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {
                <span class="hljs-keyword">synchronized</span> (queue) {
                    <span class="hljs-keyword">while</span> (queue.size() == MAX_LEN) {
                        queue.notify();
                        System.out.println(<span class="hljs-string">"当前队列满"</span>);
                        <span class="hljs-keyword">try</span> {
                            queue.wait();
                        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    queue.add(<span class="hljs-number">1</span>);
                    queue.notify();
                    System.out.println(<span class="hljs-string">"生产者生产一条任务，当前队列长度为"</span> + queue.size());
                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">500</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            consumer();
        }
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                <span class="hljs-keyword">synchronized</span> (queue) {
                    <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>) {
                        queue.notify();
                        System.out.println(<span class="hljs-string">"当前队列为空"</span>);
                        <span class="hljs-keyword">try</span> {
                            queue.wait();
                        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    queue.poll();
                    queue.notify();
                    System.out.println(<span class="hljs-string">"消费者消费一条任务，当前队列长度为"</span> + queue.size());
                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">500</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ProducerAndConsumer pc = <span class="hljs-keyword">new</span> ProducerAndConsumer();
        Producer producer = pc.new Producer();
        Consumer consumer = pc.new Consumer();
        producer.start();
        consumer.start();
    }
}
</code></pre>
<h1 id="lockcondition的同步">3 lock+condition的同步</h1>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.LinkedList;
<span class="hljs-keyword">import</span> java.util.Queue;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;
<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-comment">/**
 * version 1 doesn't use synchronized to improve performance
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerAndConsumer1</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEN = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition condition = lock.newCondition();
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            producer();
        }
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {
                lock.lock();
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">while</span> (queue.size() == MAX_LEN) {
                        System.out.println(<span class="hljs-string">"当前队列满"</span>);
                        <span class="hljs-keyword">try</span> {
                            condition.await();
                        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    queue.add(<span class="hljs-number">1</span>);
                    condition.signal();
                    System.out.println(<span class="hljs-string">"生产者生产一条任务，当前队列长度为"</span> + queue.size());
                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">500</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                } <span class="hljs-keyword">finally</span> {
                    lock.unlock();
                }
            }
        }
    }
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            consumer();
        }
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                lock.lock();
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">while</span> (queue.size() == <span class="hljs-number">0</span>) {
                        System.out.println(<span class="hljs-string">"当前队列为空"</span>);
                        <span class="hljs-keyword">try</span> {
                            condition.await();
                        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    queue.poll();
                    condition.signal();
                    System.out.println(<span class="hljs-string">"消费者消费一条任务，当前队列长度为"</span> + queue.size());
                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">500</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }
                } <span class="hljs-keyword">finally</span> {
                    lock.unlock();
                }
            }
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ProducerAndConsumer pc = <span class="hljs-keyword">new</span> ProducerAndConsumer();
        Producer producer = pc.new Producer();
        Consumer consumer = pc.new Consumer();
        producer.start();
        consumer.start();
    }
}
</code></pre>
<h1 id="blockingqueue版实现">4 BlockingQueue版实现</h1>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.Random;
<span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;
<span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerAndConsumer</span> </span>{
    <span class="hljs-keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;(<span class="hljs-number">10</span>);
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            producer();
        }
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) {
                <span class="hljs-keyword">try</span> {
                    queue.put(<span class="hljs-number">1</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(<span class="hljs-string">"生产者生产一条任务，当前队列长度为"</span> + queue.size());
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>)+<span class="hljs-number">500</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
            consumer();
        }
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                <span class="hljs-keyword">try</span> {
                    queue.take();
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(<span class="hljs-string">"消费者消费一条任务，当前队列长度为"</span> + queue.size());
                <span class="hljs-keyword">try</span> {
                    Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>)+<span class="hljs-number">500</span>);
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ProducerAndConsumer pc = <span class="hljs-keyword">new</span> ProducerAndConsumer();
        Producer producer = pc.new Producer();
        Consumer consumer = pc.new Consumer();
        producer.start();
        consumer.start();
    }
}
</code></pre>
<h1 id="disruptor方式">5 Disruptor方式</h1>
<pre><code class="lang-java"><span class="hljs-comment">// 摘自《Java高并发程序设计》</span>
<span class="hljs-comment">// https://blog.csdn.net/sunhaoning/article/details/64131362</span>

<span class="hljs-comment">// BlockigQueue用于实现生产者和消费者一个不错的选择。它可以很自然地实现作为生产者和消费者的内存缓冲区。但是BlockigQueue并不是一个高性能的实现，它完全使用锁和阻塞等待来实现线程间的同步。在高并发场合，它的性能并不是特别的优越。就像之前我已经提过的：ConcurrentLinkedQueue是一个高性能的队列，但是BlockingQueue只是为了方便数据共享。</span>

<span class="hljs-comment">// 而ConcurrentLinkedQueue的秘诀就在于大量使用了无锁的CAS操作。同理，如果我们使用CAS来实现生产者-消费者模式，也同样可以获得可观的性能提升。不过正如大家所见，使用CAS进行编程是非常困难的，但有一个好消息是，目前有一个现成的Disruptor框架，它已经帮助我们实现了这一个功能。</span>

<span class="hljs-comment">// Disruptor框架是由LMAX公司开发的一款高效的无锁内存队列。它使用无锁的方式实现了一个环形队列，非常适合于实现生产者和消费者模式，比如事件和消息的发布。在Disruptor中，别出心裁地使用了环形队列（RingBuffer）来代替普通线性队列，这个环形队列内部实现为一个普通的数组。对于一般的队列，势必要提供队列同步head和尾部tail两个指针，用于出队和入队，这样无疑就增加了线程协作的复杂度。但如果队列是环形的，则只需要对外提供一个当前位置cursor，利用这个指针既可以进入入队也可以进行出队操作。由于环形队列的缘故，队列的总大小必须事先指定，不能动态扩展。为了能够快速从一个序列（sequence）对应到数组的实际位置（每次有元素入队，序列就加1），Disruptor要求我们必须将数组的大小设置为2的整数次方。这样通过sequence &amp;(queueSize-1)就能立即定位到实际的元素位置index。这个要比取余（%）操作快得多。</span>


<span class="hljs-comment">// 首先，我们还是需要一个代表数据的PCData：</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCData</span>
</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> value;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span>
    </span>{
        <span class="hljs-keyword">this</span>.value = value;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> value;
    }
}

<span class="hljs-comment">// 消费者实现为WorkHandler接口，它来自Disruptor框架</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WorkHandler</span>＜<span class="hljs-title">PCData</span>＞ </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(PCData event)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">":Event: --"</span>
                + event.get() * event.get() + <span class="hljs-string">"--"</span>);
    }
}

<span class="hljs-comment">// 还需要一个产生PCData的工厂类。它会在Disruptor系统初始化时，构造所有的缓冲区中的对象实例</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCDataFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EventFactory</span>＜<span class="hljs-title">PCData</span>＞
</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> PCData <span class="hljs-title">newInstance</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PCData();
    }
}

<span class="hljs-comment">// 生产者</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span>
</span>{
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RingBuffer＜PCData＞ ringBuffer;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(RingBuffer＜PCData＞ ringBuffer)</span>
     </span>{
         <span class="hljs-keyword">this</span>.ringBuffer = ringBuffer;
     }
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushData</span><span class="hljs-params">(ByteBuffer bb)</span>
     </span>{
         <span class="hljs-keyword">long</span> sequence = ringBuffer.next();  <span class="hljs-comment">// Grab the next sequence</span>
         <span class="hljs-keyword">try</span>
         {
             PCData event = ringBuffer.get(sequence); <span class="hljs-comment">// Get the entry in the Disruptor</span>
                                                         <span class="hljs-comment">// for the sequence</span>
             event.set(bb.getLong(<span class="hljs-number">0</span>));  <span class="hljs-comment">// Fill with data</span>
         }
         <span class="hljs-keyword">finally</span>
         {
             ringBuffer.publish(sequence);
         }
     }
}

<span class="hljs-comment">// 主函数</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception
 </span>{
     Executor executor = Executors.newCachedThreadPool();
     PCDataFactory factory = <span class="hljs-keyword">new</span> PCDataFactory();
     <span class="hljs-comment">// Specify the size of the ring buffer, must be power of 2.</span>
     <span class="hljs-keyword">int</span> bufferSize = ;
     Disruptor＜PCData＞ disruptor = <span class="hljs-keyword">new</span> Disruptor＜PCData＞(factory,
             bufferSize,
             executor,
             ProducerType.MULTI,
             <span class="hljs-keyword">new</span> BlockingWaitStrategy()
             );
     disruptor.handleEventsWithWorkerPool(
             <span class="hljs-keyword">new</span> Consumer(),
             <span class="hljs-keyword">new</span> Consumer(),
             <span class="hljs-keyword">new</span> Consumer(),
             <span class="hljs-keyword">new</span> Consumer());
     disruptor.start();

     RingBuffer＜PCData＞ ringBuffer = disruptor.getRingBuffer();
     Producer producer = <span class="hljs-keyword">new</span> Producer(ringBuffer);
     ByteBuffer bb = ByteBuffer.allocate(<span class="hljs-number">8</span>);
     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> l = <span class="hljs-number">0</span>; <span class="hljs-keyword">true</span>; l++)
     {
         bb.putLong(<span class="hljs-number">0</span>, l);
         producer.pushData(bb);
         Thread.sleep(<span class="hljs-number">0</span>);
         System.out.println(<span class="hljs-string">"add data "</span>+l);
     }
 }

<span class="hljs-number">8</span>:Event: --<span class="hljs-number">0</span>--
add data <span class="hljs-number">0</span>
<span class="hljs-number">11</span>:Event: --<span class="hljs-number">1</span>--
add data <span class="hljs-number">1</span>
<span class="hljs-number">10</span>:Event: --<span class="hljs-number">4</span>--
add data <span class="hljs-number">2</span>
<span class="hljs-number">9</span>:Event: --<span class="hljs-number">9</span>--
add data <span class="hljs-number">3</span>

根据Disruptor的官方报告，Disruptor的性能要比BlockingQueue至少高一个数量级以上。
</code></pre>
<h2 id="提高消费者的响应时间：选择合适的策略">5.1 提高消费者的响应时间：选择合适的策略</h2>
<p>当有新数据在Disruptor的环形缓冲区中产生时，消费者如何知道这些新产生的数据呢？或者说，消费者如何监控缓冲区中的信息呢？为此，Disruptor提供了几种策略，这些策略由WaitStrategy接口进行封装，主要有以下几种实现。</p>
<ul>
<li>BlockingWaitStrategy：这是默认的策略。使用BlockingWaitStrategy和使用BlockingQueue是非常类似的，它们都使用锁和条件（Condition）进行数据的监控和线程的唤醒。因为涉及到线程的切换，BlockingWaitStrategy策略是最节省CPU，但是在高并发下性能表现最糟糕的一种等待策略。</li>
<li>SleepingWaitStrategy：这个策略也是对CPU使用率非常保守的。它会在循环中不断等待数据。它会先进行自旋等待，如果不成功，则使用Thread.yield()让出CPU，并最终使用LockSupport.parkNanos(1)进行线程休眠，以确保不占用太多的CPU数据。因此，这个策略对于数据处理可能产生比较高的平均延时。它比较适合于对延时要求不是特别高的场合，好处是它对生产者线程的影响最小。典型的应用场景是异步日志。</li>
<li>YieldingWaitStrategy：这个策略用于低延时的场合。消费者线程会不断循环监控缓冲区变化，在循环内部，它会使用Thread.yield()让出CPU给别的线程执行时间。如果你需要一个高性能的系统，并且对延时有较为严格的要求，则可以考虑这种策略。使用这种策略时，相当于你的消费者线程变身成为了一个内部执行了Thread.yield()的死循环。因此，你最好有多于消费者线程数量的逻辑CPU数量（这里的逻辑CPU，我指的是“双核四线程”中的那个四线程，否则，整个应用程序恐怕都会受到影响。</li>
<li>BusySpinWaitStrategy：这个是最疯狂的等待策略了。它就是一个死循环！消费者线程会尽最大努力疯狂监控缓冲区的变化。因此，它会吃掉所有的CPU资源。你只有在对延迟非常苛刻的场合可以考虑使用它（或者说，你的系统真的非常繁忙）。因为在这里你等同开启了一个死循环监控，所以，你的物理CPU数量必须要大于消费者线程数。注意，我这里说的是物理CPU，如果你在一个物理核上使用超线程技术模拟两个逻辑核，另外一个逻辑核显然会受到这种超密集计算的影响而不能正常工作。</li>
</ul>
<h2 id="cpu-cache的优化：解决伪共享问题">5.2 CPU Cache的优化：解决伪共享问题</h2>
<p>​        什么是<strong>伪共享问题</strong>呢？我们知道，为了提高CPU的速度，CPU有一个高速缓存Cache。在高速缓存中，读写数据的最小单位为缓存行（Cache Line），它是从主存（memory）复制到缓存（Cache）的最小单位，一般为32字节到128字节。</p>
<p>​        如果两个变量存放在一个缓存行中时，在多线程访问中，可能会相互影响彼此的性能。如图5.4所示，假设X和Y在同一个缓存行。运行在CPU1上的线程更新了X，那么CPU2上的缓存行就会失效，同一行的Y即使没有修改也会变成无效，导致Cache无法命中。接着，如果在CPU2上的线程更新了Y，则导致CPU1上的缓存行又失效（此时，同一行的X又变得无法访问）。这种情况反反复复发生，无疑是一个潜在的性能杀手。如果CPU经常不能命中缓存，那么系统的吞吐量就会急剧下降。</p>
<h1 id="并行流水线">6 并行流水线</h1>
<pre><code class="lang-java"><span class="hljs-number">1</span>. 借鉴《Java高并发程序设计》第<span class="hljs-number">5.6</span>节
<span class="hljs-number">2</span>.
</code></pre>
<pre><code class="lang-java">计算(B+C)*B/<span class="hljs-number">2</span>，那么这个运行过程就是无法并行的。原因是，如果B+C没有执行完成，则永远算不出(B+C)*B，这就是数据相关性。如果线程执行时，所需的数据存在这种依赖关系，那么，就没有办法将它们完美的并行化。
那遇到这种情况时，有没有什么补救措施呢？答案是肯定的，那就是借鉴日常生产中的流水线思想。

比如，现在要生产一批小玩偶。小玩偶的制作分为四个步骤，第一要组装身体，第二要在身体上安装四肢和头部，第三，给组装完成的玩偶穿上一件漂亮的衣服，第四，就可以包装出货了。为了加快制作玩具的进度，我们不可能叫四个人同时加工一个玩具，因为这四个步骤有着严重的依赖关系。如果没有身体，就没有地方安装四肢，如果没有组装完成，就不能穿衣服，如果没有穿上衣服，就不能包装发货。因此，找四个人来做一个玩偶是毫无意义的。

但是，如果你现在要制作的不是<span class="hljs-number">1</span>只玩偶，而是<span class="hljs-number">1</span>万只玩偶，那情况就不同了。你可以找四个人，第一个人只负责组装身体，完成后交给第二个人；第二个人只负责安装头部和四肢，交付第三人；第三人只负责穿衣服，并交付第四人；第四人只负责包装发货。这样所有人都可以一起工作，共同完成任务，而整个时间周期也能缩短到原来的<span class="hljs-number">1</span>/<span class="hljs-number">4</span>左右，这就是流水线的思想。一旦流水线满载，每次只需要一步（假设一个玩偶需要四步）就可以产生一个玩偶
类似的思想可以借鉴到程序开发中。即使(B+C)*B/<span class="hljs-number">2</span>无法并行，但是如果你需要计算一大堆B和C的值，你依然可以将它流水化。首先将计算过程拆分为三个步骤：

P1:A＝B+C
P2:D＝A×B
P3:D=D/<span class="hljs-number">2</span>

上述步骤中P1、P2和P3均在单独的线程中计算，并且每个线程只负责自己的工作。此时，P3的计算结果就是最终需要的答案。

P1接收B和C的值，并求和，将结果输入给P2。P2求乘积后输入给P3。P3将D除以<span class="hljs-number">2</span>得到最终值。一旦这条流水线建立，只需要一个计算步骤就可以得到(B+C)*B/<span class="hljs-number">2</span>的结果。
</code></pre>
<pre><code class="lang-java"><span class="hljs-comment">// 为了实现这个功能，我们需要定义一个在线程间携带结果进行信息交换的载体：</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Msg</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> i;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> j;
    <span class="hljs-keyword">public</span> String orgStr=<span class="hljs-keyword">null</span>;
}

<span class="hljs-comment">// P1计算的是加法：</span>
 <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plus</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BlockingQueue＜Msg＞ bq=<span class="hljs-keyword">new</span> LinkedBlockingQueue＜Msg＞();
     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>){
             <span class="hljs-keyword">try</span> {
                 Msg msg=bq.take();
                 msg.j=msg.i+msg.j;
                 Multiply.bq.add(msg);
             } <span class="hljs-keyword">catch</span> (InterruptedException e) {
             }
         }
     }
 }
<span class="hljs-comment">// 上述代码中，P1取得封装了两个操作数的Msg，并进行求和，将结果传递给乘法线程P2（第9行）。当没有数据需要处理时，P1进行等待。</span>

<span class="hljs-comment">// P2计算乘法：</span>
 <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Multiply</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BlockingQueue＜Msg＞ bq = <span class="hljs-keyword">new</span> LinkedBlockingQueue＜Msg＞();

     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
             <span class="hljs-keyword">try</span> {
                 Msg msg = bq.take();
                 msg.i = msg.i * msg.j;
                 Div.bq.add(msg);
             } <span class="hljs-keyword">catch</span> (InterruptedException e) {
             }
         }
     }
 }
<span class="hljs-comment">//和P1非常类似，P2计算相乘结果后，将中间结果传递给除法线程P3。</span>

<span class="hljs-comment">//P3计算除法：</span>
 <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Div</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BlockingQueue＜Msg＞ bq = <span class="hljs-keyword">new</span> LinkedBlockingQueue＜Msg＞();
     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
         <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
             <span class="hljs-keyword">try</span> {
                 Msg msg = bq.take();
                 msg.i = msg.i / <span class="hljs-number">2</span>;
                 System.out.println(msg.orgStr + <span class="hljs-string">"="</span> + msg.i);
             } <span class="hljs-keyword">catch</span> (InterruptedException e) {
             }
         }
     }
 }
<span class="hljs-comment">// P3将结果除以2后输出最终的结果。</span>

<span class="hljs-comment">// 最后是提交任务的主线程，这里，我们提交0万个请求，让线程组进行计算：</span>
 <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PStreamMain</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
         <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Plus()).start();
         <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Multiply()).start();
         <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Div()).start();

         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i ＜= ; i++) {
             <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j ＜= ; j++) {
                 Msg msg = <span class="hljs-keyword">new</span> Msg();
                 msg.i = i;
                 msg.j = j;
                 msg.orgStr = <span class="hljs-string">"(("</span> + i + <span class="hljs-string">"+"</span> + j + <span class="hljs-string">")*"</span> + i + <span class="hljs-string">")/2"</span>;
                 Plus.bq.add(msg);
             }
         }
     }
 }
上述代码第行，将数据提交给P1加法线程，开启流水线的计算。在多核或者分布式场景中，这种设计思路可以有效地将有依赖关系的操作分配在不同的线程中进行计算，尽可能利用多核优势。
</code></pre>
<p></p><footer class="page-footer"><span class="copyright">Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2022-02-24 07:08:20
</span></footer><hr/><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el: "#vcomments",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false})</script><p></p>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 多线程_JUC线程池" class="navigation navigation-prev" href="多线程_JUC线程池.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: IDEA快捷键" class="navigation navigation-next" href="IDEA快捷键.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"多线程_生产者消费者","level":"1.3.7","depth":2,"next":{"title":"IDEA快捷键","level":"1.4","depth":1,"path":"chapters/IDEA快捷键.md","ref":"chapters/IDEA快捷键.md","articles":[]},"previous":{"title":"多线程_JUC线程池","level":"1.3.6","depth":2,"path":"chapters/多线程_JUC线程池.md","ref":"chapters/多线程_JUC线程池.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-sharing","splitter","expandable-chapters-small","anchors","github","github-buttons","donate","sharing-plus","anchor-navigation-ex","mathjax","mermaid-gb3","tbfed-pagefooter","code","favicon","search-plus","-lunr","-search","lightbox","change_girls","theme-comscore","valine","pageview-count","favicon-absolute"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright © narutohyc.com 2022","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/narutohyc"},"splitter":{},"change_girls":{"time":10,"urls":["https://plc.jj20.com/up/allimg/1115/012122143136/220121143136-2.jpg","https://plc.jj20.com/up/allimg/1115/111R1094405/21111P94405-1.jpg"]},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"donate":{"alipay":"https://i.loli.net/2021/01/12/Cdunm9AoBcHF5MI.png","alipayText":"支付宝打赏","button":"赏","title":"","wechat":"https://i.loli.net/2021/01/12/gmzASfCciIFXTyr.png","wechatText":"微信打赏"},"favicon-absolute":{"appleTouchIconMore":{},"appleTouchIconPrecomposed152":"./chapters/res/other/favicon.ico","appleTouchIconPrecomposedMore":{},"favicon":"./chapters/res/other/favicon.ico"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"favicon":{},"lightbox":{"jquery":true,"sameUuid":false},"theme-comscore":{},"pageview-count":{},"github-buttons":{"buttons":[{"user":"narutohyc","repo":"bk_jdk","type":"star","size":"small","count":true}]},"mathjax":{"forceSVG":false,"version":"2.6-latest"},"expandable-chapters-small":{},"sharing":{"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"],"douban":true,"facebook":true,"weibo":true,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":false,"google":true,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{},"valine":{"avatar":"","lang":"zh-CN","pageSize":10,"placeholder":"Just go go","recordIP":false,"appId":"jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz","appKey":"FOXMptWOHC7cU1FxXt0LJj4o"},"search-plus":{}},"theme":"default","author":"narutohyc","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Java相关学习记录","language":"zh-hans","links":{"sidebar":{"我的狗窝":"https://github.com/narutohyc"}},"gitbook":"*","description":"记录 Java 的学习和一些技巧的使用"},"file":{"path":"chapters/多线程_生产者消费者.md","mtime":"2022-02-24T07:08:20.959Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-02-24T07:10:05.237Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>
<script src="../gitbook/gitbook.js"></script>
<script src="../gitbook/theme.js"></script>
<script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
<script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
<script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
<script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="../gitbook/gitbook-plugin-lightbox/js/lightbox.min.js"></script>
<script src="../gitbook/gitbook-plugin-change_girls/girls.js"></script>
<script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>
</body>
</html>
