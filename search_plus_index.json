{"./":{"url":"./","title":"Introduction","keywords":"","body":" &#x1F42C; java学习记录 其中有些来自一些博客论坛，如有侵权，请联系作者 1832044043@qq.com 其中能加上原文地址的都已在文中尽可能加上 gitbook使用教程 Some study notes on java and python. Java learning comparison includes java basic syntax, java multi-threading, design patterns and Spring annotations. Python study notes include Python basic syntax, machine learning related libraries, and Anaconda tools. The basic Python syntax includes multi-process, multi-corout, decorator, Pythonic methods, generators and iterators, as well as some advanced tips. The machine learning library mainly includes matplotlib, numpy, pandas, scikit, skimage and other materials. javaとpythonに関するいくつかの研究ノート。 Javaの学習比較には、Javaの基本構文、Javaのマルチスレッド、デザインパターン、およびSpringの注釈が含まれます。 Pythonスタディノートには、Pythonの基本的な構文、機械学習関連のライブラリ、およびAnacondaツールが含まれています。 Pythonの基本的な構文には、マルチプロセス、マルチコルート、デコレータ、Pythonicメソッド、ジェネレータ、イテレータ、およびいくつかの高度なヒントがあります。 機械学習ライブラリには、主にmatplotlib、numpy、pandas、scikit、skimage、その他の資料が含まれています。 Деякі нотатки про дослідження на Java і Python. Порівняння Java навчання включає базовий синтаксис Java, багатопоточність Java, шаблони дизайну та анотації Spring. Зауваження Python включають базовий синтаксис Python, бібліотеки, пов'язані з машинним навчанням, і інструменти Anaconda. Основний синтаксис Python включає в себе багатопроцесорний, багатокорабельний, декоратор, Pythonic методи, генератори і ітератори, а також деякі вдосконалені поради. Бібліотека машинного навчання в основному включає в себе matplotlib, numpy, pandas, scikit, skimage та інші матеріали. જાવા અને પાયથોન પર કેટલાક અભ્યાસો નોંધે છે. જાવા લર્નિંગ સરખામણીમાં જાવા બેઝિક સિન્ટેક્સ, જાવા મલ્ટિ-થ્રેડિંગ, ડિઝાઇન પેટર્ન અને સ્પ્રિંગ એન્ટેશન્સ શામેલ છે. પાયથોન અભ્યાસ નોંધો પાયથોન મૂળભૂત વાક્યરચના, મશીન લર્નિંગ સંબંધિત પુસ્તકાલયો, અને એનાકોન્ડા સાધનોનો સમાવેશ કરે છે. મૂળભૂત પાયથોન સિન્ટેક્સમાં મલ્ટિ-પ્રોસેસ, મલ્ટિ-કોરઆઉટ, ડેકોનર, પાયથોનિક પદ્ધતિઓ, જનરેટર અને ઇટરેટર્સ, તેમજ કેટલીક વિગતવાર ટીપ્સ શામેલ છે. મશીન લર્નિંગ લાઇબ્રેરીમાં મુખ્યત્વે મેટપ્લોલિબ, numpy, pandas, scikit, skimage અને અન્ય સામગ્રી શામેલ છે. \\text{life}= \\underset{birth}{\\overset{death}{\\mathop \\int }}\\,\\frac{happiness}{time}\\vartriangle time [1] J. Yin, Y. Huang, B. Chen and S. Ye, \"Color Transferred Convolutional Neural Networks for Image Dehazing,\" in IEEE Transactions on Circuits and Systems for Video Technology. doi: 10.1109/TCSVT.2019.2917315 keywords: {Atmospheric modeling;Image color analysis;Integrated circuit modeling;Estimation;Standards;Computational modeling;Image dehazing;color transfer;deep learning}, URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8716692&isnumber=4358651 [2] Y. Wu, H. Tsai, Y. Huang and B. Chen, \"Accurate Emotion Recognition for Driving Risk Prevention in Driver Monitoring System,\" 2018 IEEE 7th Global Conference on Consumer Electronics (GCCE), Nara, 2018, pp. 796-797. doi: 10.1109/GCCE.2018.8574610 keywords: {convolution;driver information systems;emotion recognition;face recognition;feature extraction;feedforward neural nets;driving risk prevention;driver monitoring system;DeriskNet;deep convolutional neural network;audio resources;driving risks;facial emotion recognition;convolutional neural network designs;Vehicles;Emotion recognition;Monitoring;Convolution;Convolutional neural networks;Computer science;Sensors;driver monitoring;driving risks;negative emotions}, URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8574610&isnumber=8574475 [3] Y. Pang, S. Syu, Y. Huang and B. Chen, \"An Advanced Deep Framework for Recognition of Distracted Driving Behaviors,\" 2018 IEEE 7th Global Conference on Consumer Electronics (GCCE), Nara, 2018, pp. 802-803. doi: 10.1109/GCCE.2018.8574512 keywords: {behavioural sciences computing;convolution;driver information systems;feedforward neural nets;image recognition;road safety;deep convolutional neural networks;DedistractedNet;advanced deep framework;trainable deep framework;distracted driving behavior recognition;physiological sensors;on-board diagnostics;baseline CNN methods;Convolution;Image recognition;Measurement;Physiology;Sensors;Convolutional neural networks;Vehicles;driving behaviors;deep learning;image recognition}, URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8574512&isnumber=8574475 [4] J. Su, Y. Huang, J. Yin, B. Chen and S. Qu, \"Saliency-Guided Deep Framework for Power Consumption Suppressing on Mobile Devices,\" 2018 1st IEEE International Conference on Knowledge Innovation and Invention (ICKII), Jeju, 2018, pp. 191-194. doi: 10.1109/ICKII.2018.8569207 keywords: {image enhancement;image texture;mobile handsets;neural nets;telecommunication power management;visual perception;textual features;saliency-guided deep framework;power consumption suppressing;mobile devices;trainable power-constrained contrast enhancement algorithm;imaging features;displayed image;human visual perception;deep convolutional neural networks;perceptual quality;Power demand;Imaging;Convolution;Organic light emitting diodes;Energy efficiency;Technological innovation;Visualization;mobile devices;power consumption;deep framework}, URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8569207&isnumber=8569041 [5] Y. Huang, J. Yin, B. Chen and S. Ye, \"Impaired driving detection based on deep convolutional neural network using multimodal sensor data,\" 2018 IEEE International Conference on Applied System Invention (ICASI), Chiba, 2018, pp. 957-960. doi: 10.1109/ICASI.2018.8394429 keywords: {driver information systems;feature extraction;feedforward neural nets;road accidents;road safety;sensor fusion;deep convolutional neural network;multimodal sensor data;intelligent vehicle systems;advanced driving assistance systems;driving-related accidents;human injuries;impaired driving detection;collaborative information extraction;classifier;feature fusion;Feature extraction;Vehicles;Convolution;Sensors;Conferences;Accidents;Support vector machines;intelligent vehicle systems;multimodal sensor data;deep neural network}, URL: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8394429&isnumber=8394245 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/设计模式.html":{"url":"chapters/设计模式.html","title":"设计模式","keywords":"","body":"设计模式的概念设计模式的组成和分类UML图示说明六大设计原则单一职责原则(SRP)开放封闭原则(OCP)里式替换原则(LSP)迪米特法则(LKP)接口隔离原则(ISP)依赖倒置原则(DIP)创建型模式抽象工厂模式(Abstract Factory)建造者模式(Builder)工厂方法模式(Factory Method)原型模式(Prototype)单例模式(Singleton)行为型模式职责链模式(Chain of Responsibility)命令模式(Command)解释器模式(Interpreter)迭代器模式(Iterator)中介者模式(Mediator)备忘录模式(Memento)观察者模式(Observer)状态模式(State)策略模式(Strategy)模板方法模式(Template Method)访问者模式(Visitor)结构型模式适配器模式(Adapter)桥接模式(Bridge)概述意图抽象化实现化脱耦组合模式(Composite)透明与安全组合模式总结装饰模式(Decorator)外观模式(Facade)享元模式(Flyweight)代理模式(Proxy)设计模式总结 [TOC] 设计模式的概念 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 设计模式的组成和分类 根据其目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种： • 创建型模式主要用于创建对象。 • 结构型模式主要用于处理类或对象的组合。 • 行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。 根据范围（模式主要是用于处理类之间关系还是处理对象之间的关系）可分为类模式和对象模式两种： • 类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。 • 对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。 UML图示说明 Type Symbol Drawing Extension（扩展） Composition（组合） *-- Aggregation（聚合） o-- 使用.. 来代替 -- 可以得到点 线. 在这些规则下，也可以绘制下列图形 @startuml Class01 @startuml Class11 Class14 Class15 ..> Class16 Class17 ..|> Class18 Class19 @startuml Class21 #-- Class22 Class23 x-- Class24 Class25 }-- Class26 Class27 +-- Class28 Class29 ^-- Class30 @enduml 定义可访问性 一旦你定义了域或者方法，你可以定义相应条目的可访问性质。 Character Icon for field Icon for method Visibility - private # protected ~ package private + public 六大设计原则 学习6大设计原则、23种设计模式 总结下软件设计的六大原则 6大设计原则总结 JAVA设计模式总结之23种设计模式 图说设计模式 单一职责原则(SRP) There should never be more than one reason for a class to change. 理解：一个类应该只有一个发生变化的原因，即一个类只负责一项职责。如果一个类有多个职责，这些职责就耦合在了一起。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起会影响复用性。此原则的核心是解耦和增强内聚性。 总结：一个类只承担一个职责 开放封闭原则(OCP) Software entities like classes,modules and functions should be open for extension but closed for modifications. 理解：对扩展开放，对更改封闭。类模块应该是可扩展的，但是不可修改。 总结：对软件实体的改动，最好用扩展而非修改的方式。 里式替换原则(LSP) Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。 总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。 迪米特法则(LKP) Only talk to you immediate friends. 理解：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 总结：一定要做到：低耦合、高内聚。 接口隔离原则(ISP) The dependency of one class to another one should depend on the smallest possible interface. 理解：不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。 总结：不要对外暴露没有实际意义的接口。 依赖倒置原则(DIP) High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. 理解：高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。 总结：面向接口编程，提取出事务的本质和共性。 创建型模式 在线plantuml工具 plantuml语法 Draw Diagrams With Markdown 抽象工厂模式(Abstract Factory) @startuml abstract AbsBmwCar{ +drive() } note left: 抽象产品，代表了某一类的产品 class BmwSportCar{ +drive() } class BmwBusinessCar{ +drive() } note left: 具体某类产品 abstract AbsAudiCar{ +drive() } class AudiSportCar{ +drive() } class AudiBusinessCar{ +drive() } abstract AbsBenzCar{ +drive() } class BenzSportCar{ +drive() } class BenzBusinessCar{ +drive() } abstract AbsDriver{ +createBenzCar() +createBmwCar() +createAudiCar() } note left: 抽象工厂，包含了所有产品创建的抽象方法 class SportDriver{ +createBenzCar() +createBmwCar() +createAudiCar() } class BusinessDriver{ +createBenzCar() +createBmwCar() +createAudiCar() } class Client AbsBmwCar AbsBmwCar Client --> AbsAudiCar Client --> AbsBenzCar Client --> AbsDriver SportDriver ..> BmwSportCar SportDriver ..> BmwBusinessCar SportDriver ..> AudiSportCar SportDriver ..> AudiBusinessCar SportDriver ..> BenzSportCar SportDriver ..> BenzBusinessCar BusinessDriver ..> BmwSportCar BusinessDriver ..> BmwBusinessCar BusinessDriver ..> AudiBusinessCar BusinessDriver ..> AudiBusinessCar BusinessDriver ..> BenzSportCar BusinessDriver ..> BenzBusinessCar @enduml 《JAVA设计模式》之抽象工厂模式(Abstract Factory) 每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。 优点 抽象工厂模式正如其名字一样，理解起来非常抽象，正是因为这种抽象，使得抽象工厂模式非常强大和灵活，比其他两种工厂设计模式要强大很多。抽象工厂模式可以创建多个系列，并且每个系列抽象子类一一对应，这种强大的功能是其他两种工厂模式都不能实现的。 通过抽象工厂模式统一控制多个系列的抽象子类，可以用多个系列的抽象子类完成一些复杂的需求。例如我们文中说到的本地持久化方案的切换，最后通过我们的不断优化，做到只需要修改一个预编译指令的参数即可切换整个数据持久化方案，这是其他工厂模式所不能完成的。 抽象工厂模式延续了工厂模式的优点，外界接触不到任何类型的抽象子类，而只需要知道不同类型的抽象类即可，抽象子类的创建过程都在工厂子类中。这种设计方式充分的利用了面向对象语言中的多态特性，使灵活性大大提升。而且抽象工厂模式是非常符合开放封闭原则的，对扩展的开放以及对修改的封闭都完美支持。 缺点 抽象工厂模式带来的缺点也是显而易见的，最明显的缺点就是模式比较庞大，所以需要在适合的业务场景使用这种模式，否则会适得其反。 上面说到抽象工厂和工厂方法模式的功能添加都非常复杂，那么我们有没有什么办法可以简化呢？ 答案是肯定有的： 那就是工厂模式 + 配置文件 + 反射。具体怎么实现，请看下回分解。 建造者模式(Builder) 建造者模式 @startuml class Director{ -builder:Builder +construct():void } note top: 指挥者,构建一个使用Builder接口的对象 interface Builder{ #buildPart1():void #buildPart2():void #retrieveResult():Product } note top: Builder是为创建一个Product对象\\n的各个部件指定的抽象接口 class Product { -part1:String -part2:String } note bottom: 具体产品 class ConcreteBuilder{ -product:Product #buildPart1():void #buildPart2():void #retrieveResult():Product } note bottom: 具体创建者,实现Builder接口,\\n构建和装配各个部件 Builder Product Director o-right-> Builder @enduml 工厂方法模式(Factory Method) @startuml interface Icar{ +run() } class Audi{ +run() } class Byd{ +run() } interface ICarFactory{ +createCar() } class AudiFactory{ +createCar() } class BydFactory{ +createCar() } Icar .left.> ICarFactory Icar 工厂方法模式角色： ​ 抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 ​ 具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。 ​ 抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 ​ 具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。 在工厂方法模式中，核心工厂类不在负责产品的创建，而是将具体的创建工作交给子类去完成。也就是后所这个核心工厂仅仅只是提供创建的接口，具体实现方法交给继承它的子类去完成。 原型模式(Prototype) @startuml class Client{ } note right:让一个原型克隆自身,\\n从而新建一个对象 abstract Shape{ -id:String #type:String +draw():void +clone():Object } note top: 原型类,定义实现一个克隆自身的方法 class Rectangle{ +draw():void } note bottom: 具体原型类,实现自己的操作 class Square{ +draw():void } class Circle{ +draw():void } class ShapeCache { -shapeMap:Hashtable +getShape(shapeId:String):Shape +loadCache():void } note bottom: 从数据库获取实体类，并把它们存储在一个Hashtable中 Shape ShapeCache @enduml 单例模式(Singleton) @startuml class Singleton{ -instance : Singleton -Singleton() +GetInstance() } note right:Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。\\n GetInstance是一个静态方法，主要创建自己的唯一实例 @enduml 单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如： （1）需要频繁实例化然后销毁的对象。 （2）创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 （3）有状态的工具类对象。 （4）频繁访问数据库或文件的对象。 package per.hyc.designPattern.Singleton; /** * 1、懒汉式，线程不安全 * 是否 Lazy 初始化：是 * 是否多线程安全：否 * 实现难度：易 * 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 * 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 */ class SingleObject_1 { private static SingleObject_1 instance; private SingleObject_1() { } public static SingleObject_1 getInstance() { if (instance == null) { instance = new SingleObject_1(); } return instance; } public void showMessage() { System.out.println(\"1、懒汉式，线程不安全\"); } } /** * 2、懒汉式，线程安全 * 是否 Lazy 初始化：是 * 是否多线程安全：是 * 实现难度：易 * 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 * 优点：第一次调用才初始化，避免内存浪费。 * 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 * getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 */ class SingleObject_2 { private static SingleObject_2 instance; private SingleObject_2() { } public static synchronized SingleObject_2 getInstance() { if (instance == null) { instance = new SingleObject_2(); } return instance; } public void showMessage() { System.out.println(\"2、懒汉式，线程安全\"); } } /** * 3、饿汉式 * 是否 Lazy 初始化：否 * 是否多线程安全：是 * 实现难度：易 * 描述：这种方式比较常用，但容易产生垃圾对象。 * 优点：没有加锁，执行效率会提高。 * 缺点：类加载时就初始化，浪费内存。 * 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化， * 虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， * 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance * 显然没有达到 lazy loading 的效果。 */ class SingleObject_3 { private static SingleObject_3 instance = new SingleObject_3(); private SingleObject_3() { } public static SingleObject_3 getInstance() { return instance; } public void showMessage() { System.out.println(\"3、饿汉式\"); } } /** * 4、双检锁/双重校验锁（DCL，即 double-checked locking） * JDK 版本：JDK1.5 起 * 是否 Lazy 初始化：是 * 是否多线程安全：是 * 实现难度：较复杂 * 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 * getInstance() 的性能对应用程序很关键。 */ class SingleObject_4 { private volatile static SingleObject_4 singleton; private SingleObject_4() { } public static SingleObject_4 getInstance() { if (singleton == null) { synchronized (SingleObject_4.class) { if (singleton == null) { singleton = new SingleObject_4(); } } } return singleton; } public void showMessage() { System.out.println(\"4、双检锁/双重校验锁（DCL，即 double-checked locking）\"); } } /** * 5、登记式/静态内部类 * 是否 Lazy 初始化：是 * 是否多线程安全：是 * 实现难度：一般 * 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化， * 应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况， * 双检锁方式可在实例域需要延迟初始化时使用。 * 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程， * 它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了， * 那么 instance 就会被实例化（没有达到 lazy loading 效果）， * 而这种方式是 Singleton 类被装载了，instance 不一定被初始化。 * 因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时， * 才会显式装载 SingletonHolder 类，从而实例化 instance。 * 想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载， * 另外一方面，又不希望在 Singleton 类加载时就实例化， * 因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载， * 那么这个时候实例化 instance 显然是不合适的。 * 这个时候，这种方式相比第 3 种方式就显得很合理。 */ class SingleObject_5 { private static class SingletonHolder { private static final SingleObject_5 INSTANCE = new SingleObject_5(); } private SingleObject_5() { } public static final SingleObject_5 getInstance() { return SingletonHolder.INSTANCE; } public void showMessage() { System.out.println(\"5、登记式/静态内部类\"); } } /** * 6、枚举 * JDK 版本：JDK1.5 起 * 是否 Lazy 初始化：否 * 是否多线程安全：是 * 实现难度：易 * 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。 * 它更简洁，自动支持序列化机制，绝对防止多次实例化。 * 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题， * 而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 * 不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏， * 在实际工作中，也很少用。 * 不能通过 reflection attack 来调用私有构造方法。 */ enum SingleObject_6 { INSTANCE; public void showMessage() { System.out.println(\"6、枚举\"); } } /** * 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。 * 只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。 * 如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。 * 如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 */ public class Singleton { static void TestSingleObject_1() { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject_1 object = SingleObject_1.getInstance(); //显示消息 object.showMessage(); } static void TestSingleObject_2() { //获取唯一可用的对象 SingleObject_2 object = SingleObject_2.getInstance(); //显示消息 object.showMessage(); } static void TestSingleObject_3() { //获取唯一可用的对象 SingleObject_3 object = SingleObject_3.getInstance(); //显示消息 object.showMessage(); } static void TestSingleObject_4() { //获取唯一可用的对象 SingleObject_4 object = SingleObject_4.getInstance(); //显示消息 object.showMessage(); } static void TestSingleObject_5() { //获取唯一可用的对象 SingleObject_5 object = SingleObject_5.getInstance(); //显示消息 object.showMessage(); } static void TestSingleObject_6() { //获取唯一可用的对象 SingleObject_6 object = SingleObject_6.INSTANCE; //显示消息 object.showMessage(); } public static void main(String[] args) { TestSingleObject_1(); TestSingleObject_2(); TestSingleObject_3(); TestSingleObject_4(); TestSingleObject_5(); TestSingleObject_6(); } } 1、懒汉式，线程不安全 2、懒汉式，线程安全 3、饿汉式 4、双检锁/双重校验锁（DCL，即 double-checked locking） 5、登记式/静态内部类 6、枚举 行为型模式 职责链模式(Chain of Responsibility) @startuml abstract AbstractLogger{ #level:int +logMessage(level: int, message:string) +setNextLogger(nextLogger: AbstractLogger) +write(message:string) } note right: 定义一个处理请示的接口 class Client class ConsoleLogger{ +write(message:string) } class ErrorLogger{ +write(message:string) } class FileLogger{ +write(message:string) } note bottom: 具体处理者类，处理它所负责的请求，可访问它的后继者，\\n 如果可以处理该请求就处理，不然将请求转发给它的后继者 Client -right-> AbstractLogger AbstractLogger 优点 责任链模式将请求和处理分开，请求者不知道是谁处理的，处理者可以不用知道请求的全貌。 提高系统的灵活性。 缺点 降低程序的性能。每个请求都是从链头遍历到链尾，当链比较长的时候，性能会大幅下降。 不易于调试。由于该模式采用了类似递归的方式，调试的时候逻辑比较复杂。 应用场景 责任链模式是一种常见的模式，Struts2的核心控件FilterDispatcher是一个Servlet过滤器，该控件就是采用责任链模式，可以对用户请求进行层层过滤处理。责任链模式在实际项目中的使用比较多，其典型的应用场景如下： 一个请求需要一系列的处理工作。 业务流的处理，例如文件审批。 对系统进行扩展补充。 在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。 责任链模式是一种对象行为型模式，其主要优点如下。 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。 命令模式(Command) @startuml class Invoker{ -concreteCommandA:ICommand -concreteCommandB:ICommand +orderA():void +orderB():void } note top: 要求该命令执行这个请求 interface ICommand { +execute():void } note top: 用来声明执行操作的接口 class ConcreteCommandA{ -receiver:Receiver +execute():void } class ConcreteCommandB{ -receiver:Receiver +execute():void } note bottom: 将一个接收者对象绑定于一个动作,\\n调用接收者相应的操作,以实现Execute class Receiver{ +execute():void } note bottom: 知道如何实施与执行一个请求相关\\n的操作,任何类都可能作为一个接收者 Client .right.> Invoker Client .right.> Receiver ICommand ICommand Receiver 命令模式的几个角色： 抽象命令接口ICommand：定义命令的接口，声明执行的方法。 具体的命令对象ConcreteCommand：持有具体的接受者对象，完成具体的具体的命令。 接受者对象Receiver：接受者对象，真正执行命令的对象。 传递命令对象Invoker：持有命令对象，要求命令对象执行请求。 客户端对象Client：创建具体命令的对象并且设置命令对象的接受者。 Java设计模式（18）之命令模式 解释器模式(Interpreter) @startuml abstract ReadXmlExpression{ +interpret(c:Context):String[] } note left: 抽象表达式,声明一个抽象的解释操作,\\n这个接口为抽象语法树中所有的节点共享 class ElementExpression{ -eles:Collection -eleName:String +addEle(ele:ReadXmlExpression):boolean +removeEle(ele:ReadXmlExpression):boolean +interpret(c:Context):String[] } note bottom: 非终结表达式,为文法中的非终结\\n符实现解释操作。对文法中每一条\\n规则R1..Rn都需要一个具体的非终结符\\n表达式类 class ElementTerminalExpression{ -eleName:String +interpret(c:Context):String[] } note bottom: 终结表达式,实现与文法中的终结符\\n相关联的解释操作 class PropertyTerminalExpression{ -eleName:String +interpret(c:Context):String[] } class Context{ -preEle:Element -document:Document +reInit():void +getNowEle(pEle:Element,eleName:String):Element } note right: 包含解释器之外的一些全局信息 ReadXmlExpression Context Clinet ..> ReadXmlExpression ElementExpression o--> ReadXmlExpression @enduml 迭代器模式(Iterator) @startuml interface IAggregate{ +CreateIterator(): int } note top: 聚集接口 class Client interface AbsIterator{ +First() +Next() +IsDone() +CurrentItem() } note top: 迭代接口类，用于得到开始对象、 \\n 得到下一个对象、判断是否到结尾、 \\n 当前对象等抽象方法，统一接口 class ConcreteIterator note bottom: 具体迭代器类 class ConcreteAggregate{ +CreateIterator(): int } note bottom: 具体聚集类，继承自IAggregate Client -left-> AbsIterator Client -right-> IAggregate IAggregate ConcreteIterator @enduml 中介者模式(Mediator) @startuml interface Mediator note left: 接口终中介者，定义了Colleague \\n 对象到Mediator对象的接口 abstract AbsColleague class ConcreteMediator note left: 具体中介者对象，实现抽象类的方法，\\n 它需要知道所有具体的Colleague类，并从具体的 \\n Colleague接收消息，向具体Colleague对象发出命令 class ColleagueA note top: 具体Colleague类，每个具体Colleague只知道自己 \\n 的行为，而不了解其他Colleague类的情况， \\n 但它们却都认识Mediator对象 class ColleagueB Mediator 中介者模式的定义 用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。 中介者模式的优点 适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。 使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。 使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。 适用场景 在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性，适当的使用中介者模式可以使原本凌乱的对象关系清晰，但是如果滥用，则可能会带来反的效果。一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。 中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数的情况，同事类之间的关系不会复杂到混乱不堪的网状结构，因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式。滥用中介者模式，只会让事情变的更复杂。 优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。 缺点： 1.中介者会庞大，变得复杂难以维护。 2.如果中介者类出现问题，将会导致所有相关类出问题。 Where: 多个类相互耦合，形成了网状结构。 设计模式之中介者模式（Mediator Pattern） 备忘录模式(Memento) Java设计模式学习记录-备忘录模式https://www.cnblogs.com/jimoer/p/9537997.html @startuml class Game{ +playerStep:int +restore(gameMemento: GameMemento):void +createGameMemento():GameMemento } note Bottom: 负责创建一个备忘录GameMemento， \\n 用以记录当前时刻的内部状态， \\n 并可使用备忘录恢复内部状态 class GameMemento{ -playerSteps:int } note top: 负责存储Game对象的内部状态，\\n 并可防止Game以外的对象访问 \\n 备忘录GameMemento class Caretaker{ -gameMemento: GameMemento +saveMemento(gameMemento:GameMemento):void } note right: 负责保存好备忘录GameMemento Game .right.> GameMemento GameMemento 观察者模式(Observer) @startuml class ISubject{ +attach(observer: Observer) +detach(observer: Observer) +notifyAllObservers() } note top: ISubject类,它把所有对观察者对象的引用保存在一个\\n聚集里,每个主题都可以有任何数量的观察者. 主题提供\\n一个接口,可以增加和删除观察者对象 class Subject{ #observers:List +state: int +getState() +setState() +attach(observer: Observer) +detach(observer: Observer) +notifyAllObservers() } note bottom: Subject类,具体主题,将有关状态存入\\n具体观察者对象;在具体主题的内部状态改变\\n的时候，给所有登记过的观察者发出通知 abstract Observer{ #subject:Subject +update() } note top: 抽象观察者,为所有的具体观察者定义\\n一个接口,在得到主题的通知时更新自己 class BinaryObserver{ +update() } class OctalObserver{ +update() } note bottom: 具体观察者,实现抽象观察者角色所\\n要求的更新接口,以便使自身状态与主题状态相协调 class HexaObserver{ +update() } ISubject Observer @enduml 状态模式(State) @startuml interface State note left: 状态类接口，定义一个接口以封装与 \\n Context的一个特定状态相关的行为 class Context{ +Request() } note left: 维护一个ConcreteState子类的实例，\\n 这个实例定义当前的状态 class ConcreteStateA{ +Handle() } note right: 具体状态，每一个子类实现一个 \\n 与Context的一个状态相关的行为 class ConcreteStateB{ +Handle() } class ConcreteStateC{ +Handle() } Context o--> State State 策略模式(Strategy) @startuml class OperationAdd{ +doOperation() } class OperationSubstract{ +doOperation() } class OperationMultiply{ +doOperation() } note bottom: 具体策略类，封装了具体的算法或行为，继承于IStrategy class Context{ +executeStrategy() } note bottom: Context上下文，用一个 \\n ConcreateStategy来配置， \\n 维护一个对IStrategy对象的引用 interface IStrategy{ +doOperation() } note right:策略类，定义所有支持的算法的公共接口 Context 二十三种设计模式 - 策略模式 模式定义 策略模式：属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。 策略模式：使得算法可以在不影响到客户端的情况下发生变化。 策略模式：是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。 参与者 策略模式参与者： Context：环境角色，持有一个Strategy的引用。 Strategy：抽象策略角色，这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 ConcreteStrategy：具体策略角色，包装了相关的算法或行为 优点： 业务逻辑和前端展示相互分离开了。业务逻辑的修改，不影响前端代码展示。 每一个业务逻辑单独一个类，修改或者添加一个类，不会影响到其他的类。 使用工厂类封装了业务逻辑类，前端不需要知道到底每种业务怎么实现，只需要知道他的父类即可。 缺点： 如果活动很频繁，经常会搞各种各样的活动，那么业务逻辑就会有很多种，每一次都要增加一个类。 每增加一个类都要修改工厂类，修改会很频繁。 策略模式的优点 （1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 （2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点 （1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 （2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观 用途不一样 工厂是创建型模式,它的作用就是创建对象； 策略是行为型模式,它的作用是让一个对象在许多行为中选择一种行为; 关注点不一样 一个关注对象创建 一个关注行为的封装 解决不同的问题 工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。 策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。 工厂相当于黑盒子，策略相当于白盒子； 模板方法模式(Template Method) @startuml abstract AbsTestPaper{ +TestQuestion1() +TestQuestion2() +TestQuestion3() +Answer1() +Answer2() +Answer3() } class TestPaperA{ +Answer1() +Answer2() +Answer3() } class TestPaperB{ +Answer1() +Answer2() +Answer3() } AbsTestPaper 访问者模式(Visitor) 设计模式：访问者（Visitor）模式 访问者模式一篇就够了 @startuml class Clinet{ +visitor() } abstract Staff{ +accept(visitor: Visitor) } note top: 定义一个accept操作,它以一个访问为参数 class Engineer{ +accept(visitor: Visitor) } class Manager{ +accept(visitor: Visitor) } note bottom: 具体元素,实现accept操作 class BusinessReport{ -mStaffs: List +showReport(visitor: Visitor) } note bottom: 能枚举它的元素,可以提供一个高层的接口\\n以允许访问者访问它的元素 interface Visitor{ +visit(engineer: Engineer) +visit(manager: Manager) } note top:为该对象结构中每个实现类声明一个visit操作 class CEOVisitor{ +visit(engineer: Engineer) +visit(manager: Manager) } class CTOVisitor{ +visit(engineer: Engineer) +visit(manager: Manager) } note bottom: 具体访问者,实现每个由Visitor声明的操作,\\n每个操作实现算法的一部分,而该算法\\n片段仍是对应于结构中对象的类 Staff BusinessReport Clinet -right-> Visitor BusinessReport -left-> Staff @enduml 角色介绍 Visitor：接口或者抽象类，定义了对每个 Element 访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁地修改 Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。 ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。 Element：元素接口或者抽象类，它定义了一个接受访问者（accept）的方法，其意义是指每一个元素都要可以被访问者访问。 ElementA、ElementB：具体的元素类，它提供接受访问的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。 结构型模式 适配器模式(Adapter) @startuml abstract AbsPlayer{ +attack() +defense() } note left: 球员抽象类 class Forwards{ +attack() +defense() } class Center{ +attack() +defense() } class Guards{ +attack() +defense() } class Translator{ +attack() +defense() } class ChinaCenter{ +jingong() +fangshou() } note left: 中国中锋 AbsPlayer 优点： 1：将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。 2：增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一适配者类可以在多个不同的系统中复用。 3：灵活性和扩展性都非常好，通过使用配置文件，可以很方便的更换适配器，也可以在不修改原有代码的基础上 增加新的适配器，完全复合开闭原则。 缺点： 1：一次最多只能适配一个适配者类，不能同时适配多个适配者。 2：适配者类不能为最终类，在C#中不能为sealed类 3：目标抽象类只能为接口，不能为类，其使用有一定的局限性。 桥接模式(Bridge) @startuml interface Color{ +bepaint(penType:String,name:String):void } class Blue{ +bepaint(penType:String,name:String):void } class Green{ +bepaint(penType:String,name:String):void } class Pen{ #color:Color +draw(name:String):void } class SmallPen{ +draw(name:String):void } class MiddlePen{ +draw(name:String):void } Pen Color @enduml 概述 在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。 意图 【GOF95】在提出桥梁模式的时候指出，桥梁模式的用意是\"将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化\"。这句话有三个关键词，也就是抽象化、实现化和脱耦。 抽象化 存在于多个实体中的共同的概念性联系，就是抽象化。作为一个过程，抽象化就是忽略一些信息，从而把不同的实体当做同样的实体对待【LISKOV94】。 实现化 抽象化给出的具体实现，就是实现化。 脱耦 所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。 将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联。因此，桥梁模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以相对独立地变化。这就是桥梁模式的用意。 组合模式(Composite) @startuml abstract AbsCompany{ +add(company: AbsCompany) +remove(company: AbsCompany) +display(depth: int) +lineOfDuty() } note right: 组合中的对象声明接口，在适当情况下，\\n 实现所有类共有接口的默认行为。声明一个\\n 接口用于访问和管理AbsCompany的子部件 class ConcreteCompany{ +add(company: AbsCompany) +remove(company: AbsCompany) +display(depth: int) +lineOfDuty() } note bottom: 定义有枝节点行为，用来存储子部件，\\n 在AbsCompany接口中实现与子部件有关 \\n 的操作，比如增加Add和删除Remove class HRDepartment{ +add(company: AbsCompany) +remove(company: AbsCompany) +display(depth: int) +lineOfDuty() } note bottom: 在组合中表示叶节点对象， \\n 叶节点没有子节点 class FinanceDepartment{ +add(company: AbsCompany) +remove(company: AbsCompany) +display(depth: int) +lineOfDuty() } AbsCompany 组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有 \"整体—部分\" 关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为 \"整体—部分\"(Part-Whole) 模式，它是一种对象结构型模式。 由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式，Java SE中的AWT和Swing包的设计就基于组合模式。 除此以外，在XML解析、组织结构树处理、文件系统设计等领域，组合模式都得到了广泛应用。 角色 Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。 Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。 Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。 透明与安全 在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安 全组合模式两种形式。 透明组合模式 透明组合模式中，抽象构件角色中声明了所有用于管理成员对象的方法，譬如在示例中 Component 声明了 add、remove 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 安全组合模式 在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在容器构件 Composite 类中声明并实现这些方法。 组合模式总结 组合模式的主要优点如下： 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 组合模式的主要缺点如下： 使得设计更加复杂，客户端需要花更多时间理清类之间的层次关系。 在增加新构件时很难对容器中的构件类型进行限制。 适用场景： 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 在一个使用面向对象语言开发的系统中需要处理一个树形结构。 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。 装饰模式(Decorator) @startuml interface IComponent{ +Operation() } note left: IComponent是定义一个对象接口，\\n 可以给这些对象动态地添加职责 class ConcreteComponent{ +Operation() } note bottom: ConcreteComponent是定义了一个具体的对象，\\n 也可以给这个对象添加一些职责 abstract AbsDecorator{ -component:IComponent +Operation() } note left: AbsDecorator，装饰抽象类，\\n 继承了IComponent，从外类来扩展\\n IComponent类的功能，\\n 但对于IComponent来说，是无需知道\\n AbsDecorator的存在的 class ConcreteDecoratorA{ +Operation() -AddedBehaviorA() } class ConcreteDecoratorB{ +Operation() -AddedBehaviorB() } note bottom: ConcreteDecorator就是具体的装饰对象，\\n 起到给IComponent添加职责的功能 IComponent 装饰器模式：在不改变原有结构的情况下，允许动态的给一个现有对象添加一些额外的职责（额外的结构） 装饰器模式主要解决：动态对一个类进行扩展，保证其原有结构不变的基础上获得新的结构和功能。这种扩展不以继承的方式实现，有效的防止子类过分膨胀的问题。 优点：装饰类和被装饰类可以独立发展，不会相互耦合。 装饰模式是继承的一个替代的方法，装饰模式可以动态扩展一个实现类的功能。另外，装饰模式可以实现未知顺序的扩展，将原有的父子结构转换为兄弟结构，降低系统的耦合度。 装饰器模式的优点 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。 装饰器模式的缺点 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 外观模式(Facade) @startuml class ControllerFacade{ +on():void +off():void } note right: Facadew外观类\\n 知道哪些子系统负责处理请求，\\n 将客户的请求代理给适当的子系统对象 class Light{ +on():void +off():void } class Television{ +on():void +off():void } class Aircondition{ +on():void +off():void } class Client Client -right-> ControllerFacade ControllerFacade--> Light ControllerFacade --> Television ControllerFacade--> Aircondition @enduml 门面模式要求一个子系统的外部与其内部的通信必须通过一个统一的门面(Facade)对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 就如同医院的接待员一样，门面模式的门面类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与门面对象打交道，而不需要与子系统内部的很多对象打交道。 初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。 享元模式(Flyweight) 享元模式 享元模式（Flyweight）又称为 轻量级模式，它是一种对象结构型模式。 面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式 正是为解决这一类问题而诞生的。 享元模式 是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。享元模式 也是为了减少内存的使用，避免出现大量重复的创建销毁对象的场景。 享元模式 的宗旨是共享细粒度对象，将多个对同一对象的访问集中起来，不必为每个访问者创建一个单独的对象，以此来降低内存的消耗。 享元模式 把一个对象的状态分成内部状态和外部状态，内部状态即是不变的，外部状态是变化的；然后通过共享不变的部分，达到减少对象数量并节约内存的目的。 享元模式 本质：缓存共享对象，降低内存消耗 @startuml interface IFlyweight{ +operation(extrinsicState:String):void } class ConcreteFlyweight{ -intrinsicState:String +operation(extrinsicState:String):void } class FlyweightFactory{ -pool:Map +getFlyweight(intrinsicState:String):IFlyweight } class Client Client ..> FlyweightFactory ConcreteFlyweight --|> IFlyweight FlyweightFactory o-right- IFlyweight ConcreteFlyweight 享元模式（Flyweight）又称为 轻量级模式，它是一种对象结构型模式。 面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式 正是为解决这一类问题而诞生的。 享元模式 是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。享元模式 也是为了减少内存的使用，避免出现大量重复的创建销毁对象的场景。 享元模式 的宗旨是共享细粒度对象，将多个对同一对象的访问集中起来，不必为每个访问者创建一个单独的对象，以此来降低内存的消耗。 享元模式 把一个对象的状态分成内部状态和外部状态，内部状态即是不变的，外部状态是变化的；然后通过共享不变的部分，达到减少对象数量并节约内存的目的。 享元模式 本质：缓存共享对象，降低内存消耗 优点 享元模式 可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低内存占用，增强程序的性能； 享元模式 的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享； 缺点 享元模式 使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化； 为了使对象可以共享，享元模式 需要将享元对象的状态外部化，而且外部状态必须具备固化特性，不应该随内部状态改变而改变，否则会导致系统的逻辑混乱； 使用场景 系统中存在大量的相似对象； 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份； 需要缓冲池的场景； java中，从享元模式角度再看String String a = \"将导致运行代价过高\"; String b = \"将导致运行代价过高\"; String c = new String(\"将导致运行代价过高\"); String d = new String(\"将导致运行代价过高\"); a==b true c==d false 代理模式(Proxy) @startuml interface IGiveGift{ +giveDolls() +giveFlowers() } note right: IGiveGift类，定义了Pursuit和GiftProxy的公用接口，\\n 这样就在任何使用Pursuit的地方都可以使用GiftProxy class Pursuit{ +giveDolls() +giveFlowers() } class GiftProxy{ +giveDolls() +giveFlowers() } Client -right-> IGiveGift IGiveGift 代理模式：为其他对象提供一种代理以控制对这个对象的访问。 代理模式使用一个代理类来代表另一个类的功能，代理类持有现有对象，并利用现有对象对外界提供功能。代理模式可以看作是对原有对象的一个再包装，现在其他对象对原有对象的访问都应该通过代理的模式来做，起到控制访问的效果。 代理模式主要解决：直接访问对象的时候需要很多额外的操作（比如权限控制，安全性检查等），这个对象被访问的时候希望能无一例外的对这些请求做控制，此时则需要使用到代理模式。 优点： 1、职责清晰，满足单一职责原则。 被代理者和代理者各自负责自己的职责即可，将被代理者的访问控制转移到代理者身上。 2、高扩展性，代理者可以作为一个被代理者被再次包装，在不改变原有结构的基础上扩展新功能。 代理模式可以看作是一种特殊目的的装饰器模式。 装饰器是在不改变原有类的结构下，为其增加新的功能。代理模式则是在不改变原有类的结构下，控制其他类对其的访问，这种控制功能可以看作是为原有类增加的特殊的新功能。 代理模式为了实现对原有类的访问的控制，则要求持有原有对象。装饰器模式没有必要的要求，装饰器模式可以和被装饰类（原有类）互相独立，只需要在需要装饰的时候可以获取到被装饰类即可。 依据第二点，可以看出代理模式和装饰器模式之间最大的区别在于：代理模式中，代理者和被代理者的关系需要在编译时就确定下来，实现对被代理者的有效控制；装饰器模式中，装饰者和被装饰者之间是相互独立的，当被装饰者有新功能需要添加的时候，使用合适的装饰者将其装饰即可。 设计模式总结 设计模式总结 设计模式总结 常见设计模式总结 设计模式 用法 单例 保证类的实例只有一个 简单工厂 根据参数创建对应具体子类 策略 算法、规则的封装、传入具体调用，调用具体算法 装饰者 动态对一个对象进行增属性、调用方法等操作，链式操作随意组合。梳头、画眉、只梳头不画眉、只画眉不梳头 工厂方法 创建类，一个实现类要有一个工厂类总是通过对应的工厂类创建实现类，判断在客户端进行。工厂类太多。 代理 对象中保存能执行另一种操作的对象，通过这个保存的对象去操作。 原型 用克隆(Clone)，代替new对象。克隆的方式能够保留一些同样的信息。 模板方法 提炼出相同的公共代码，封装为一个方法模板。 外观 通过改造内部实现，让外部看起来调用的方式很简单(如，实际需要调用3个方法，但增加一个方法来调用这3个方法，让外部只调用一个方法即可)。 建造者 将一个复制对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 观察者 观察者类里面放了一个集合，包含了多个被通知类，被通知类实现一个抽象方法，有一个方法接受通知。 抽象工厂 增加一个接口，让外部依赖接口而不是具体类 状态 多个大致相同的类，只是状态不同，随着不停的调用一个状态会转为另一个状态(一个类转为另一个类) 适配器 将一个类的接口转换成客户希望的另外一个接口可以理解为，仅仅改为一个方法名，在方法内部调用真正的方法(名字不同)。 备忘录 增加一个类用于存储状态，一个类负责备份和恢复状态 组合 部分-整体关系，解决无限递归问题。 迭代器 分离了集合对象的遍历行为，抽象出一个迭代器类来负责。解决遍历问题 桥接 将继承关系分离出来改为聚合关系 命令 对请求的封装，请求-》真正执行(队列) 职责链 类似于Asp.net管道，一条链操作，每个类都有处理的机会没权限就往上级抛，直到有权限的类能够处理 中介者 通过一个中介类来处理两个类之间的信息交换 享元 对象的大多数状态为外部状态，如果删除对象的外部状态那么可以用相对较少的共享对象取代很多组对象。 访问者 它把数据结构和作用于结构上的操作之间的耦合解脱开（用类封装变化的数据） 解释器 用类去封装一条规则 graph LR A[Hard edge] -->B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] C -->|Two| F[Result two] F -->|Two| G[Result two] Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/多线程_基础篇.html":{"url":"chapters/多线程_基础篇.html","title":"多线程_基础篇","keywords":"","body":"基础篇实现多线程的两种方式synchronized关键字线程等待与唤醒线程让步yield()线程休眠sleep()join() 方法interrupt()和线程终止方式线程优先级和守护线程生产消费者问题 [TOC] 基础篇 1. Java多线程系列目录(共43篇)-转 https://www.jianshu.com/p/dca27f047923 https://www.cnblogs.com/skywang12345/p/java_threads_category.html 线程共包括以下5种状态： 新建状态(New) : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。 就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。 运行状态(Running): 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 阻塞状态(Blocked) : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： (01) 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。 (02) 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。 (03) 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 扩展： Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。 Thread类，线程操作函数。例如sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。 synchronized关键字，区分为synchronized代码块和synchronized方法，让线程获取对象的同步锁。 实现多线程的两种方式 1. Runnable 是一个接口，该接口中只包含了一个run()方法。 Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。 2. Thread 是一个类。Thread本身就实现了Runnable接口。Thread的作用，实现多线程。 Thread和Runnable的异同点 Thread 和 Runnable 的相同点：都是“多线程的实现方式”。 Thread 和 Runnable 的不同点： Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。 此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。//通常，建议通过“Runnable”实现多线程！ Runnable的多线程示例 class MyThread implements Runnable { private int ticket = 10; public void run() { for (int i = 0; i 0) { System.out.println(Thread.currentThread().getName() + \" 卖票：ticket\" + this.ticket--); } } } }; public class Test { public static void main(String[] args) { MyThread mt = new MyThread(); // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！ Thread t1 = new Thread(mt); Thread t2 = new Thread(mt); Thread t3 = new Thread(mt); t1.start(); t2.start(); t3.start(); } } //结果说明： (01) 和下面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。 (02) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。 Thread-1 卖票：ticket10 Thread-2 卖票：ticket9 Thread-0 卖票：ticket9 Thread-2 卖票：ticket7 Thread-1 卖票：ticket8 Thread-2 卖票：ticket5 Thread-0 卖票：ticket6 Thread-2 卖票：ticket3 Thread-1 卖票：ticket4 Thread-2 卖票：ticket1 Thread-0 卖票：ticket2 Thread的多线程示例 class MyThread extends Thread{ private int ticket=5; public void run(){ for(int i=0;i0){ System.out.println(this.getName()+\" 卖票：ticket\"+this.ticket--); } } } } public class Test { public static void main(String[] args) { // 启动3个线程t1,t2,t3；每个线程各卖10张票！ MyThread t1=new MyThread(); MyThread t2=new MyThread(); MyThread t3=new MyThread(); t1.start(); t2.start(); t3.start(); } } //结果说明： (01) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出10张票。 (02) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了10张票。 Thread-0 卖票：ticket5 Thread-0 卖票：ticket4 Thread-0 卖票：ticket3 Thread-0 卖票：ticket2 Thread-0 卖票：ticket1 Thread-1 卖票：ticket5 Thread-1 卖票：ticket4 Thread-1 卖票：ticket3 Thread-1 卖票：ticket2 Thread-1 卖票：ticket1 Thread-2 卖票：ticket5 Thread-2 卖票：ticket4 Thread-2 卖票：ticket3 Thread-2 卖票：ticket2 Thread-2 卖票：ticket1 Thread中start()和run()的区别 start(): 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。 run(): run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！ synchronized关键字 synchronized原理 在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。 当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。 不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。 synchronized基本规则 第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 // 第一条 class MyRunable implements Runnable { @Override public void run() { synchronized(this) { try { for (int i = 0; i // 第一条_续 class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { synchronized(this) { try { for (int i = 0; i // 第二条 class Count { // 含有synchronized同步块的方法 public void synMethod() { synchronized(this) { try { for (int i = 0; i // 第三条 class Count { // 含有synchronized同步块的方法 public void synMethod() { synchronized(this) { try { for (int i = 0; i synchronized方法 和 synchronized代码块 // synchronized方法示例 public synchronized void foo1() { System.out.println(\"synchronized methoed\"); } // synchronized代码块 public void foo2() { synchronized (this) { System.out.println(\"synchronized methoed\"); } } // synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。 // synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。 实例锁和全局锁 实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。 // 实例锁对应的就是synchronized关键字。 全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 // 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。 pulbic class Something { public synchronized void isSyncA(){} public synchronized void isSyncB(){} public static synchronized void cSyncA(){} public static synchronized void cSyncB(){} } 假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。 (01) (不能被同时访问)x.isSyncA()与x.isSyncB() (02) (可以同时被访问)x.isSyncA()与y.isSyncA() (03) (不能被同时访问)x.cSyncA()与y.cSyncB() (04) (可以被同时访问)x.isSyncA()与Something.cSyncA() // (01) 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！ // LockTest1.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i // (02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。 // LockTest2.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i // (03) 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时访问。 // LockTest3.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i // (04) 可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。 // LockTest4.java的源码 class Something { public synchronized void isSyncA(){ try { for (int i = 0; i 线程等待与唤醒 wait(), notify(), notifyAll()等方法介绍 Object类中关于等待/唤醒的API详细信息如下： notify() -- 唤醒在此对象监视器上等待的单个线程。 notifyAll() -- 唤醒在此对象监视器上等待的所有线程。 wait() -- 当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。 wait(long timeout) -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 wait(long timeout, int nanos) -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。 wait()和notify()示例 // WaitTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { System.out.println(Thread.currentThread().getName()+\" call notify()\"); // 唤醒当前的wait线程 notify(); } } } public class WaitTest { public static void main(String[] args) { ThreadA t1 = new ThreadA(\"t1\"); synchronized(t1) { try { // 启动“线程t1” System.out.println(Thread.currentThread().getName()+\" start t1\"); t1.start(); // 主线程等待t1通过notify()唤醒。 System.out.println(Thread.currentThread().getName()+\" wait()\"); t1.wait(); System.out.println(Thread.currentThread().getName()+\" continue\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } main start t1 main wait() t1 call notify() main continue // 结果说明： 如下图，说明了“主线程”和“线程t1”的流程。 (01) 注意，图中\"主线程\" 代表“主线程main”。\"线程t1\" 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。 (02) “主线程”通过 new ThreadA(\"t1\") 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。 (03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。 (04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。 (05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。 jdk文档中关于wait的一段介绍： Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0). The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution. 引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。 “当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。 注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！ 这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！ wait(long timeout)和notify() wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 // WaitTimeoutTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { System.out.println(Thread.currentThread().getName() + \" run \"); // 死循环，不断运行。 while(true) ; } } public class WaitTimeoutTest { public static void main(String[] args) { ThreadA t1 = new ThreadA(\"t1\"); synchronized(t1) { try { // 启动“线程t1” System.out.println(Thread.currentThread().getName() + \" start t1\"); t1.start(); // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。 System.out.println(Thread.currentThread().getName() + \" call wait \"); t1.wait(3000); System.out.println(Thread.currentThread().getName() + \" continue\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } main start t1 main call wait t1 run // 大约3秒之后...输出“main continue” main continue // 结果说明： 如下图，说明了“主线程”和“线程t1”的流程。 (01) 注意，图中\"主线程\" 代表WaitTimeoutTest主线程(即，线程main)。\"线程t1\" 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。 (02) 主线程main执行t1.start()启动“线程t1”。 (03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。 (04) “线程t1”运行之后，进入了死循环，一直不断的运行。 (05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。 wait() 和 notifyAll() public class NotifyAllTest { private static Object obj = new Object(); public static void main(String[] args) { ThreadA t1 = new ThreadA(\"t1\"); ThreadA t2 = new ThreadA(\"t2\"); ThreadA t3 = new ThreadA(\"t3\"); t1.start(); t2.start(); t3.start(); try { System.out.println(Thread.currentThread().getName()+\" sleep(3000)\"); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized(obj) { // 主线程等待唤醒。 System.out.println(Thread.currentThread().getName()+\" notifyAll()\"); obj.notifyAll(); } } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run() { synchronized (obj) { try { // 打印输出结果 System.out.println(Thread.currentThread().getName() + \" wait\"); // 唤醒当前的wait线程 obj.wait(); // 打印输出结果 System.out.println(Thread.currentThread().getName() + \" continue\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } } t1 wait main sleep(3000) t3 wait t2 wait main notifyAll() t2 continue t3 continue t1 continue // 结果说明： 参考下面的流程图。 (01) 主线程中新建并且启动了3个线程\"t1\", \"t2\"和\"t3\"。 (02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设\"t1\", \"t2\"和\"t3\"这3个线程都运行了。以\"t1\"为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，\"t2\"和\"t3\"也会等待其它线程通过nofity()或nofityAll()来唤醒它们。 (03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒\"t1\", \"t2\"和\"t3\"这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，\"t1\", \"t2\"和\"t3\"就可以获取“obj锁”而继续运行了！ Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。 wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！ OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。 负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。 总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。 线程让步yield() yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！ // YieldTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public synchronized void run(){ for(int i=0; i yield() 与 wait()的比较 wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： (01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。 (02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。 // 下面通过示例演示yield()是不会释放锁的。 // YieldLockTest.java 的源码 public class YieldLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(\"t1\"); ThreadA t2 = new ThreadA(\"t2\"); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 synchronized (obj) { for(int i=0; i 线程休眠sleep() sleep() 定义在Thread.java中。 sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。 // SleepTest.java的源码 class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public synchronized void run() { try { for(int i=0; i sleep() 与 wait()的比较 wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 // SleepLockTest.java的源码 public class SleepLockTest{ private static Object obj = new Object(); public static void main(String[] args){ ThreadA t1 = new ThreadA(\"t1\"); ThreadA t2 = new ThreadA(\"t2\"); t1.start(); t2.start(); } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ // 获取obj对象的同步锁 synchronized (obj) { try { for(int i=0; i join() 方法 join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。 // 主线程 public class Father extends Thread { public void run() { Son s = new Son(); s.start(); s.join(); ... } } // 子线程 public class Son extends Thread { public void run() { ... } } // 说明： 上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。 在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！ // 问题： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让\"子线程等待才对(因为调用子线程对象s的wait方法嘛)\"？ 答案：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！ // JoinTest.java的源码 public class JoinTest{ public static void main(String[] args){ try { ThreadA t1 = new ThreadA(\"t1\"); // 新建“线程t1” t1.start(); // 启动“线程t1” t1.join(); // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成” System.out.printf(\"%s finish\\n\", Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } } static class ThreadA extends Thread{ public ThreadA(String name){ super(name); } public void run(){ System.out.printf(\"%s start\\n\", this.getName()); // 延时操作 for(int i=0; i interrupt()和线程终止方式 // 关于interrupt()，java的djk文档描述如下：http://docs.oracle.com/javase/7/docs/api/ Interrupts this thread. Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown. If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException. If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException. If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked. If none of the previous conditions hold then this thread's interrupt status will be set. Interrupting a thread that is not alive need not have any effect. interrupt()的作用是中断本线程。 本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。 如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。 如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。 如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。 中断一个“已终止的线程”不会产生任何操作。 终止线程的方式 Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！ 终止处于“阻塞状态”的线程 通常，我们通过“中断”方式终止处于“阻塞状态”的线程。 当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下： @Override public void run() { try { while (true) { // 执行任务... } } catch (InterruptedException ie) { // 由于产生InterruptedException异常，退出while(true)循环，线程终止！ } } 说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！ 注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。 终止处于“运行状态”的线程 通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。 // (01) 通过“中断标记”终止线程。 @Override public void run() { while (!isInterrupted()) { // 执行任务... } } 说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。 注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。 // (02) 通过“额外添加标记”。 private volatile boolean flag= true; protected void stopTask() { flag = false; } @Override public void run() { while (flag) { // 执行任务... } } 说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。 注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。 // 综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下： @Override public void run() { try { // 1. isInterrupted()保证，只要中断标记为true就终止线程。 while (!isInterrupted()) { // 执行任务... } } catch (InterruptedException ie) { // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 } } 终止线程的示例 // 终止线程的示例 // interrupt()常常被用来终止“阻塞状态”线程。 // Demo1.java的源码 class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { try { int i=0; while (!isInterrupted()) { Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+\" (\"+this.getState()+\") loop \" + i); } } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() +\" (\"+this.getState()+\") catch InterruptedException.\"); } } } public class Demo1 { public static void main(String[] args) { try { Thread t1 = new MyThread(\"t1\"); // 新建“线程t1” System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\"); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\"); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() +\" (\"+t1.getState()+\") is interrupted.\"); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +\" (\"+t1.getState()+\") is interrupted now.\"); } catch (InterruptedException e) { e.printStackTrace(); } } } // 结果说明： (01) 主线程main中通过new MyThread(\"t1\")创建线程t1，之后通过t1.start()启动线程t1。 (02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。 (03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。 t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) catch InterruptedException. t1 (TERMINATED) is interrupted now. // 通过“额外添加标记”的方式终止“状态状态”的线程的示例 // Demo3.java的源码 class MyThread extends Thread { private volatile boolean flag= true; public void stopTask() { flag = false; } public MyThread(String name) { super(name); } @Override public void run() { synchronized(this) { try { int i=0; while (flag) { Thread.sleep(100); // 休眠100ms i++; System.out.println(Thread.currentThread().getName()+\" (\"+this.getState()+\") loop \" + i); } } catch (InterruptedException ie) { System.out.println(Thread.currentThread().getName() +\" (\"+this.getState()+\") catch InterruptedException.\"); } } } } public class Demo3 { public static void main(String[] args) { try { MyThread t1 = new MyThread(\"t1\"); // 新建“线程t1” System.out.println(t1.getName() +\" (\"+t1.getState()+\") is new.\"); t1.start(); // 启动“线程t1” System.out.println(t1.getName() +\" (\"+t1.getState()+\") is started.\"); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.stopTask(); System.out.println(t1.getName() +\" (\"+t1.getState()+\") is interrupted.\"); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() +\" (\"+t1.getState()+\") is interrupted now.\"); } catch (InterruptedException e) { e.printStackTrace(); } } } t1 (NEW) is new. t1 (RUNNABLE) is started. t1 (RUNNABLE) loop 1 t1 (RUNNABLE) loop 2 t1 (TIMED_WAITING) is interrupted. t1 (RUNNABLE) loop 3 t1 (TERMINATED) is interrupted now. interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。 区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)； 而isInterrupted()仅仅返回中断标记。 线程优先级和守护线程 java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。 java 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。 用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。 JDK 中关于线程优先级和守护线程的介绍如下： Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon. When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs: The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place. All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads. 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。 当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行： (01) 调用了exit()方法，并且exit()有权限被正常执行。 (02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。 每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。 class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ for (int i=0; i // 守护线程的示例 // Demo.java class MyThread extends Thread{ public MyThread(String name) { super(name); } public void run(){ try { for (int i=0; i 生产消费者问题 生产/消费者问题是个非常典型的多线程问题，涉及到的对象包括“生产者”、“消费者”、“仓库”和“产品”。他们之间的关系如下： (01) 生产者仅仅在仓储未满时候生产，仓满则停止生产。 (02) 消费者仅仅在仓储有产品时候才能消费，仓空则等待。 (03) 当消费者发现仓储没产品可消费时候会通知生产者生产。 (04) 生产者在生产出可消费产品时候，应该通知等待的消费者去消费。 // 通过wait()/notify()方式实现该模型(后面在学习了线程池相关内容之后，再通过其它方式实现生产/消费者模型)。 // Demo1.java // 仓库 class Depot { private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 public Depot(int capacity) { this.capacity = capacity; this.size = 0; } public synchronized void produce(int val) { try { // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left > 0) { // 库存已满时，等待“消费者”消费产品。 while (size >= capacity) wait(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”>“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)>capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf(\"%s produce(%3d) --> left=%3d, inc=%3d, size=%3d\\n\", Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 notifyAll(); } } catch (InterruptedException e) { } } public synchronized void consume(int val) { try { // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left > 0) { // 库存为0时，等待“生产者”生产产品。 while (size left= 0, inc= 60, size= 60 Thread-4 produce(110) --> left= 70, inc= 40, size=100 Thread-2 consume( 90) left= 20, inc=100, size=100 Thread-3 consume(150) left= 0, inc= 70, size= 70 Thread-3 consume(150) left= 0, inc= 20, size= 50 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/多线程_锁.html":{"url":"chapters/多线程_锁.html","title":"多线程_锁","keywords":"","body":"锁概念锁的分类互斥锁和自旋锁读写锁读优先锁、写优先锁、公平读写锁乐观锁和悲观锁惊群问题惊群的几种情况 [TOC] 锁概念 锁的分类 如何理解互斥锁、条件锁、读写锁以及自旋锁？ 5000字 | 24张图带你彻底理解21种并发锁 互斥锁和自旋锁 互斥锁和自旋锁是最底层的两种锁，其他的很多锁都是基于他们的实现。 当线程A获取到锁后，线程B再去获取锁，有两种处理方式: 线程B循环的去尝试获取锁，直到获取成功为止即自旋锁 线程B放弃获取锁，在锁空闲时，等待被唤醒，即互斥锁 互斥锁 互斥锁会释放当前线程的cpu，导致加锁的代码阻塞，直到线程再次被唤醒。互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，存在一定的性能开销 while (抢锁(lock) == 没抢到) {睡眠直到锁状态改变再唤醒(lock)} 当线程加锁失败，内核会把线程的状态由“运行”设置为“睡眠”，让出cpu 当锁空闲时，内核唤醒线程，状态设置为“就绪”，获取cpu执行 自旋锁 自旋锁会自用户态由应用程序完成，不涉及用户态到内核态的转化，没有线程上下文切换，性能相对较好，自旋锁加锁过程: while (抢锁(lock) == 没抢到) {} 查看锁的状态 锁空闲，获取锁，否则执行(1) 自旋锁会利用cpu一直工作直到获取到锁，中间不会释放cpu，但如果被锁住的代码执行时间较长，导致cpu空转，浪费资源 读写锁 读写锁由读锁和写锁组成： 读锁又称为共享锁，S锁 写锁又称为排它锁、X锁，在mysql的事务中大量使用 写锁是独占锁，一旦线程获取写锁，其他线程不能获取写锁和读锁。 读锁是共享锁，当线程获取读锁，其他线程可以获取读锁不能获取写锁。因为并发数据读取并不会改变共享数据导致数据不一致。读写锁把对共享资源的读操作和写操作分别加锁控制，能够提高读线程的并发性，适用于读多写少的场景。 读优先锁、写优先锁、公平读写锁 读优先锁 读优先锁希望的是读锁能够被更多的线程获取，可以提高读线程的并发性。线程A获取了读锁，线程B想获取写锁，此时会被阻塞，线程c可以继续获取读锁，直到A和c释放锁，线程B才可以获取写锁。如果有很多线程获取读锁，且加锁的代码执行时间很长，就到导致线程B永远获取不到写锁。 写优先锁 写优先锁希望的是写锁能够被优先获取。线程A获取了读锁，线程B想获取写锁，此时会被阻塞，后面获取读锁都会失败，线程A释放锁，线程B可以获取写锁，其他获取读锁的线程阻塞。如果有很多写线程获取写锁，且加锁的代码执行时间很长，就到导致读线程永远获取不到读锁。 公平读写锁 上面两种锁都会造成【饥饿】现象，为解决这种问题，可以增加一个队列，把获取锁的线程（不管是写线程还是读线程）按照先进先出的方式排队，每次从队列中取出一个线程获取锁，这种获取锁的方式是公平的。 乐观锁和悲观锁 乐观锁 乐观锁是先修改共享资源，再用历史数据和当前数据比对验证这段时间共享数据有没有被修改，如果没有被修改，那么更新数据，如果有其他线程更新了共享资源，需要重新获取数据，再更新，验证，循环往复的重试，直到更新成功。所以当数据更新操作比较频繁，数据冲突的概率就会比较大，重试的次数就会多，浪费CPU资源。 乐观锁其实全程没有加锁，也叫无锁编程，所以针对读多写少的场景，并发性能较高，典型的实现MVCC，mysql中会使用MVCC构建一致性读来保证可重复读。 悲观锁 悲观锁是在访问共享资源之前统统加锁。当并发冲突概率较高时，乐观锁不再适用，悲观锁就派上用场。互斥锁、自旋锁都是悲观锁的实现。 惊群问题 [框架]高并发中的惊群效应 当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。 简单地说：就是扔一块食物，所有鸽子来抢，但最终只一个鸽子抢到了食物。 语义分析：食物只有一块，最终只有一个鸽子抢到，但是惊动了所有鸽子，每个鸽子都跑过来，消耗了每个鸽子的能量。（这个很符合达尔文的进化论，物种之间的竞争，适者生存。） 操作系统的惊群 在多进程/多线程等待同一资源时，也会出现惊群。即当某一资源可用时，多个进程/线程会惊醒，竞争资源。这就是操作系统中的惊群。 惊醒所有进程/线程，导致n-1个进程/线程做了无效的调度，上下文切换，cpu瞬时增高 多个进程/线程争抢资源，所以涉及到同步问题，需对资源进行加锁保护，加解锁加大系统CPU开销 惊群的几种情况 在高并发（多线程/多进程/多连接）中，会产生惊群的情况有： accept惊群 epoll惊群 nginx惊群 线程池惊群 线程池惊群 在多线程设计中，经常会用到互斥和条件变量的问题。当一个线程解锁并通知其他线程的时候，就会出现惊群的现象。 pthread_mutex_lock/pthread_mutex_unlock：线程互斥锁的加锁及解锁函数。 pthread_cond_wait：线程池中的消费者线程等待线程条件变量被通知； pthread_cond_signal/pthread_cond_broadcast：生产者线程通知线程池中的某个或一些消费者线程池，接收处理任务； 这里的惊群现象出现在3里，pthread_cond_signal，语义上看，是通知一个线程。调用此函数后，系统会唤醒在相同条件变量上等待的一个或多个线程（可参看手册）。如果通知了多个线程，则发生了惊群。 正常的用法： 所有线程共用一个锁，共用一个条件变量 当pthread_cond_signal通知时，就可能会出现惊群 解决惊群的方法： 所有线程共用一个锁，每个线程有自已的条件变量 pthread_cond_signal通知时，定向通知某个线程的条件变量，不会出现惊群 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/多线程_JUC原子类.html":{"url":"chapters/多线程_JUC原子类.html","title":"多线程_JUC原子类","keywords":"","body":"JUC原子类AtomicLong介绍和函数列表AtomicLongArray原子类AtomicReference介绍和函数列表AtomicLongFieldUpdater介绍和函数列表 [TOC] JUC原子类 根据修改的数据类型，可以将JUC包中的原子操作类可以分为4类。 基本类型: AtomicInteger, AtomicLong, AtomicBoolean ; 数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ; 引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ; 对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。 这些类存在的目的是对相应的数据进行原子操作。所谓原子操作，是指操作过程不会被中断，保证数据操作是以原子方式进行的。 AtomicLong介绍和函数列表 AtomicLong是作用是对长整形进行原子操作。 在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。 // AtomicLong函数列表 // 构造函数 AtomicLong() // 创建值为initialValue的AtomicLong对象 AtomicLong(long initialValue) // 以原子方式设置当前值为newValue。 final void set(long newValue) // 获取当前值 final long get() // 以原子方式将当前值减 1，并返回减1后的值。等价于“--num” final long decrementAndGet() // 以原子方式将当前值减 1，并返回减1前的值。等价于“num--” final long getAndDecrement() // 以原子方式将当前值加 1，并返回加1后的值。等价于“++num” final long incrementAndGet() // 以原子方式将当前值加 1，并返回加1前的值。等价于“num++” final long getAndIncrement() // 以原子方式将delta与当前值相加，并返回相加后的值。 final long addAndGet(long delta) // 以原子方式将delta添加到当前值，并返回相加前的值。 final long getAndAdd(long delta) // 如果当前值 == expect，则以原子方式将该值设置为update。成功返回true，否则返回false，并且不修改原值。 final boolean compareAndSet(long expect, long update) // 以原子方式设置当前值为newValue，并返回旧值。 final long getAndSet(long newValue) // 返回当前值对应的int值 int intValue() // 获取当前值对应的long值 long longValue() // 以 float 形式返回当前值 float floatValue() // 以 double 形式返回当前值 double doubleValue() // 最后设置为给定值。延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。 final void lazySet(long newValue) // 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。 final boolean weakCompareAndSet(long expect, long update) // 以incrementAndGet()为例，对AtomicLong的原理进行说明。 public final long incrementAndGet() { for (;;) { // 获取AtomicLong当前对应的long值 long current = get(); // 将current加1 long next = current + 1; // 通过CAS函数，更新current的值 if (compareAndSet(current, next)) return next; } } 说明： (01) incrementAndGet()首先会根据get()获取AtomicLong对应的long值。该值是volatile类型的变量，get()的源码如下： (02) incrementAndGet()接着将current加1,然后通过CAS函数，将新的值赋值给value。 // AtomicLong示例 // LongTest.java的源码 import java.util.concurrent.atomic.AtomicLong; public class LongTest { public static void main(String[] args){ // 新建AtomicLong对象 AtomicLong mAtoLong = new AtomicLong(); mAtoLong.set(0x0123456789ABCDEFL); System.out.printf(\"%20s : 0x%016X\\n\", \"get()\", mAtoLong.get()); System.out.printf(\"%20s : 0x%016X\\n\", \"intValue()\", mAtoLong.intValue()); System.out.printf(\"%20s : 0x%016X\\n\", \"longValue()\", mAtoLong.longValue()); System.out.printf(\"%20s : %s\\n\", \"doubleValue()\", mAtoLong.doubleValue()); System.out.printf(\"%20s : %s\\n\", \"floatValue()\", mAtoLong.floatValue()); System.out.printf(\"%20s : 0x%016X\\n\", \"getAndDecrement()\", mAtoLong.getAndDecrement()); System.out.printf(\"%20s : 0x%016X\\n\", \"decrementAndGet()\", mAtoLong.decrementAndGet()); System.out.printf(\"%20s : 0x%016X\\n\", \"getAndIncrement()\", mAtoLong.getAndIncrement()); System.out.printf(\"%20s : 0x%016X\\n\", \"incrementAndGet()\", mAtoLong.incrementAndGet()); System.out.printf(\"%20s : 0x%016X\\n\", \"addAndGet(0x10)\", mAtoLong.addAndGet(0x10)); System.out.printf(\"%20s : 0x%016X\\n\", \"getAndAdd(0x10)\", mAtoLong.getAndAdd(0x10)); System.out.printf(\"\\n%20s : 0x%016X\\n\", \"get()\", mAtoLong.get()); System.out.printf(\"%20s : %s\\n\", \"compareAndSet()\", mAtoLong.compareAndSet(0x12345679L, 0xFEDCBA9876543210L)); System.out.printf(\"%20s : 0x%016X\\n\", \"get()\", mAtoLong.get()); } } get() : 0x0123456789ABCDEF intValue() : 0x0000000089ABCDEF longValue() : 0x0123456789ABCDEF doubleValue() : 8.1985529216486896E16 floatValue() : 8.1985531E16 getAndDecrement() : 0x0123456789ABCDEF decrementAndGet() : 0x0123456789ABCDED getAndIncrement() : 0x0123456789ABCDED incrementAndGet() : 0x0123456789ABCDEF addAndGet(0x10) : 0x0123456789ABCDFF getAndAdd(0x10) : 0x0123456789ABCDFF get() : 0x0123456789ABCE0F compareAndSet() : false get() : 0x0123456789ABCE0F AtomicLongArray原子类 AtomicLongArray的作用则是对\"长整形数组\"进行原子操作。 // AtomicLongArray函数列表 // 创建给定长度的新 AtomicLongArray。 AtomicLongArray(int length) // 创建与给定数组具有相同长度的新 AtomicLongArray，并从给定数组复制其所有元素。 AtomicLongArray(long[] array) // 以原子方式将给定值添加到索引 i 的元素。 long addAndGet(int i, long delta) // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean compareAndSet(int i, long expect, long update) // 以原子方式将索引 i 的元素减1。 long decrementAndGet(int i) // 获取位置 i 的当前值。 long get(int i) // 以原子方式将给定值与索引 i 的元素相加。 long getAndAdd(int i, long delta) // 以原子方式将索引 i 的元素减 1。 long getAndDecrement(int i) // 以原子方式将索引 i 的元素加 1。 long getAndIncrement(int i) // 以原子方式将位置 i 的元素设置为给定值，并返回旧值。 long getAndSet(int i, long newValue) // 以原子方式将索引 i 的元素加1。 long incrementAndGet(int i) // 最终将位置 i 的元素设置为给定值。 void lazySet(int i, long newValue) // 返回该数组的长度。 int length() // 将位置 i 的元素设置为给定值。 void set(int i, long newValue) // 返回数组当前值的字符串表示形式。 String toString() // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean weakCompareAndSet(int i, long expect, long update) AtomicLongArray示例 // LongArrayTest.java的源码 import java.util.concurrent.atomic.AtomicLongArray; public class LongArrayTest { public static void main(String[] args){ // 新建AtomicLongArray对象 long[] arrLong = new long[] {10, 20, 30, 40, 50}; AtomicLongArray ala = new AtomicLongArray(arrLong); ala.set(0, 100); for (int i=0, len=ala.length(); i AtomicReference介绍和函数列表 AtomicReference是作用是对\"对象\"进行原子操作。 // AtomicReference函数列表 // 使用 null 初始值创建新的 AtomicReference。 AtomicReference() // 使用给定的初始值创建新的 AtomicReference。 AtomicReference(V initialValue) // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean compareAndSet(V expect, V update) // 获取当前值。 V get() // 以原子方式设置为给定值，并返回旧值。 V getAndSet(V newValue) // 最终设置为给定值。 void lazySet(V newValue) // 设置为给定值。 void set(V newValue) // 返回当前值的字符串表示形式。 String toString() // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 boolean weakCompareAndSet(V expect, V update) AtomicReference的源码比较简单。它是通过\"volatile\"和\"Unsafe提供的CAS函数实现\"原子操作。 (01) value是volatile类型。这保证了：当某线程修改value的值时，其他线程看到的value值都是最新的value值，即修改之后的volatile的值。 (02) 通过CAS设置value。这保证了：当某线程池通过CAS函数(如compareAndSet函数)设置value时，它的操作是原子的，即线程在操作value时不会被中断。 AtomicReference示例 // AtomicReferenceTest.java的源码 import java.util.concurrent.atomic.AtomicReference; public class AtomicReferenceTest { public static void main(String[] args){ // 创建两个Person对象，它们的id分别是101和102。 Person p1 = new Person(101); Person p2 = new Person(102); // 新建AtomicReference对象，初始化它的值为p1对象 AtomicReference ar = new AtomicReference(p1); // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。 ar.compareAndSet(p1, p2); Person p3 = (Person)ar.get(); System.out.println(\"p3 is \"+p3); System.out.println(\"p3.equals(p1)=\"+p3.equals(p1)); } } class Person { volatile long id; public Person(long id) { this.id = id; } public String toString() { return \"id:\"+id; } } // 结果说明： 新建AtomicReference对象ar时，将它初始化为p1。 紧接着，通过CAS函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。 最后，获取ar对应的对象，并打印结果。p3.equals(p1)的结果为false，这是因为Person并没有覆盖equals()方法，而是采用继承自Object.java的equals()方法；而Object.java中的equals()实际上是调用\"==\"去比较两个对象，即比较两个对象的地址是否相等。 p3 is id:102 p3.equals(p1)=false AtomicLongFieldUpdater介绍和函数列表 AtomicLongFieldUpdater可以对指定\"类的 'volatile long'类型的成员\"进行原子更新。它是基于反射原理实现的。 // AtomicLongFieldUpdater函数列表 // 受保护的无操作构造方法，供子类使用。 protected AtomicLongFieldUpdater() // 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。 long addAndGet(T obj, long delta) // 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。 abstract boolean compareAndSet(T obj, long expect, long update) // 以原子方式将此更新器管理的给定对象字段当前值减 1。 long decrementAndGet(T obj) // 获取此更新器管理的在给定对象的字段中保持的当前值。 abstract long get(T obj) // 以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值。 long getAndAdd(T obj, long delta) // 以原子方式将此更新器管理的给定对象字段当前值减 1。 long getAndDecrement(T obj) // 以原子方式将此更新器管理的给定对象字段的当前值加 1。 long getAndIncrement(T obj) // 将此更新器管理的给定对象的字段以原子方式设置为给定值，并返回旧值。 long getAndSet(T obj, long newValue) // 以原子方式将此更新器管理的给定对象字段当前值加 1。 long incrementAndGet(T obj) // 最后将此更新器管理的给定对象的字段设置为给定更新值。 abstract void lazySet(T obj, long newValue) // 为对象创建并返回一个具有给定字段的更新器。 static AtomicLongFieldUpdater newUpdater(Class tclass, String fieldName) // 将此更新器管理的给定对象的字段设置为给定更新值。 abstract void set(T obj, long newValue) // 如果当前值 == 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值。 abstract boolean weakCompareAndSet(T obj, long expect, long update) // AtomicLongFieldUpdater示例 // LongTest.java的源码 import java.util.concurrent.atomic.AtomicLongFieldUpdater; public class LongFieldTest { public static void main(String[] args) { // 获取Person的class对象 Class cls = Person.class; // 新建AtomicLongFieldUpdater对象，传递参数是“class对象”和“long类型在类中对应的名称” AtomicLongFieldUpdater mAtoLong = AtomicLongFieldUpdater.newUpdater(cls, \"id\"); Person person = new Person(12345678L); // 比较person的\"id\"属性，如果id的值为12345678L，则设置为1000。 mAtoLong.compareAndSet(person, 12345678L, 1000); System.out.println(\"id=\"+person.getId()); } } class Person { volatile long id; public Person(long id) { this.id = id; } public void setId(long id) { this.id = id; } public long getId() { return id; } } id=1000 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/多线程_JUC锁集合 .html":{"url":"chapters/多线程_JUC锁集合 .html","title":"多线程_JUC锁集合 ","keywords":"","body":"JUC锁集合互斥锁ReentrantLock公平锁获取公平锁tryAcquire()addWaiter(Node.EXCLUSIVE)acquireQueued()selfInterrupt()释放公平锁非公平锁获取非公平锁释放非公平锁Condition条件Condition示例LockSupportLockSupport示例共享锁和ReentrantReadWriteLock获取共享锁释放共享锁公平共享锁和非公平共享锁ReentrantReadWriteLock示例CountDownLatch原理和示例CountDownLatch的使用示例CyclicBarrier原理和示例CyclicBarrier的使用示例Semaphore信号量的原理和示例公平信号量获取和释放非公平信号量获取和释放Semaphore示例 [TOC] JUC锁集合 同步锁: 即通过synchronized关键字来进行同步，实现对竞争资源的互斥访问的锁。Java 1.0版本中就已经支持同步锁了。对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。这就是，多线程通过同步锁进行同步的原理！ JUC包中的锁 : 相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。 　　JUC包中的锁，包括：Lock接口，ReadWriteLock接口，LockSupport阻塞原语，Condition条件，AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer三个抽象类，ReentrantLock独占锁，ReentrantReadWriteLock读写锁。由于CountDownLatch，CyclicBarrier和Semaphore也是通过AQS来实现的； Lock接口: JUC包中的 Lock 接口支持那些语义不同(重入、公平等)的锁规则。所谓语义不同，是指锁可是有\"公平机制的锁\"、\"非公平机制的锁\"、\"可重入的锁\"等等。\"公平机制\"是指\"不同线程获取锁的机制是公平的\"，而\"非公平机制\"则是指\"不同线程获取锁的机制是非公平的\"，\"可重入的锁\"是指同一个锁能够被一个线程多次获取。 ReadWriteLock: ReadWriteLock 接口以和Lock类似的方式定义了一些读取者可以共享而写入者独占的锁。JUC包只有一个类实现了该接口，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。 AQS: AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer 　　AbstractQueuedSynchronizer就是被称之为AQS的类，它是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器；ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier和Semaphore等这些类都是基于AQS类实现的。AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。 LockSupport: LockSupport提供“创建锁”和“其他同步类的基本线程阻塞原语”。 　　LockSupport的功能和\"Thread中的Thread.suspend()和Thread.resume()有点类似\"，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 Condition: Condition需要和Lock联合使用，它的作用是代替Object监视器方法，可以通过await(),signal()来休眠/唤醒线程。 Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 ReentrantLock: ReentrantLock是独占锁。所谓独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。ReentrantLock锁包括\"公平的ReentrantLock\"和\"非公平的ReentrantLock\"。\"公平的ReentrantLock\"是指\"不同线程获取锁的机制是公平的\"，而\"非公平的　　ReentrantLock\"则是指\"不同线程获取锁的机制是非公平的\"，ReentrantLock是\"可重入的锁\"。 ReentrantReadWriteLock: ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括子类ReadLock和WriteLock。ReentrantLock是共享锁，而WriteLock是独占锁。 CountDownLatch: CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。CountDownLatch包含了sync对象，sync是Sync类型。CountDownLatch的Sync是实例类，它继承于AQS。 CyclicBarrier: CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 CyclicBarrier是包含了\"ReentrantLock对象lock\"和\"Condition对象trip\"，它是通过独占锁实现的。 CyclicBarrier和CountDownLatch的区别**是： (01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 (02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 Semaphore: Semaphore是一个计数信号量，它的本质是一个\"共享锁\"。 　信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。和\"ReentrantLock\"一样，Semaphore包含了sync对象，sync是Sync类型；而且，Sync也是一个继承于AQS的抽象类。Sync也包括\"公平信号量\"FairSync和\"非公平信号量\"NonfairSync。 互斥锁ReentrantLock ReentrantLock是一个可重入的互斥锁，又被称为“独占锁”。 顾名思义，ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。 ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。 // ReentrantLock函数列表 // 创建一个 ReentrantLock ，默认是“非公平锁”。 ReentrantLock() // 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。 ReentrantLock(boolean fair) // 查询当前线程保持此锁的次数。 int getHoldCount() // 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。 protected Thread getOwner() // 返回一个 collection，它包含可能正等待获取此锁的线程。 protected Collection getQueuedThreads() // 返回正等待获取此锁的线程估计数。 int getQueueLength() // 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。 protected Collection getWaitingThreads(Condition condition) // 返回等待与此锁相关的给定条件的线程估计数。 int getWaitQueueLength(Condition condition) // 查询给定线程是否正在等待获取此锁。 boolean hasQueuedThread(Thread thread) // 查询是否有些线程正在等待获取此锁。 boolean hasQueuedThreads() // 查询是否有些线程正在等待与此锁有关的给定条件。 boolean hasWaiters(Condition condition) // 如果是“公平锁”返回true，否则返回false。 boolean isFair() // 查询当前线程是否保持此锁。 boolean isHeldByCurrentThread() // 查询此锁是否由任意线程保持。 boolean isLocked() // 获取锁。 void lock() // 如果当前线程未被中断，则获取锁。 void lockInterruptibly() // 返回用来与此 Lock 实例一起使用的 Condition 实例。 Condition newCondition() // 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 boolean tryLock() // 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。 boolean tryLock(long timeout, TimeUnit unit) // 试图释放此锁。 void unlock() // ReentrantLock示例 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; // LockTest1.java // 仓库 class Depot { private int size; // 仓库的实际数量 private Lock lock; // 独占锁 public Depot() { this.size = 0; this.lock = new ReentrantLock(); } public void produce(int val) { lock.lock(); try { size += val; System.out.printf(\"%s produce(%d) --> size=%d\\n\", Thread.currentThread().getName(), val, size); } finally { lock.unlock(); } } public void consume(int val) { lock.lock(); try { size -= val; System.out.printf(\"%s consume(%d) size=60 Thread-1 produce(120) --> size=180 Thread-3 consume(150) size=50 结果分析： (01) Depot 是个仓库。通过produce()能往仓库中生产货物，通过consume()能消费仓库中的货物。通过独占锁lock实现对仓库的互斥访问：在操作(生产/消费)仓库中货品前，会先通过lock()锁住仓库，操作完之后再通过unlock()解锁。 (02) Producer是生产者类。调用Producer中的produce()函数可以新建一个线程往仓库中生产产品。 (03) Customer是消费者类。调用Customer中的consume()函数可以新建一个线程消费仓库中的产品。 (04) 在主线程main中，我们会新建1个生产者mPro，同时新建1个消费者mCus。它们分别向仓库中生产/消费产品。 根据main中的生产/消费数量，仓库最终剩余的产品应该是50。运行结果是符合我们预期的！ 这个模型存在两个问题： (01) 现实中，仓库的容量不可能为负数。但是，此模型中的仓库容量可以为负数，这与现实相矛盾！ (02) 现实中，仓库的容量是有限制的。但是，此模型中的容量确实没有限制的！ 这两个问题，我们稍微会讲到如何解决。现在，先看个简单的示例2；通过对比“示例1”和“示例2”,我们能更清晰的认识lock(),unlock()的用途。 // 在“示例2”中，我们通过Condition去解决“示例1”中的两个问题： // “仓库的容量不可能为负数” // “仓库的容量是有限制的”。 // 解决该问题是通过Condition。Condition是需要和Lock联合使用的：通过Condition中的await()方法，能让线程阻塞[类似于wait()]；通过Condition的signal()方法，能让唤醒线程[类似于notify()]。 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.Condition; // LockTest3.java // 仓库 class Depot { private int capacity; // 仓库的容量 private int size; // 仓库的实际数量 private Lock lock; // 独占锁 private Condition fullCondtion; // 生产条件 private Condition emptyCondtion; // 消费条件 public Depot(int capacity) { this.capacity = capacity; this.size = 0; this.lock = new ReentrantLock(); this.fullCondtion = lock.newCondition(); this.emptyCondtion = lock.newCondition(); } public void produce(int val) { lock.lock(); try { // left 表示“想要生产的数量”(有可能生产量太多，需多此生产) int left = val; while (left > 0) { // 库存已满时，等待“消费者”消费产品。 while (size >= capacity) fullCondtion.await(); // 获取“实际生产的数量”(即库存中新增的数量) // 如果“库存”+“想要生产的数量”>“总的容量”，则“实际增量”=“总的容量”-“当前容量”。(此时填满仓库) // 否则“实际增量”=“想要生产的数量” int inc = (size+left)>capacity ? (capacity-size) : left; size += inc; left -= inc; System.out.printf(\"%s produce(%3d) --> left=%3d, inc=%3d, size=%3d\\n\", Thread.currentThread().getName(), val, left, inc, size); // 通知“消费者”可以消费了。 emptyCondtion.signal(); } } catch (InterruptedException e) { } finally { lock.unlock(); } } public void consume(int val) { lock.lock(); try { // left 表示“客户要消费数量”(有可能消费量太大，库存不够，需多此消费) int left = val; while (left > 0) { // 库存为0时，等待“生产者”生产产品。 while (size left= 0, inc= 60, size= 60 Thread-1 produce(120) --> left= 80, inc= 40, size=100 Thread-2 consume( 90) left= 10, inc=100, size=100 Thread-3 consume(150) left= 0, inc= 10, size= 10 Thread-3 consume(150) left= 0, inc= 80, size= 80 Thread-3 consume(150) 公平锁 基本概念: AQS -- 指AbstractQueuedSynchronizer类。 AQS是java中管理“锁”的抽象类，锁的许多公共方法都是在这个类中实现。AQS是独占锁(例如，ReentrantLock)和共享锁(例如，Semaphore)的公共父类。 AQS锁的类别 -- 分为“独占锁”和“共享锁”两种。 (01) 独占锁 -- 锁在一个时间点只能被一个线程锁占有。根据锁的获取机制，它又划分为“公平锁”和“非公平锁”。公平锁，是按照通过CLH等待线程按照先来先得的规则，公平的获取锁；而非公平锁，则当线程要获取锁时，它会无视CLH等待队列而直接获取锁。独占锁的典型实例子是ReentrantLock，此外，ReentrantReadWriteLock.WriteLock也是独占锁。 (02) 共享锁 -- 能被多个线程同时拥有，能被共享的锁。JUC包中的ReentrantReadWriteLock.ReadLock，CyclicBarrier， CountDownLatch和Semaphore都是共享锁。这些锁的用途和原理，在以后的章节再详细介绍。 CLH队列 -- Craig, Landin, and Hagersten lock queue CLH队列是AQS中“等待锁”的线程队列。在多线程中，为了保护竞争资源不被多个线程同时操作而起来错误，我们常常需要通过锁来保护这些资源。在独占锁中，竞争资源在一个时间点只能被一个线程锁访问；而其它线程则需要等待。CLH就是管理这些“等待锁”的线程的队列。 CLH是一个非阻塞的 FIFO 队列。也就是说往里面插入或移除一个节点的时候，在并发条件下不会阻塞，而是通过自旋锁和 CAS 保证节点插入和移除的原子性。 CAS函数 -- Compare And Swap CAS函数，是比较并交换函数，它是原子操作函数；即，通过CAS操作的数据都是以原子方式进行的。例如，compareAndSetHead(), compareAndSetTail(), compareAndSetNext()等函数。它们共同的特点是，这些函数所执行的动作是以原子的方式进行的。 获取公平锁 1. lock() lock()在ReentrantLock.java的FairSync类中实现 说明：“当前线程”实际上是通过acquire(1)获取锁的。 这里说明一下“1”的含义，它是设置“锁的状态”的参数。对于“独占锁”而言，锁处于可获取状态时，它的状态值是0；锁被线程初次获取到了，它的状态值就变成了1。 由于ReentrantLock(公平锁/非公平锁)是可重入锁，所以“独占锁”可以被单个线程多此获取，每获取1次就将锁的状态+1。也就是说，初次获取锁时，通过acquire(1)将锁的状态值设为1；再次获取锁时，将锁的状态值设为2；依次类推...这就是为什么获取锁时，传入的参数是1的原因了。 可重入就是指锁可以被单个线程多次获取。 2. acquire() acquire()在AQS中实现的 (01) “当前线程”首先通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列排序等待(前面还有可能有需要线程在等待该锁)。 (02) “当前线程”尝试失败的情况下，先通过addWaiter(Node.EXCLUSIVE)来将“当前线程”加入到\"CLH队列(非阻塞的FIFO队列)\"末尾。CLH队列就是线程等待队列。 (03) 再执行完addWaiter(Node.EXCLUSIVE)之后，会调用acquireQueued()来获取锁。由于此时ReentrantLock是公平锁，它会根据公平性原则来获取锁。 (04) “当前线程”在执行acquireQueued()时，会进入到CLH队列中休眠等待，直到获取锁了才返回！如果“当前线程”在休眠等待过程中被中断过，acquireQueued会返回true，此时\"当前线程\"会调用selfInterrupt()来自己给自己产生一个中断。 tryAcquire() 1. tryAcquire() 说明：根据代码，我们可以分析出，tryAcquire()的作用就是尝试去获取锁。注意，这里只是尝试！ 尝试成功的话，返回true；尝试失败的话，返回false，后续再通过其它办法来获取该锁。后面我们会说明，在尝试失败的情况下，是如何一步步获取锁的。 2. hasQueuedPredecessors() 说明：通过代码，能分析出，hasQueuedPredecessors() 是通过判断\"当前线程\"是不是在CLH队列的队首，来返回AQS中是不是有比“当前线程”等待更久的线程。下面对head、tail和Node进行说明。 3. Node的源码 说明：Node是CLH队列的节点，代表“等待锁的线程队列”。 (01) 每个Node都会一个线程对应。 (02) 每个Node会通过prev和next分别指向上一个节点和下一个节点，这分别代表上一个等待线程和下一个等待线程。 (03) Node通过waitStatus保存线程的等待状态。 (04) Node通过nextWaiter来区分线程是“独占锁”线程还是“共享锁”线程。如果是“独占锁”线程，则nextWaiter的值为EXCLUSIVE；如果是“共享锁”线程，则nextWaiter的值是SHARED。 4. compareAndSetState() 说明： compareAndSwapInt() 是sun.misc.Unsafe类中的一个本地方法。对此，我们需要了解的是 compareAndSetState(expect, update) 是以原子的方式操作当前线程；若当前线程的状态为expect，则设置它的状态为update。 5. setExclusiveOwnerThread() 说明：setExclusiveOwnerThread()的作用就是，设置线程t为当前拥有“独占锁”的线程 6. getState(), setState() 说明：state表示锁的状态，对于“独占锁”而已，state=0表示锁是可获取状态(即，锁没有被任何线程锁持有)。由于java中的独占锁是可重入的，state的值可以>1。 addWaiter(Node.EXCLUSIVE) addWaiter(Node.EXCLUSIVE)的作用是，创建“当前线程”的Node节点，且Node中记录“当前线程”对应的锁是“独占锁”类型，并且将该节点添加到CLH队列的末尾。 1.addWaiter() 说明：对于“公平锁”而言，addWaiter(Node.EXCLUSIVE)会首先创建一个Node节点，节点的类型是“独占锁”(Node.EXCLUSIVE)类型。然后，再将该节点添加到CLH队列的末尾。 2. compareAndSetTail() 说明：compareAndSetTail也属于CAS函数，也是通过“本地方法”实现的。compareAndSetTail(expect, update)会以原子的方式进行操作，它的作用是判断CLH队列的队尾是不是为expect，是的话，就将队尾设为update。 3. enq() 说明： enq()的作用很简单。如果CLH队列为空，则新建一个CLH表头；然后将node添加到CLH末尾。否则，直接将node添加到CLH末尾。 小结：addWaiter()的作用，就是将当前线程添加到CLH队列中。这就意味着将当前线程添加到等待获取“锁”的等待线程队列中了。 acquireQueued() acquireQueued()的作用就是逐步的去执行CLH队列的线程，如果当前线程获取到了锁，则返回；否则，当前线程进行休眠，直到唤醒并重新获取锁了才返回。 1. acquireQueued() 说明：acquireQueued()的目的是从队列中获取锁。 2. shouldParkAfterFailedAcquire() 说明： (01) 关于waitStatus请参考下表(中扩号内为waitStatus的值)，更多关于waitStatus的内容，可以参考前面的Node类的介绍。 CANCELLED[1] -- 当前线程已被取消 SIGNAL[-1] -- “当前线程的后继线程需要被unpark(唤醒)”。一般发生情况是：当前线程的后继线程处于阻塞状态，而当前线程被release或cancel掉，因此需要唤醒当前线程的后继线程。 CONDITION[-2] -- 当前线程(处在Condition休眠状态)在等待Condition唤醒 PROPAGATE[-3] -- (共享锁)其它线程获取到“共享锁” [0] -- 当前线程不属于上面的任何一种状态。 (02) shouldParkAfterFailedAcquire()通过以下规则，判断“当前线程”是否需要被阻塞。 规则1：如果前继节点状态为SIGNAL，表明当前节点需要被unpark(唤醒)，此时则返回true。 规则2：如果前继节点状态为CANCELLED(ws>0)，说明前继节点已经被取消，则通过先前回溯找到一个有效(非CANCELLED状态)的节点，并返回false。 规则3：如果前继节点状态为非SIGNAL、非CANCELLED，则设置前继的状态为SIGNAL，并返回false。 如果“规则1”发生，即“前继节点是SIGNAL”状态，则意味着“当前线程”需要被阻塞。接下来会调用parkAndCheckInterrupt()阻塞当前线程，直到当前先被唤醒才从parkAndCheckInterrupt()中返回。 3. parkAndCheckInterrupt()) 说明：parkAndCheckInterrupt()的作用是阻塞当前线程，并且返回“线程被唤醒之后”的中断状态。 它会先通过LockSupport.park()阻塞“当前线程”，然后通过Thread.interrupted()返回线程的中断状态。 这里介绍一下线程被阻塞之后如何唤醒。一般有2种情况： 第1种情况：unpark()唤醒。“前继节点对应的线程”使用完锁之后，通过unpark()方式唤醒当前线程。 第2种情况：中断唤醒。其它线程通过interrupt()中断当前线程。 补充：LockSupport()中的park(),unpark()的作用 和 Object中的wait(),notify()作用类似，是阻塞/唤醒。 它们的用法不同，park(),unpark()是轻量级的，而wait(),notify()是必须先通过Synchronized获取同步锁。 4. 再次tryAcquire() 说明： (01) 通过node.predecessor()获取前继节点。predecessor()就是返回node的前继节点，若对此有疑惑可以查看下面关于Node类的介绍。 (02) p == head && tryAcquire(arg) 首先，判断“前继节点”是不是CHL表头。如果是的话，则通过tryAcquire()尝试获取锁。 其实，这样做的目的是为了“让当前线程获取锁”，但是为什么需要先判断p==head呢？理解这个对理解“公平锁”的机制很重要，因为这么做的原因就是为了保证公平性！ (a) 前面，我们在shouldParkAfterFailedAcquire()我们判断“当前线程”是否需要阻塞； (b) 接着，“当前线程”阻塞的话，会调用parkAndCheckInterrupt()来阻塞线程。当线程被解除阻塞的时候，我们会返回线程的中断状态。而线程被解决阻塞，可能是由于“线程被中断”，也可能是由于“其它线程调用了该线程的unpark()函数”。 (c) 再回到p==head这里。如果当前线程是因为其它线程调用了unpark()函数而被唤醒，那么唤醒它的线程，应该是它的前继节点所对应的线程(关于这一点，后面在“释放锁”的过程中会看到)。 OK，是前继节点调用unpark()唤醒了当前线程！ 此时，再来理解p==head就很简单了：当前继节点是CLH队列的头节点，并且它释放锁之后；就轮到当前节点获取锁了。然后，当前节点通过tryAcquire()获取锁；获取成功的话，通过setHead(node)设置当前节点为头节点，并返回。 总之，如果“前继节点调用unpark()唤醒了当前线程”并且“前继节点是CLH表头”，此时就是满足p==head，也就是符合公平性原则的。否则，如果当前线程是因为“线程被中断”而唤醒，那么显然就不是公平了。这就是为什么说p==head就是保证公平性！ 小结：acquireQueued()的作用就是“当前线程”会根据公平性原则进行阻塞等待，直到获取锁为止；并且返回当前线程在等待过程中有没有并中断过。 selfInterrupt() private static void selfInterrupt() { Thread.currentThread().interrupt(); } 说明：selfInterrupt()的代码很简单，就是“当前线程”自己产生一个中断。但是，为什么需要这么做呢？ 这必须结合acquireQueued()进行分析。如果在acquireQueued()中，当前线程被中断过，则执行selfInterrupt()；否则不会执行。 在acquireQueued()中，即使是线程在阻塞状态被中断唤醒而获取到cpu执行权利；但是，如果该线程的前面还有其它等待锁的线程，根据公平性原则，该线程依然无法获取到锁。它会再次阻塞！ 该线程再次阻塞，直到该线程被它的前面等待锁的线程锁唤醒；线程才会获取锁，然后“真正执行起来”！ 也就是说，在该线程“成功获取锁并真正执行起来”之前，它的中断会被忽略并且中断标记会被清除！ 因为在parkAndCheckInterrupt()中，我们线程的中断状态时调用了Thread.interrupted()。该函数不同于Thread的isInterrupted()函数，isInterrupted()仅仅返回中断状态，而interrupted()在返回当前中断状态之后，还会清除中断状态。 正因为之前的中断状态被清除了，所以这里需要调用selfInterrupt()重新产生一个中断！ 小结：selfInterrupt()的作用就是当前线程自己产生一个中断。 总结: 再回过头看看acquire()函数，它最终的目的是获取锁！ public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } (01) 先是通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，再通过acquireQueued()获取锁。 (02) 尝试失败的情况下，会先通过addWaiter()来将“当前线程”加入到\"CLH队列\"末尾；然后调用acquireQueued()，在CLH队列中排序等待获取锁，在此过程中，线程处于休眠状态。直到获取锁了才返回。 如果在休眠等待过程中被中断过，则调用selfInterrupt()来自己产生一个中断。 释放公平锁 1. unlock() 说明：unlock()是解锁函数，它是通过AQS的release()函数来实现的。 在这里，“1”的含义和“获取锁的函数acquire(1)的含义”一样，它是设置“释放锁的状态”的参数。由于“公平锁”是可重入的，所以对于同一个线程，每释放锁一次，锁的状态-1。 2. release() 说明：release()会先调用tryRelease()来尝试释放当前线程锁持有的锁。成功的话，则唤醒后继等待线程，并返回true。否则，直接返回false。 3. tryRelease() 说明：tryRelease()的作用是尝试释放锁。 (01) 如果“当前线程”不是“锁的持有者”，则抛出异常。 (02) 如果“当前线程”在本次释放锁操作之后，对锁的拥有状态是0(即，当前线程彻底释放该“锁”)，则设置“锁”的持有者为null，即锁是可获取状态。同时，更新当前线程的锁的状态为0。 4. unparkSuccessor() 在release()中“当前线程”释放锁成功的话，会唤醒当前线程的后继线程。 根据CLH队列的FIFO规则，“当前线程”(即已经获取锁的线程)肯定是head；如果CLH队列非空的话，则唤醒锁的下一个等待线程。 说明：unparkSuccessor()的作用是“唤醒当前线程的后继线程”。后继线程被唤醒之后，就可以获取该锁并恢复运行了。 关 总结: “释放锁”的过程相对“获取锁”的过程比较简单。释放锁时，主要进行的操作，是更新当前线程对应的锁的状态。如果当前线程对锁已经彻底释放，则设置“锁”的持有线程为null，设置当前线程的状态为空，然后唤醒后继线程。 非公平锁 获取非公平锁 非公平锁和公平锁在获取锁的方法上，流程是一样的；它们的区别主要表现在“尝试获取锁的机制不同”。简单点说，“公平锁”在每次尝试获取锁时，都是采用公平策略(根据等待队列依次排序等待)；而“非公平锁”在每次尝试获取锁时，都是采用的非公平策略(无视等待队列，直接尝试获取锁，如果锁是空闲的，即可获取状态，则获取锁)。 1. lock() 说明：lock()会先通过compareAndSet(0, 1)来判断“锁”是不是空闲状态。是的话，“当前线程”直接获取“锁”；否则的话，调用acquire(1)获取锁。 (01) compareAndSetState()是CAS函数，它的作用是比较并设置当前锁的状态。若锁的状态值为0，则设置锁的状态值为1。 (02) setExclusiveOwnerThread(Thread.currentThread())的作用是，设置“当前线程”为“锁”的持有者。 “公平锁”和“非公平锁”关于lock()的对比 公平锁 -- 公平锁的lock()函数，会直接调用acquire(1)。 非公平锁 -- 非公平锁会先判断当前锁的状态是不是空闲，是的话，就不排队，而是直接获取锁。 2. acquire() (01) “当前线程”首先通过tryAcquire()尝试获取锁。获取成功的话，直接返回；尝试失败的话，进入到等待队列依次排序，然后获取锁。 (02) “当前线程”尝试失败的情况下，会先通过addWaiter(Node.EXCLUSIVE)来将“当前线程”加入到\"CLH队列(非阻塞的FIFO队列)\"末尾。 (03) 然后，调用acquireQueued()获取锁。在acquireQueued()中，当前线程会等待它在“CLH队列”中前面的所有线程执行并释放锁之后，才能获取锁并返回。如果“当前线程”在休眠等待过程中被中断过，则调用selfInterrupt()来自己产生一个中断。 “公平锁”和“非公平锁”关于acquire()的对比 公平锁和非公平锁，只有tryAcquire()函数的实现不同；即它们尝试获取锁的机制不同。这就是我们所说的“它们获取锁策略的不同所在之处”！ 在“Java多线程系列--“JUC锁”03之 公平锁(一)”中，已经详细介绍了acquire()涉及到的各个函数。这里仅对它们有差异的函数tryAcquire()进行说明。 说明： 根据代码，我们可以分析出，tryAcquire()的作用就是尝试去获取锁。 (01) 如果“锁”没有被任何线程拥有，则通过CAS函数设置“锁”的状态为acquires，同时，设置“当前线程”为锁的持有者，然后返回true。 (02) 如果“锁”的持有者已经是当前线程，则将更新锁的状态即可。 (03) 如果不术语上面的两种情况，则认为尝试失败。 “公平锁”和“非公平锁”关于tryAcquire()的对比 公平锁和非公平锁，它们尝试获取锁的方式不同。 公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。 而非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。 释放非公平锁 非公平锁和公平锁在释放锁的方法和策略上是一样的。 Condition条件 Condition的作用是对锁进行更精确的控制。Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。不同的是，Object中的wait(),notify(),notifyAll()方法是和\"同步锁\"(synchronized关键字)捆绑使用的；而Condition是需要与\"互斥锁\"/\"共享锁\"捆绑使用的。 // Condition函数列表 // 造成当前线程在接到信号或被中断之前一直处于等待状态。 void await() // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。 boolean await(long time, TimeUnit unit) // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。 long awaitNanos(long nanosTimeout) // 造成当前线程在接到信号之前一直处于等待状态。 void awaitUninterruptibly() // 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。 boolean awaitUntil(Date deadline) // 唤醒一个等待线程。 void signal() // 唤醒所有等待线程。 void signalAll() Condition示例 // 示例1是通过Object的wait(), notify()来演示线程的休眠/唤醒功能。 public class WaitTest1 { public static void main(String[] args) { ThreadA ta = new ThreadA(\"ta\"); synchronized(ta) { // 通过synchronized(ta)获取“对象ta的同步锁” try { System.out.println(Thread.currentThread().getName()+\" start ta\"); ta.start(); System.out.println(Thread.currentThread().getName()+\" block\"); ta.wait(); // 等待 System.out.println(Thread.currentThread().getName()+\" continue\"); } catch (InterruptedException e) { e.printStackTrace(); } } } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+\" wakup others\"); notify(); // 唤醒“当前对象上的等待线程” } } } } // 示例2是通过Condition的await(), signal()来演示线程的休眠/唤醒功能。 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class ConditionTest1 { private static Lock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); public static void main(String[] args) { ThreadA ta = new ThreadA(\"ta\"); lock.lock(); // 获取锁 try { System.out.println(Thread.currentThread().getName()+\" start ta\"); ta.start(); System.out.println(Thread.currentThread().getName()+\" block\"); condition.await(); // 等待 System.out.println(Thread.currentThread().getName()+\" continue\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); // 释放锁 } } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { lock.lock(); // 获取锁 try { System.out.println(Thread.currentThread().getName()+\" wakup others\"); condition.signal(); // 唤醒“condition所在锁上的其它线程” } finally { lock.unlock(); // 释放锁 } } } } 运行结果： main start ta main block ta wakup others main continue 通过“示例1”和“示例2”，我们知道Condition和Object的方法有一下对应关系： Object Condition 休眠 wait await 唤醒个线程 notify signal 唤醒所有线程 notifyAll signalAll Condition除了支持上面的功能之外，它更强大的地方在于：能够更加精细的控制多线程的休眠与唤醒。对于同一个锁，我们可以创建多个Condition，在不同的情况下使用不同的Condition。 例如，假如多线程读/写同一个缓冲区：当向缓冲区中写入数据之后，唤醒\"读线程\"；当从缓冲区读出数据之后，唤醒\"写线程\"；并且当缓冲区满的时候，\"写线程\"需要等待；当缓冲区为空时，\"读线程\"需要等待。 如果采用Object类中的wait(), notify(), notifyAll()实现该缓冲区，当向缓冲区写入数据之后需要唤醒\"读线程\"时，不可能通过notify()或notifyAll()明确的指定唤醒\"读线程\"，而只能通过notifyAll唤醒所有线程(但是notifyAll无法区分唤醒的线程是读线程，还是写线程)。 但是，通过Condition，就能明确的指定唤醒读线程。 看看下面的示例3，可能对这个概念有更深刻的理解。 // 示例3是通过Condition的高级功能。 import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[5]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); //获取锁 try { // 如果“缓冲已满”，则等待；直到“缓冲”不是满的，才将x添加到缓冲中。 while (count == items.length) notFull.await(); // 将x添加到缓冲中 items[putptr] = x; // 将“put统计数putptr+1”；如果“缓冲已满”，则设putptr为0。 if (++putptr == items.length) putptr = 0; // 将“缓冲”数量+1 ++count; // 唤醒take线程，因为take线程通过notEmpty.await()等待 notEmpty.signal(); // 打印写入的数据 System.out.println(Thread.currentThread().getName() + \" put \"+ (Integer)x); } finally { lock.unlock(); // 释放锁 } } public Object take() throws InterruptedException { lock.lock(); //获取锁 try { // 如果“缓冲为空”，则等待；直到“缓冲”不为空，才将x从缓冲中取出。 while (count == 0) notEmpty.await(); // 将x从缓冲中取出 Object x = items[takeptr]; // 将“take统计数takeptr+1”；如果“缓冲为空”，则设takeptr为0。 if (++takeptr == items.length) takeptr = 0; // 将“缓冲”数量-1 --count; // 唤醒put线程，因为put线程通过notFull.await()等待 notFull.signal(); // 打印取出的数据 System.out.println(Thread.currentThread().getName() + \" take \"+ (Integer)x); return x; } finally { lock.unlock(); // 释放锁 } } } public class ConditionTest2 { private static BoundedBuffer bb = new BoundedBuffer(); public static void main(String[] args) { // 启动10个“写线程”，向BoundedBuffer中不断的写数据(写入0-9)； // 启动10个“读线程”，从BoundedBuffer中不断的读数据。 for (int i=0; i LockSupport LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。 LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 因为park() 和 unpark()有许可的存在；调用 park() 的线程和另一个试图将其 unpark() 的线程之间的竞争将保持活性。 // LockSupport函数列表 // 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。 static Object getBlocker(Thread t) // 为了线程调度，禁用当前线程，除非许可可用。 static void park() // 为了线程调度，在许可可用之前禁用当前线程。 static void park(Object blocker) // 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。 static void parkNanos(long nanos) // 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。 static void parkNanos(Object blocker, long nanos) // 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。 static void parkUntil(long deadline) // 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。 static void parkUntil(Object blocker, long deadline) // 如果给定线程的许可尚不可用，则使其可用。 static void unpark(Thread thread) LockSupport示例 public class WaitTest1 { public static void main(String[] args) { ThreadA ta = new ThreadA(\"ta\"); synchronized(ta) { // 通过synchronized(ta)获取“对象ta的同步锁” try { System.out.println(Thread.currentThread().getName()+\" start ta\"); ta.start(); System.out.println(Thread.currentThread().getName()+\" block\"); // 主线程等待 ta.wait(); System.out.println(Thread.currentThread().getName()+\" continue\"); } catch (InterruptedException e) { e.printStackTrace(); } } } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { synchronized (this) { // 通过synchronized(this)获取“当前对象的同步锁” System.out.println(Thread.currentThread().getName()+\" wakup others\"); notify(); // 唤醒“当前对象上的等待线程” } } } } import java.util.concurrent.locks.LockSupport; public class LockSupportTest1 { private static Thread mainThread; public static void main(String[] args) { ThreadA ta = new ThreadA(\"ta\"); // 获取主线程 mainThread = Thread.currentThread(); System.out.println(Thread.currentThread().getName()+\" start ta\"); ta.start(); System.out.println(Thread.currentThread().getName()+\" block\"); // 主线程阻塞 LockSupport.park(mainThread); System.out.println(Thread.currentThread().getName()+\" continue\"); } static class ThreadA extends Thread{ public ThreadA(String name) { super(name); } public void run() { System.out.println(Thread.currentThread().getName()+\" wakup others\"); // 唤醒“主线程” LockSupport.unpark(mainThread); } } } 运行结果： main start ta main block ta wakup others main continue 说明：park和wait的区别。wait让线程阻塞前，必须通过synchronized获取同步锁。 共享锁和ReentrantReadWriteLock ReadWriteLock，顾名思义，是读写锁。它维护了一对相关的锁 — — “读取锁”和“写入锁”，一个用于读取操作，另一个用于写入操作。 “读取锁”用于只读操作，它是“共享锁”，能同时被多个线程获取。 “写入锁”用于写入操作，它是“独占锁”，写入锁只能被一个线程锁获取。 注意：不能同时存在读取锁和写入锁！ ReadWriteLock是一个接口。ReentrantReadWriteLock是它的实现类，ReentrantReadWriteLock包括子类ReadLock和WriteLock。 // ReadWriteLock函数列表 // 返回用于读取操作的锁。 Lock readLock() // 返回用于写入操作的锁。 Lock writeLock() // ReentrantReadWriteLock函数列表 // 创建一个新的 ReentrantReadWriteLock，默认是采用“非公平策略”。 ReentrantReadWriteLock() // 创建一个新的 ReentrantReadWriteLock，fair是“公平策略”。fair为true，意味着公平策略；否则，意味着非公平策略。 ReentrantReadWriteLock(boolean fair) // 返回当前拥有写入锁的线程，如果没有这样的线程，则返回 null。 protected Thread getOwner() // 返回一个 collection，它包含可能正在等待获取读取锁的线程。 protected Collection getQueuedReaderThreads() // 返回一个 collection，它包含可能正在等待获取读取或写入锁的线程。 protected Collection getQueuedThreads() // 返回一个 collection，它包含可能正在等待获取写入锁的线程。 protected Collection getQueuedWriterThreads() // 返回等待获取读取或写入锁的线程估计数目。 int getQueueLength() // 查询当前线程在此锁上保持的重入读取锁数量。 int getReadHoldCount() // 查询为此锁保持的读取锁数量。 int getReadLockCount() // 返回一个 collection，它包含可能正在等待与写入锁相关的给定条件的那些线程。 protected Collection getWaitingThreads(Condition condition) // 返回正等待与写入锁相关的给定条件的线程估计数目。 int getWaitQueueLength(Condition condition) // 查询当前线程在此锁上保持的重入写入锁数量。 int getWriteHoldCount() // 查询是否给定线程正在等待获取读取或写入锁。 boolean hasQueuedThread(Thread thread) // 查询是否所有的线程正在等待获取读取或写入锁。 boolean hasQueuedThreads() // 查询是否有些线程正在等待与写入锁有关的给定条件。 boolean hasWaiters(Condition condition) // 如果此锁将公平性设置为 ture，则返回 true。 boolean isFair() // 查询是否某个线程保持了写入锁。 boolean isWriteLocked() // 查询当前线程是否保持了写入锁。 boolean isWriteLockedByCurrentThread() // 返回用于读取操作的锁。 ReentrantReadWriteLock.ReadLock readLock() // 返回用于写入操作的锁。 ReentrantReadWriteLock.WriteLock writeLock() 获取共享锁 获取共享锁的思想(即lock函数的步骤)，是先通过tryAcquireShared()尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过doAcquireShared()不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared()在循环中每次尝试获取锁时，都是通过tryAcquireShared()来进行尝试的。 1. lock() 2. acquireShared() 说明：acquireShared()首先会通过tryAcquireShared()来尝试获取锁。 尝试成功的话，则不再做任何动作(因为已经成功获取到锁了)。 尝试失败的话，则通过doAcquireShared()来获取锁。doAcquireShared()会获取到锁了才返回。 3. tryAcquireShared() 说明：tryAcquireShared()的作用是尝试获取“共享锁”。 如果在尝试获取锁时，“不需要阻塞等待”并且“读取锁的共享计数小于MAX_COUNT”，则直接通过CAS函数更新“读取锁的共享计数”，以及将“当前线程获取读取锁的次数+1”。 否则，通过fullTryAcquireShared()获取读取锁。 4. fullTryAcquireShared() 说明：fullTryAcquireShared()会根据“是否需要阻塞等待”，“读取锁的共享计数是否超过限制”等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过CAS尝试获取锁，并返回1。 5. doAcquireShared() 说明：doAcquireShared()的作用是获取共享锁。 它会首先创建线程对应的CLH队列的节点，然后将该节点添加到CLH队列中。CLH队列是管理获取锁的等待线程的队列。 如果“当前线程”是CLH队列的表头，则尝试获取共享锁；否则，则需要通过shouldParkAfterFailedAcquire()判断是否阻塞等待，需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。 doAcquireShared()会通过for循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared()在每一次尝试获取锁时，是通过tryAcquireShared()来执行的！ 释放共享锁 释放共享锁的思想，是先通过tryReleaseShared()尝试释放共享锁。尝试成功的话，则通过doReleaseShared()唤醒“其他等待获取共享锁的线程”，并返回true；否则的话，返回flase。 1. unlock() 说明：该函数实际上调用releaseShared(1)释放共享锁。 2. releaseShared() 说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。 它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。 3. tryReleaseShared() 说明：tryReleaseShared()的作用是尝试释放共享锁。 4. doReleaseShared() 说明：doReleaseShared()会释放“共享锁”。它会从前往后的遍历CLH队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的锁。 公平共享锁和非公平共享锁 和互斥锁ReentrantLock一样，ReadLock也分为公平锁和非公平锁。 公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数readerShouldBlock()是不同的。 在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。 在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为null，则返回true。 ReentrantReadWriteLock示例 import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockTest1 { public static void main(String[] args) { // 创建账户 MyCount myCount = new MyCount(\"4238920615242830\", 10000); // 创建用户，并指定账户 User user = new User(\"Tommy\", myCount); // 分别启动3个“读取账户金钱”的线程 和 3个“设置账户金钱”的线程 for (int i=0; i CountDownLatch原理和示例 CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CountDownLatch和CyclicBarrier的区别 (01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 (02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 关于CyclicBarrier的原理，后面一章再来学习。 // CountDownLatch函数列表 CountDownLatch(int count) // 构造一个用给定计数初始化的 CountDownLatch。 // 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。 void await() // 使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。 boolean await(long timeout, TimeUnit unit) // 递减锁存器的计数，如果计数到达零，则释放所有等待的线程。 void countDown() // 返回当前计数。 long getCount() // 返回标识此锁存器及其状态的字符串。 String toString() 1. CountDownLatch(int count) 说明：该函数是创建一个Sync对象，而Sync是继承于AQS类。 2. await() 说明：该函数实际上是调用的AQS的acquireSharedInterruptibly(1); 说明：acquireSharedInterruptibly()的作用是获取共享锁。 如果当前线程是中断状态，则抛出异常InterruptedException。否则，调用tryAcquireShared(arg)尝试获取共享锁；尝试成功则返回，否则就调用doAcquireSharedInterruptibly()。doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁(或被中断)才返回。 说明：tryAcquireShared()的作用是尝试获取共享锁。 如果\"锁计数器=0\"，即锁是可获取状态，则返回1；否则，锁是不可获取状态，则返回-1。 说明： (01) addWaiter(Node.SHARED)的作用是，创建”当前线程“的Node节点，且Node中记录的锁的类型是”共享锁“(Node.SHARED)；并将该节点添加到CLH队列末尾。关于Node和CLH在\"Java多线程系列--“JUC锁”03之 公平锁(一)\"已经详细介绍过，这里就不再重复说明了。 (02) node.predecessor()的作用是，获取上一个节点。如果上一节点是CLH队列的表头，则”尝试获取共享锁“。 (03) shouldParkAfterFailedAcquire()的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回true；否则，返回false。 (04) 当shouldParkAfterFailedAcquire()返回ture时，则调用parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。 3. countDown() 说明：该函数实际上调用releaseShared(1)释放共享锁。 说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。 它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。 说明：tryReleaseShared()的作用是释放共享锁，将“锁计数器”的值-1。 总结：CountDownLatch是通过“共享锁”实现的。在创建CountDownLatch中时，会传递一个int类型参数count，该参数是“锁计数器”的初始状态，表示该“共享锁”最多能被count给线程同时获取。当某线程调用该CountDownLatch对象的await()方法时，该线程会等待“共享锁”可用时，才能获取“共享锁”进而继续运行。而“共享锁”可用的条件，就是“锁计数器”的值为0！而“锁计数器”的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，才将“锁计数器”-1；通过这种方式，必须有count个线程调用countDown()之后，“锁计数器”才为0，而前面提到的等待线程才能继续运行！ CountDownLatch的使用示例 // 通过CountDownLatch实现：\"主线程\"等待\"5个子线程\"全部都完成\"指定的工作(休眠1000ms)\"之后，再继续运行。 import java.util.concurrent.CountDownLatch; import java.util.concurrent.CyclicBarrier; public class CountDownLatchTest1 { private static int LATCH_SIZE = 5; private static CountDownLatch doneSignal; public static void main(String[] args) { try { doneSignal = new CountDownLatch(LATCH_SIZE); // 新建5个任务 for(int i=0; i CyclicBarrier原理和示例 CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 注意比较CountDownLatch和CyclicBarrier： (01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 (02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 // CyclicBarrier函数列表 CyclicBarrier(int parties) // 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。 CyclicBarrier(int parties, Runnable barrierAction) // 创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。 int await() // 在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。 int await(long timeout, TimeUnit unit) // 在所有参与者都已经在此屏障上调用 await 方法之前将一直等待,或者超出了指定的等待时间。 int getNumberWaiting() // 返回当前在屏障处等待的参与者数目。 int getParties() // 返回要求启动此 barrier 的参与者数目。 boolean isBroken() // 查询此屏障是否处于损坏状态。 void reset() // 将屏障重置为其初始状态。 1. 构造函数 CyclicBarrier的构造函数共2个：CyclicBarrier 和 CyclicBarrier(int parties, Runnable barrierAction)。第1个构造函数是调用第2个构造函数来实现的， 2. 等待函数 说明：await()是通过dowait()实现的。 说明：dowait()的作用就是让当前线程阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，当前线程才继续执行。 (01) generation是CyclicBarrier的一个成员遍历，它的定义如下： private Generation generation = new Generation(); private static class Generation { boolean broken = false; } 在CyclicBarrier中，同一批的线程属于同一代，即同一个Generation；CyclicBarrier中通过generation对象，记录属于哪一代。 当有parties个线程到达barrier，generation就会被更新换代。 (02) 如果当前线程被中断，即Thread.interrupted()为true；则通过breakBarrier()终止CyclicBarrier。breakBarrier()的源码如下： private void breakBarrier() { generation.broken = true; count = parties; trip.signalAll(); } breakBarrier()会设置当前中断标记broken为true，意味着“将该Generation中断”；同时，设置count=parties，即重新初始化count；最后，通过signalAll()唤醒CyclicBarrier上所有的等待线程。 (03) 将“count计数器”-1，即--count；然后判断是不是“有parties个线程到达barrier”，即index是不是为0。 当index=0时，如果barrierCommand不为null，则执行该barrierCommand，barrierCommand就是我们创建CyclicBarrier时，传入的Runnable对象。然后，调用nextGeneration()进行换代工作，nextGeneration()的源码如下： private void nextGeneration() { trip.signalAll(); count = parties; generation = new Generation(); } 首先，它会调用signalAll()唤醒CyclicBarrier上所有的等待线程；接着，重新初始化count；最后，更新generation的值。 (04) 在for(;;)循环中。timed是用来表示当前是不是“超时等待”线程。如果不是，则通过trip.await()进行等待；否则，调用awaitNanos()进行超时等待。 CyclicBarrier的使用示例 // 新建5个线程，这5个线程达到一定的条件时，它们才继续往后运行。 import java.util.concurrent.CyclicBarrier; import java.util.concurrent.BrokenBarrierException; public class CyclicBarrierTest1 { private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) { cb = new CyclicBarrier(SIZE); // 新建5个任务 for(int i=0; i // 新建5个线程，当这5个线程达到一定的条件时，执行某项任务。 import java.util.concurrent.CyclicBarrier; import java.util.concurrent.BrokenBarrierException; public class CyclicBarrierTest2 { private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) { cb = new CyclicBarrier(SIZE, new Runnable () { public void run() { System.out.println(\"CyclicBarrier's parties is: \"+ cb.getParties()); } }); // 新建5个任务 for(int i=0; i Semaphore信号量的原理和示例 Semaphore是一个计数信号量，它的本质是一个\"共享锁\"。 信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。 // Semaphore的函数列表 // 创建具有给定的许可数和非公平的公平设置的 Semaphore。 Semaphore(int permits) // 创建具有给定的许可数和给定的公平设置的 Semaphore。 Semaphore(int permits, boolean fair) // 从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断。 void acquire() // 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞，或者线程已被中断。 void acquire(int permits) // 从此信号量中获取许可，在有可用的许可前将其阻塞。 void acquireUninterruptibly() // 从此信号量获取给定数目的许可，在提供这些许可前一直将线程阻塞。 void acquireUninterruptibly(int permits) // 返回此信号量中当前可用的许可数。 int availablePermits() // 获取并返回立即可用的所有许可。 int drainPermits() // 返回一个 collection，包含可能等待获取的线程。 protected Collection getQueuedThreads() // 返回正在等待获取的线程的估计数目。 int getQueueLength() // 查询是否有线程正在等待获取。 boolean hasQueuedThreads() // 如果此信号量的公平设置为 true，则返回 true。 boolean isFair() // 根据指定的缩减量减小可用许可的数目。 protected void reducePermits(int reduction) // 释放一个许可，将其返回给信号量。 void release() // 释放给定数目的许可，将其返回到信号量。 void release(int permits) // 返回标识此信号量的字符串，以及信号量的状态。 String toString() // 仅在调用时此信号量存在一个可用许可，才从信号量获取许可。 boolean tryAcquire() // 仅在调用时此信号量中有给定数目的许可时，才从此信号量中获取这些许可。 boolean tryAcquire(int permits) // 如果在给定的等待时间内此信号量有可用的所有许可，并且当前线程未被中断，则从此信号量获取给定数目的许可。 boolean tryAcquire(int permits, long timeout, TimeUnit unit) // 如果在给定的等待时间内，此信号量有可用的许可并且当前线程未被中断，则从此信号量获取一个许可。 boolean tryAcquire(long timeout, TimeUnit unit) Semaphore是通过共享锁实现的。根据共享锁的获取原则，Semaphore分为\"公平信号量\"和\"非公平信号量\"。 \"公平信号量\"和\"非公平信号量\"的区别 \"公平信号量\"和\"非公平信号量\"的释放信号量的机制是一样的！不同的是它们获取信号量的机制：线程在尝试获取信号量许可时，对于公平信号量而言，如果当前线程不在CLH队列的头部，则排队等候；而对于非公平信号量而言，无论当前线程是不是在CLH队列的头部，它都会直接获取信号量。该差异具体的体现在，它们的tryAcquireShared()函数的实现不同。 公平信号量获取和释放 1. 公平信号量的获取 Semaphore中的公平信号量是FairSync。 信号量中的acquire()获取函数，实际上是调用的AQS中的acquireSharedInterruptibly()。 说明：tryAcquireShared()的作用是尝试获取acquires个信号量许可数。 对于Semaphore而言，state表示的是“当前可获得的信号量许可数”。 说明：doAcquireSharedInterruptibly()会使当前线程一直等待，直到当前线程获取到共享锁(或被中断)才返回。 (01) addWaiter(Node.SHARED)的作用是，创建”当前线程“的Node节点，且Node中记录的锁的类型是”共享锁“(Node.SHARED)；并将该节点添加到CLH队列末尾。关于Node和CLH在\"Java多线程系列--“JUC锁”03之 公平锁(一)\"已经详细介绍过，这里就不再重复说明了。 (02) node.predecessor()的作用是，获取上一个节点。如果上一节点是CLH队列的表头，则”尝试获取共享锁“。 (03) shouldParkAfterFailedAcquire()的作用和它的名称一样，如果在尝试获取锁失败之后，线程应该等待，则返回true；否则，返回false。 (04) 当shouldParkAfterFailedAcquire()返回ture时，则调用parkAndCheckInterrupt()，当前线程会进入等待状态，直到获取到共享锁才继续运行。 2. 公平信号量的释放 信号量的releases()释放函数，实际上是调用的AQS中的releaseShared()。 说明：releaseShared()的目的是让当前线程释放它所持有的共享锁。 它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。 Semaphore重写了tryReleaseShared()， 如果tryReleaseShared()尝试释放共享锁失败，则会调用doReleaseShared()去释放共享锁。 说明：doReleaseShared()会释放“共享锁”。它会从前往后的遍历CLH队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的信号量。 非公平信号量获取和释放 Semaphore中的非公平信号量是NonFairSync。在Semaphore中，“非公平信号量许可的释放(release)”与“公平信号量许可的释放(release)”是一样的。不同的是它们获取“信号量许可”的机制不同， 说明：非公平信号量的tryAcquireShared()调用AQS中的nonfairTryAcquireShared()。而在nonfairTryAcquireShared()的for循环中，它都会直接判断“当前剩余的信号量许可数”是否足够；足够的话，则直接“设置可以获得的信号量许可数”，进而再获取信号量。 而公平信号量的tryAcquireShared()中，在获取信号量之前会通过if (hasQueuedPredecessors())来判断“当前线程是不是在CLH队列的头部”，是的话，则返回-1。 Semaphore示例 import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; public class SemaphoreTest1 { private static final int SEM_MAX = 10; public static void main(String[] args) { Semaphore sem = new Semaphore(SEM_MAX); //创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(3); //在线程池中执行任务 threadPool.execute(new MyThread(sem, 5)); threadPool.execute(new MyThread(sem, 4)); threadPool.execute(new MyThread(sem, 7)); //关闭池 threadPool.shutdown(); } } class MyThread extends Thread { private volatile Semaphore sem; // 信号量 private int count; // 申请信号量的大小 MyThread(Semaphore sem, int count) { this.sem = sem; this.count = count; } public void run() { try { // 从信号量中获取count个许可 sem.acquire(count); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \" acquire count=\"+count); } catch (InterruptedException e) { e.printStackTrace(); } finally { // 释放给定数目的许可，将其返回到信号量。 sem.release(count); System.out.println(Thread.currentThread().getName() + \" release \" + count + \"\"); } } } (某一次)运行结果： pool-1-thread-1 acquire count=5 pool-1-thread-2 acquire count=4 pool-1-thread-1 release 5 pool-1-thread-2 release 4 pool-1-thread-3 acquire count=7 pool-1-thread-3 release 7 结果说明：信号量sem的许可总数是10个；共3个线程，分别需要获取的信号量许可数是5,4,7。前面两个线程获取到信号量的许可后，sem中剩余的可用的许可数是1；因此，最后一个线程必须等前两个线程释放了它们所持有的信号量许可之后，才能获取到7个信号量许可。 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/多线程_ JUC集合.html":{"url":"chapters/多线程_ JUC集合.html","title":"多线程_ JUC集合","keywords":"","body":"JUC集合CopyOnWriteArrayListCopyOnWriteArrayList示例ConcurrentSkipListMapConcurrentSkipListMap示例 [TOC] JUC集合 List的实现类主要有: LinkedList, ArrayList, Vector, Stack。 (01) LinkedList是双向链表实现的双端队列；它不是线程安全的，只适用于单线程。 (02) ArrayList是数组实现的队列，它是一个动态数组；它也不是线程安全的，只适用于单线程。 (03) Vector是数组实现的矢量队列，它也一个动态数组；不过和ArrayList不同的是，Vector是线程安全的，它支持并发。 (04) Stack是Vector实现的栈；和Vector一样，它也是线程安全的。 Set的实现类主要有: HastSet和TreeSet。 (01) HashSet是一个没有重复元素的集合，它通过HashMap实现的；HashSet不是线程安全的，只适用于单线程。 (02) TreeSet也是一个没有重复元素的集合，不过和HashSet不同的是，TreeSet中的元素是有序的；它是通过TreeMap实现的；TreeSet也不是线程安全的，只适用于单线程。 Map的实现类主要有: HashMap，WeakHashMap, Hashtable和TreeMap。 (01) HashMap是存储“键-值对”的哈希表；它不是线程安全的，只适用于单线程。 (02) WeakHashMap是也是哈希表；和HashMap不同的是，HashMap的“键”是强引用类型，而WeakHashMap的“键”是弱引用类型，也就是说当WeakHashMap 中的某个键不再正常使用时，会被从WeakHashMap中被自动移除。WeakHashMap也不是线程安全的，只适用于单线程。 (03) Hashtable也是哈希表；和HashMap不同的是，Hashtable是线程安全的，支持并发。 (04) TreeMap也是哈希表，不过TreeMap中的“键-值对”是有序的，它是通过R-B Tree(红黑树)实现的；TreeMap不是线程安全的，只适用于单线程。 更多关于这些集合类的介绍，可以参考“Java 集合系列目录(Category)”。 为了方便，我们将前面介绍集合类统称为”java集合包“。java集合包大多是“非线程安全的”，虽然可以通过Collections工具类中的方法获取java集合包对应的同步类，但是这些同步类的并发效率并不是很高。为了更好的支持高并发任务，并发大师Doug Lea在JUC(java.util.concurrent)包中添加了java集合包中单线程类的对应的支持高并发的类。例如，ArrayList对应的高并发类是CopyOnWriteArrayList，HashMap对应的高并发类是ConcurrentHashMap，等等。 JUC包在添加”java集合包“对应的高并发类时，为了保持API接口的一致性，使用了”Java集合包“中的框架。例如，CopyOnWriteArrayList实现了“Java集合包”中的List接口，HashMap继承了“java集合包”中的AbstractMap类，等等。得益于“JUC包使用了Java集合包中的类”，如果我们了解了Java集合包中的类的思想之后，理解JUC包中的类也相对容易；理解时，最大的难点是，对JUC包是如何添加对“高并发”的支持的！ 1. List和Set JUC集合包中的List和Set实现类包括: CopyOnWriteArrayList, CopyOnWriteArraySet和ConcurrentSkipListSet。 (01) CopyOnWriteArrayList相当于线程安全的ArrayList，它实现了List接口。CopyOnWriteArrayList是支持高并发的。 (02) CopyOnWriteArraySet相当于线程安全的HashSet，它继承于AbstractSet类。CopyOnWriteArraySet内部包含一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。 2. Map JUC集合包中Map的实现类包括: ConcurrentHashMap和ConcurrentSkipListMap。 (01) ConcurrentHashMap是线程安全的哈希表(相当于线程安全的HashMap)；它继承于AbstractMap类，并且实现ConcurrentMap接口。ConcurrentHashMap是通过“锁分段”来实现的，它支持并发。 (02) ConcurrentSkipListMap是线程安全的有序的哈希表(相当于线程安全的TreeMap); 它继承于AbstractMap类，并且实现ConcurrentNavigableMap接口。ConcurrentSkipListMap是通过“跳表”来实现的，它支持并发。 (03) ConcurrentSkipListSet是线程安全的有序的集合(相当于线程安全的TreeSet)；它继承于AbstractSet，并实现了NavigableSet接口。ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，它也支持并发。 3. Queue JUC集合包中Queue的实现类包括: ArrayBlockingQueue, LinkedBlockingQueue, LinkedBlockingDeque, ConcurrentLinkedQueue和ConcurrentLinkedDeque。 (01) ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。 (02) LinkedBlockingQueue是单向链表实现的(指定大小)阻塞队列，该队列按 FIFO（先进先出）排序元素。 (03) LinkedBlockingDeque是双向链表实现的(指定大小)双向并发阻塞队列，该阻塞队列同时支持FIFO和FILO两种操作方式。 (04) ConcurrentLinkedQueue是单向链表实现的无界队列，该队列按 FIFO（先进先出）排序元素。 (05) ConcurrentLinkedDeque是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。 CopyOnWriteArrayList 它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的时，它具有以下特性： 1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 2. 它是线程安全的。 3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大。 4. 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作。 5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 说明： 1. CopyOnWriteArrayList实现了List接口，因此它是一个队列。 2. CopyOnWriteArrayList包含了成员lock。每一个CopyOnWriteArrayList都和一个互斥锁lock绑定，通过lock，实现了对CopyOnWriteArrayList的互斥访问。 3. CopyOnWriteArrayList包含了成员array数组，这说明CopyOnWriteArrayList本质上通过数组实现的。 下面从“动态数组”和“线程安全”两个方面进一步对CopyOnWriteArrayList的原理进行说明。 1. CopyOnWriteArrayList的“动态数组”机制 -- 它内部有个“volatile数组”(array)来保持数据。在“添加/修改/删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile数组”。这就是它叫做CopyOnWriteArrayList的原因！CopyOnWriteArrayList就是通过这种方式实现的动态数组；不过正由于它在“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很 低；但是单单只是进行遍历查找的话，效率比较高。 2. CopyOnWriteArrayList的“线程安全”机制 -- 是通过volatile和互斥锁来实现的。(01) CopyOnWriteArrayList是通过“volatile数组”来保存数据的。一个线程读取volatile数组时，总能看到其它线程对该volatile变量最后的写入；就这样，通过volatile提供了“读取到的数据总是最新的”这个机制的 保证。(02) CopyOnWriteArrayList通过互斥锁来保护数据。在“添加/修改/删除”数据时，会先“获取互斥锁”，再修改完毕之后，先将数据更新到“volatile数组”中，然后再“释放互斥锁”；这样，就达到了保护数据的目的。 // CopyOnWriteArrayList函数列表 // 创建一个空列表。 CopyOnWriteArrayList() // 创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。 CopyOnWriteArrayList(Collection c) // CopyOnWriteArrayList(E[] toCopyIn) // 创建一个保存给定数组的副本的列表。 // 将指定元素添加到此列表的尾部。 boolean add(E e) // 在此列表的指定位置上插入指定元素。 void add(int index, E element) // 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中的所有元素添加此列表的尾部。 boolean addAll(Collection c) // 从指定位置开始，将指定 collection 的所有元素插入此列表。 boolean addAll(int index, Collection c) // 按照指定 collection 的迭代器返回元素的顺序，将指定 collection 中尚未包含在此列表中的所有元素添加列表的尾部。 int addAllAbsent(Collection c) // 添加元素（如果不存在）。 boolean addIfAbsent(E e) // 从此列表移除所有元素。 void clear() // 返回此列表的浅表副本。 Object clone() // 如果此列表包含指定的元素，则返回 true。 boolean contains(Object o) // 如果此列表包含指定 collection 的所有元素，则返回 true。 boolean containsAll(Collection c) // 比较指定对象与此列表的相等性。 boolean equals(Object o) // 返回列表中指定位置的元素。 E get(int index) // 返回此列表的哈希码值。 int hashCode() // 返回第一次出现的指定元素在此列表中的索引，从 index 开始向前搜索，如果没有找到该元素，则返回 -1。 int indexOf(E e, int index) // 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 int indexOf(Object o) // 如果此列表不包含任何元素，则返回 true。 boolean isEmpty() // 返回以恰当顺序在此列表元素上进行迭代的迭代器。 Iterator iterator() // 返回最后一次出现的指定元素在此列表中的索引，从 index 开始向后搜索，如果没有找到该元素，则返回 -1。 int lastIndexOf(E e, int index) // 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 int lastIndexOf(Object o) // 返回此列表元素的列表迭代器（按适当顺序）。 ListIterator listIterator() // 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。 ListIterator listIterator(int index) // 移除此列表指定位置上的元素。 E remove(int index) // 从此列表移除第一次出现的指定元素（如果存在）。 boolean remove(Object o) // 从此列表移除所有包含在指定 collection 中的元素。 boolean removeAll(Collection c) // 只保留此列表中包含在指定 collection 中的元素。 boolean retainAll(Collection c) // 用指定的元素替代此列表指定位置上的元素。 E set(int index, E element) // 返回此列表中的元素数。 int size() // 返回此列表中 fromIndex（包括）和 toIndex（不包括）之间部分的视图。 List subList(int fromIndex, int toIndex) // 返回一个按恰当顺序（从第一个元素到最后一个元素）包含此列表中所有元素的数组。 Object[] toArray() // 返回以恰当顺序（从第一个元素到最后一个元素）包含列表所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 T[] toArray(T[] a) // 返回此列表的字符串表示形式。 1. 创建 CopyOnWriteArrayList共3个构造函数。 说明：这3个构造函数都调用了setArray()， 说明：setArray()的作用是给array赋值；其中，array是volatile transient Object[]类型，即array是“volatile数组”。 关于volatile关键字，我们知道“volatile能让变量变得可见”，即对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。正在由于这种特性，每次更新了“volatile数组”之后，其它线程都能看到对它所做的更新。 关于transient关键字，它是在序列化中才起作用，transient变量不会被自动序列化。transient不是本文关注的重点，了解即可。 关于transient的更多内容，请参考：http://www.cnblogs.com/skywang12345/p/io_06.html 2. 添加 以add(E e)为例，来对“CopyOnWriteArrayList的添加操作”进行说明 说明：add(E e)的作用就是将数据e添加到”volatile数组“中。它的实现方式是，新建一个数组，接着将原始的”volatile数组“的数据拷贝到新数组中，然后将新增数据也添加到新数组中；最后，将新数组赋值给”volatile数组“。 在add(E e)中有两点需要关注。 第一，在”添加操作“开始前，获取独占锁(lock)，若此时有需要线程要获取锁，则必须等待；在操作完毕后，释放独占锁(lock)，此时其它线程才能获取锁。通过独占锁，来防止多线程同时修改数据！ 3. 获取 说明：get(int index)的实现很简单，就是返回”volatile数组“中的第index个元素。 4. 删除 以remove(int index)为例，来对“CopyOnWriteArrayList的删除操作”进行说明。 说明：remove(int index)的作用就是将”volatile数组“中第index个元素删除。它的实现方式是，如果被删除的是最后一个元素，则直接通过Arrays.copyOf()进行处理，而不需要新建数组。否则，新建数组，然后将”volatile数组中被删除元素之外的其它元素“拷贝到新数组中；最后，将新数组赋值给”volatile数组“。 和add(E e)一样，remove(int index)也是”在操作之前，获取独占锁；操作完成之后，释放独占是“；并且”在操作完成时，会通过将数据更新到volatile数组中“。 5. 遍历 以iterator()为例，来对“CopyOnWriteArrayList的遍历操作”进行说明。 说明：iterator()会返回COWIterator对象。COWIterator实现额ListIterator接口， 说明：COWIterator不支持修改元素的操作。例如，对于remove(),set(),add()等操作，COWIterator都会抛出异常！ 另外，需要提到的一点是，CopyOnWriteArrayList返回迭代器不会抛出ConcurrentModificationException异常，即它不是fail-fast机制的！ CopyOnWriteArrayList示例 import java.util.*; import java.util.concurrent.*; /* * CopyOnWriteArrayList是“线程安全”的动态数组，而ArrayList是非线程安全的。 * * 下面是“多个线程同时操作并且遍历list”的示例 * (01) 当list是CopyOnWriteArrayList对象时，程序能正常运行。 * (02) 当list是ArrayList对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class CopyOnWriteArrayListTest1 { // TODO: list是ArrayList对象时，程序会出错。 //private static List list = new ArrayList(); private static List list = new CopyOnWriteArrayList(); public static void main(String[] args) { // 同时启动两个线程对list进行操作！ new MyThread(\"ta\").start(); new MyThread(\"tb\").start(); } private static void printAll() { String value = null; Iterator iter = list.iterator(); while(iter.hasNext()) { value = (String)iter.next(); System.out.print(value+\", \"); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ ConcurrentSkipListMap ConcurrentSkipListMap是线程安全的有序的哈希表，适用于高并发的场景。 ConcurrentSkipListMap和TreeMap，它们虽然都是有序的哈希表。但是，第一，它们的线程安全机制不同，TreeMap是非线程安全的，而ConcurrentSkipListMap是线程安全的。第二，ConcurrentSkipListMap是通过跳表实现的，而TreeMap是通过红黑树实现的。 关于跳表(Skip List)，它是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。 说明： 先以数据“7,14,21,32,37,71,85”序列为例，来对跳表进行简单说明。 跳表分为许多层(level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。每一层的数据都是有序的，上一层数据是下一层数据的子集，并且第一层(level 1)包含了全部的数据；层次越高，跳跃性越大，包含的数据越少。 跳表包含一个表头，它查找数据时，是从上往下，从左往右进行查找。现在“需要找出值为32的节点”为例，来对比说明跳表和普遍的链表。 情况1：链表中查找“32”节点 情况2：跳表中查找“32”节点 忽略索引垂直线路上路径的情况下，只需要2步(红色部分表示路径)。 下面说说Java中ConcurrentSkipListMap的数据结构。 (01) ConcurrentSkipListMap继承于AbstractMap类，也就意味着它是一个哈希表。 (02) Index是ConcurrentSkipListMap的内部类，它与“跳表中的索引相对应”。HeadIndex继承于Index，ConcurrentSkipListMap中含有一个HeadIndex的对象head，head是“跳表的表头”。 (03) Index是跳表中的索引，它包含“右索引的指针(right)”，“下索引的指针(down)”和“哈希表节点node”。node是Node的对象，Node也是ConcurrentSkipListMap中的内部类。 // ConcurrentSkipListMap函数列表 // 构造一个新的空映射，该映射按照键的自然顺序进行排序。 ConcurrentSkipListMap() // 构造一个新的空映射，该映射按照指定的比较器进行排序。 ConcurrentSkipListMap(Comparator comparator) // 构造一个新映射，该映射所包含的映射关系与给定映射包含的映射关系相同，并按照键的自然顺序进行排序。 ConcurrentSkipListMap(Map m) // 构造一个新映射，该映射所包含的映射关系与指定的有序映射包含的映射关系相同，使用的顺序也相同。 ConcurrentSkipListMap(SortedMap m) // 返回与大于等于给定键的最小键关联的键-值映射关系；如果不存在这样的条目，则返回 null。 Map.Entry ceilingEntry(K key) // 返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。 K ceilingKey(K key) // 从此映射中移除所有映射关系。 void clear() // 返回此 ConcurrentSkipListMap 实例的浅表副本。 ConcurrentSkipListMap clone() // 返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。 Comparator comparator() // 如果此映射包含指定键的映射关系，则返回 true。 boolean containsKey(Object key) // 如果此映射为指定值映射一个或多个键，则返回 true。 boolean containsValue(Object value) // 返回此映射中所包含键的逆序 NavigableSet 视图。 NavigableSet descendingKeySet() // 返回此映射中所包含映射关系的逆序视图。 ConcurrentNavigableMap descendingMap() // 返回此映射中所包含的映射关系的 Set 视图。 Set> entrySet() // 比较指定对象与此映射的相等性。 boolean equals(Object o) // 返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry firstEntry() // 返回此映射中当前第一个（最低）键。 K firstKey() // 返回与小于等于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。 Map.Entry floorEntry(K key) // 返回小于等于给定键的最大键；如果不存在这样的键，则返回 null。 K floorKey(K key) // 返回指定键所映射到的值；如果此映射不包含该键的映射关系，则返回 null。 V get(Object key) // 返回此映射的部分视图，其键值严格小于 toKey。 ConcurrentNavigableMap headMap(K toKey) // 返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。 ConcurrentNavigableMap headMap(K toKey, boolean inclusive) // 返回与严格大于给定键的最小键关联的键-值映射关系；如果不存在这样的键，则返回 null。 Map.Entry higherEntry(K key) // 返回严格大于给定键的最小键；如果不存在这样的键，则返回 null。 K higherKey(K key) // 如果此映射未包含键-值映射关系，则返回 true。 boolean isEmpty() // 返回此映射中所包含键的 NavigableSet 视图。 NavigableSet keySet() // 返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry lastEntry() // 返回映射中当前最后一个（最高）键。 K lastKey() // 返回与严格小于给定键的最大键关联的键-值映射关系；如果不存在这样的键，则返回 null。 Map.Entry lowerEntry(K key) // 返回严格小于给定键的最大键；如果不存在这样的键，则返回 null。 K lowerKey(K key) // 返回此映射中所包含键的 NavigableSet 视图。 NavigableSet navigableKeySet() // 移除并返回与此映射中的最小键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry pollFirstEntry() // 移除并返回与此映射中的最大键关联的键-值映射关系；如果该映射为空，则返回 null。 Map.Entry pollLastEntry() // 将指定值与此映射中的指定键关联。 V put(K key, V value) // 如果指定键已经不再与某个值相关联，则将它与给定值关联。 V putIfAbsent(K key, V value) // 从此映射中移除指定键的映射关系（如果存在）。 V remove(Object key) // 只有目前将键的条目映射到给定值时，才移除该键的条目。 boolean remove(Object key, Object value) // 只有目前将键的条目映射到某一值时，才替换该键的条目。 V replace(K key, V value) // 只有目前将键的条目映射到给定值时，才替换该键的条目。 boolean replace(K key, V oldValue, V newValue) // 返回此映射中的键-值映射关系数。 int size() // 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。 ConcurrentNavigableMap subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) // 返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。 ConcurrentNavigableMap subMap(K fromKey, K toKey) // 返回此映射的部分视图，其键大于等于 fromKey。 ConcurrentNavigableMap tailMap(K fromKey) // 返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。 ConcurrentNavigableMap tailMap(K fromKey, boolean inclusive) // 返回此映射中所包含值的 Collection 视图。 Collection values() 1. 添加 下面以put(K key, V value)为例，对ConcurrentSkipListMap的添加方法进行说明。 实际上，put()是通过doPut()将key-value键值对添加到ConcurrentSkipListMap中的。 说明：doPut() 的作用就是将键值对添加到“跳表”中。 要想搞清doPut()，首先要弄清楚它的主干部分 —— 我们先单纯的只考虑“单线程的情况下，将key-value添加到跳表中”，即忽略“多线程相关的内容”。它的流程如下： 第1步：找到“插入位置”。 即，找到“key的前继节点(b)”和“key的后继节点(n)”；key是要插入节点的键。 第2步：新建并插入节点。 即，新建节点z(key对应的节点)，并将新节点z插入到“跳表”中(设置“b的后继节点为z”，“z的后继节点为n”)。 第3步：更新跳表。 即，随机获取一个level，然后在“跳表”的第1层～第level层之间，每一层都插入节点z；在第level层之上就不再插入节点了。若level数值大于“跳表的层次”，则新建一层。 2. 删除 下面以remove(Object key)为例，对ConcurrentSkipListMap的删除方法进行说明。 实际上，remove()是通过doRemove()将ConcurrentSkipListMap中的key对应的键值对删除的。 说明：doRemove()的作用是删除跳表中的节点。 和doPut()一样，我们重点看doRemove()的主干部分，了解主干部分之后，其余部分就非常容易理解了。下面是“单线程的情况下，删除跳表中键值对的步骤”： 第1步：找到“被删除节点的位置”。 即，找到“key的前继节点(b)”，“key所对应的节点(n)”，“n的后继节点f”；key是要删除节点的键。 第2步：删除节点。 即，将“key所对应的节点n”从跳表中移除 -- 将“b的后继节点”设为“f”！ 第3步：更新跳表。 即，遍历跳表，删除每一层的“key节点”(如果存在的话)。如果删除“key节点”之后，跳表的层次需要-1；则执行相应的操作！ 3. 获取 下面以get(Object key)为例，对ConcurrentSkipListMap的获取方法进行说明。 说明：doGet()是通过findNode()找到并返回节点的。 说明：findNode(key)的作用是在返回跳表中key对应的节点；存在则返回节点，不存在则返回null。 先弄清函数的主干部分，即抛开“多线程相关内容”，单纯的考虑单线程情况下，从跳表获取节点的算法。 第1步：找到“被删除节点的位置”。 根据findPredecessor()定位key所在的层次以及找到key的前继节点(b)，然后找到b的后继节点n。 第2步：根据“key的前继节点(b)”和“key的前继节点的后继节点(n)”来定位“key对应的节点”。 具体是通过比较“n的键值”和“key”的大小。如果相等，则n就是所要查找的键。 ConcurrentSkipListMap示例 import java.util.*; import java.util.concurrent.*; /* * ConcurrentSkipListMap是“线程安全”的哈希表，而TreeMap是非线程安全的。 * * 下面是“多个线程同时操作并且遍历map”的示例 * (01) 当map是ConcurrentSkipListMap对象时，程序能正常运行。 * (02) 当map是TreeMap对象时，程序会产生ConcurrentModificationException异常。 * * @author skywang */ public class ConcurrentSkipListMapDemo1 { // TODO: map是TreeMap对象时，程序会出错。 //private static Map map = new TreeMap(); private static Map map = new ConcurrentSkipListMap(); public static void main(String[] args) { // 同时启动两个线程对map进行操作！ new MyThread(\"a\").start(); new MyThread(\"b\").start(); } private static void printAll() { String key, value; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) { Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); value = (String)entry.getValue(); System.out.print(\"(\"+key+\", \"+value+\"), \"); } System.out.println(); } private static class MyThread extends Thread { MyThread(String name) { super(name); } @Override public void run() { int i = 0; while (i++ Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/多线程_JUC线程池.html":{"url":"chapters/多线程_JUC线程池.html","title":"多线程_JUC线程池","keywords":"","body":"JUC线程池线程池示例线程池原理(上)ThreadPoolExecutor简介线程池调度线程池示例创建线程池添加任务到线程池关闭线程池线程池原理(下)线程状态切换拒绝策略DiscardPolicy 示例DiscardOldestPolicy 示例AbortPolicy 示例CallerRunsPolicy 示例Callable和FutureCallable和Future的基本用法 [TOC] JUC线程池 1. Executor 它是\"执行者\"接口，它是来执行任务的。准确的说，Executor提供了execute()接口来执行已提交的 Runnable 任务的对象。Executor存在的目的是提供一种将\"任务提交\"与\"任务如何运行\"分离开来的机制。 它只包含一个函数接口： void execute(Runnable command) 2. ExecutorService ExecutorService继承于Executor。它是\"执行者服务\"接口，它是为\"执行者接口Executor\"服务而存在的；准确的话，ExecutorService提供了\"将任务提交给执行者的接口(submit方法)\"，\"让执行者执行任务(invokeAll, invokeAny方法)\"的接口等等。 3. AbstractExecutorService AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。 AbstractExecutorService存在的目的是为ExecutorService中的函数接口提供了默认实现。 AbstractExecutorService函数列表 由于它的函数列表和ExecutorService一样，这里就不再重复列举了。 4. ThreadPoolExecutor ThreadPoolExecutor就是大名鼎鼎的\"线程池\"。它继承于AbstractExecutorService抽象类。 5. ScheduledExecutorService ScheduledExecutorService是一个接口，它继承于于ExecutorService。它相当于提供了\"延时\"和\"周期执行\"功能的ExecutorService。 ScheduledExecutorService提供了相应的函数接口，可以安排任务在给定的延迟后执行，也可以让任务周期的执行。 6. ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor继承于ThreadPoolExecutor，并且实现了ScheduledExecutorService接口。它相当于提供了\"延时\"和\"周期执行\"功能的ScheduledExecutorService。 ScheduledThreadPoolExecutor类似于Timer，但是在高并发程序中，ScheduledThreadPoolExecutor的性能要优于Timer。 7. Executors Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。 线程池示例 import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; public class ThreadPoolDemo1 { public static void main(String[] args) { // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); } } class MyThread extends Thread { @Override public void run() { System.out.println(Thread.currentThread().getName()+ \" is running.\"); } } 运行结果： pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. 结果说明： 主线程中创建了线程池pool，线程池的容量是2。即，线程池中最多能同时运行2个线程。 紧接着，将ta,tb,tc,td,te这3个线程添加到线程池中运行。 最后，通过shutdown()关闭线程池。 线程池原理(上) ThreadPoolExecutor简介 ThreadPoolExecutor是线程池类。对于线程池，可以通俗的将它理解为\"存放一定数量线程的一个线程集合。线程池允许若个线程同时允许，允许同时运行的线程数量就是线程池的容量；当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。\" // 阻塞队列。 private final BlockingQueue workQueue; // 互斥锁 private final ReentrantLock mainLock = new ReentrantLock(); // 线程集合。一个Worker对应一个线程。 private final HashSet workers = new HashSet(); // “终止条件”，与“mainLock”绑定。 private final Condition termination = mainLock.newCondition(); // 线程池中线程数量曾经达到过的最大值。 private int largestPoolSize; // 已完成任务数量 private long completedTaskCount; // ThreadFactory对象，用于创建线程。 private volatile ThreadFactory threadFactory; // 拒绝策略的处理句柄。 private volatile RejectedExecutionHandler handler; // 保持线程存活时间。 private volatile long keepAliveTime; private volatile boolean allowCoreThreadTimeOut; // 核心池大小 private volatile int corePoolSize; // 最大池大小 private volatile int maximumPoolSize; workers workers是HashSet类型，即它是一个Worker集合。而一个Worker对应一个线程，也就是说线程池通过workers包含了\"一个线程集合\"。当Worker对应的线程池启动时，它会执行线程池中的任务；当执行完一个任务后，它会从线程池的阻塞队列中取出一个阻塞的任务来继续运行。 wokers的作用是，线程池通过它实现了\"允许多个线程同时运行\"。 workQueue workQueue是BlockingQueue类型，即它是一个阻塞队列。当线程池中的线程数超过它的容量的时候，线程会进入阻塞队列进行阻塞等待。 通过workQueue，线程池实现了阻塞功能。 mainLock mainLock是互斥锁，通过mainLock实现了对线程池的互斥访问。 corePoolSize和maximumPoolSize corePoolSize是\"核心池大小\"，maximumPoolSize是\"最大池大小\"。它们的作用是调整\"线程池中实际运行的线程的数量\"。 例如，当新任务提交给线程池时(通过execute方法)。 -- 如果此时，线程池中运行的线程数量 corePoolSize，但是却 poolSize poolSize是当前线程池的实际大小，即线程池中任务的数量。 allowCoreThreadTimeOut和keepAliveTime allowCoreThreadTimeOut表示是否允许\"线程在空闲状态时，仍然能够存活\"；而keepAliveTime是当线程池处于空闲状态的时候，超过keepAliveTime时间之后，空闲的线程会被终止。 threadFactory threadFactory是ThreadFactory对象。它是一个线程工厂类，\"线程池通过ThreadFactory创建线程\"。 handler handler是RejectedExecutionHandler类型。它是\"线程池拒绝策略\"的句柄，也就是说\"当某任务添加到线程池中，而线程池拒绝该任务时，线程池会通过handler进行相应的处理\"。 综上所说，线程池通过workers来管理\"线程集合\"，每个线程在启动后，会执行线程池中的任务；当一个任务执行完后，它会从线程池的阻塞队列中取出任务来继续运行。阻塞队列是管理线程池任务的队列，当添加到线程池中的任务超过线程池的容量时，该任务就会进入阻塞队列进行等待。 线程池调度 说明： 在\"图-01\"中，线程池中有N个任务。\"任务1\", \"任务2\", \"任务3\"这3个任务在执行，而\"任务3\"到\"任务N\"在阻塞队列中等待。正在执行的任务，在workers集合中，workers集合包含3个Worker，每一个Worker对应一个Thread线程，Thread线程每次处理一个任务。 当workers集合中处理完某一个任务之后，会从阻塞队列中取出一个任务来继续执行，如图-02所示。图-02表示\"任务1\"处理完毕之后，线程池将\"任务4\"从阻塞队列中取出，放到workers中进行处理。 线程池示例 import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; public class ThreadPoolDemo1 { public static void main(String[] args) { // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(2); // 创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口 Thread ta = new MyThread(); Thread tb = new MyThread(); Thread tc = new MyThread(); Thread td = new MyThread(); Thread te = new MyThread(); // 将线程放入池中进行执行 pool.execute(ta); pool.execute(tb); pool.execute(tc); pool.execute(td); pool.execute(te); // 关闭线程池 pool.shutdown(); } } class MyThread extends Thread { @Override public void run() { System.out.println(Thread.currentThread().getName()+ \" is running.\"); } } 运行结果： pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. pool-1-thread-2 is running. pool-1-thread-1 is running. 示例中，包括了线程池的创建，将任务添加到线程池中，关闭线程池这3个主要的步骤。 创建线程池 1. newFixedThreadPool() newFixedThreadPool()在Executors.java中定义，源码如下： public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } 说明：newFixedThreadPool(int nThreads)的作用是创建一个线程池，线程池的容量是nThreads。 newFixedThreadPool()在调用ThreadPoolExecutor()时，会传递一个LinkedBlockingQueue()对象，而LinkedBlockingQueue是单向链表实现的阻塞队列。在线程池中，就是通过该阻塞队列来实现\"当线程池中任务数量超过允许的任务数量时，部分任务会阻塞等待\"。 2. ThreadPoolExecutor() ThreadPoolExecutor()在ThreadPoolExecutor.java中定义，源码如下： public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } 说明：该函数实际上是调用ThreadPoolExecutor的另外一个构造函数。 说明：在ThreadPoolExecutor()的构造函数中，进行的是初始化工作。 corePoolSize, maximumPoolSize, unit, keepAliveTime和workQueue这些变量的值是已知的，它们都是通过newFixedThreadPool()传递而来。下面看看threadFactory和handler对象。 2.1 ThreadFactory 线程池中的ThreadFactory是一个线程工厂，线程池创建线程都是通过线程工厂对象(threadFactory)来完成的。 上面所说的threadFactory对象，是通过 Executors.defaultThreadFactory()返回的。 public static ThreadFactory defaultThreadFactory() { return new DefaultThreadFactory(); } defaultThreadFactory()返回DefaultThreadFactory对象。 说明：ThreadFactory的作用就是提供创建线程的功能的线程工厂。 它是通过newThread()提供创建线程功能的，下面简单说说newThread()。newThread()创建的线程对应的任务是Runnable对象，它创建的线程都是“非守护线程”而且“线程优先级都是Thread.NORM_PRIORITY”。 2.2 RejectedExecutionHandler handler是ThreadPoolExecutor中拒绝策略的处理句柄。所谓拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。 线程池默认会采用的是defaultHandler策略，即AbortPolicy策略。在AbortPolicy策略中，线程池拒绝任务时会抛出异常。 添加任务到线程池 1. execute() 说明：execute()的作用是将任务添加到线程池中执行。它会分为3种情况进行处理： 情况1 -- 如果\"线程池中任务数量\" = \"核心池大小\"，并且\"线程池是允许状态\"；此时，则将任务添加到阻塞队列中阻塞等待。在该情况下，会再次确认\"线程池的状态\"，如果\"第2次读到的线程池状态\"和\"第1次读到的线程池状态\"不同，则从阻塞队列中删除该任务。 情况3 -- 非以上两种情况。在这种情况下，尝试新建一个线程，并将该任务添加到线程中进行执行。如果执行失败，则通过reject()拒绝该任务。 2. addWorker() 说明：addWorker(Runnable firstTask, boolean core) 的作用是将任务(firstTask)添加到线程池中，并启动该任务。 core为true的话，则以corePoolSize为界限，若\"线程池中已有任务数量>=corePoolSize\"，则返回false；core为false的话，则以maximumPoolSize为界限，若\"线程池中已有任务数量>=maximumPoolSize\"，则返回false。 addWorker()会先通过for循环不断尝试更新ctl状态，ctl记录了\"线程池中任务数量和线程池状态\"。 更新成功之后，再通过try模块来将任务添加到线程池中，并启动任务所在的线程。 从addWorker()中，我们能清晰的发现：线程池在添加任务时，会创建任务对应的Worker对象；而一个Workder对象包含一个Thread对象。(01) 通过将Worker对象添加到\"线程的workers集合\"中，从而实现将任务添加到线程池中。 (02) 通过启动Worker对应的Thread线程，则执行该任务。 3. submit() 补充说明一点，submit()实际上也是通过调用execute()实现的 关闭线程池 说明：shutdown()的作用是关闭线程池。 线程池原理(下) 线程有5种状态：新建状态，就绪状态，运行状态，阻塞状态，死亡状态。线程池也有5种状态；然而，线程池不同于线程，线程池的5种状态是：Running, SHUTDOWN, STOP, TIDYING, TERMINATED。 线程池状态定义代码如下： private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3; private static final int CAPACITY = (1 线程状态切换 RUNNING (01) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态！ 道理很简单，在ctl的初始化代码中(如下)，就将它初始化为RUNNING状态，并且\"任务数量\"初始化为0。 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)) SHUTDOWN (01) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 (02) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。 STOP (01) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 (02) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。 TIDYING (01) 状态说明：当所有的任务已终止，ctl记录的\"任务数量\"为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 (02) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。 TEMINATED (01) 状态说明：线程池彻底终止，就变成TERMINATED状态。 (02) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。 拒绝策略 线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。 当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。 线程池共包括4种拒绝策略，它们分别是：AbortPolicy, CallerRunsPolicy, DiscardOldestPolicy和DiscardPolicy。 AbortPolicy -- 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。 CallerRunsPolicy -- 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。 DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。 DiscardPolicy -- 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。 线程池默认的处理策略是AbortPolicy！ DiscardPolicy 示例 import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.DiscardPolicy; public class DiscardPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的\"最大池大小\"和\"核心池大小\"都为1(THREADS_SIZE)，\"线程池\"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue(CAPACITY)); // 设置线程池的拒绝策略为\"丢弃\" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i DiscardOldestPolicy 示例 import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy; public class DiscardOldestPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的\"最大池大小\"和\"核心池大小\"都为1(THREADS_SIZE)，\"线程池\"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue(CAPACITY)); // 设置线程池的拒绝策略为\"DiscardOldestPolicy\" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i AbortPolicy 示例 import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.AbortPolicy; import java.util.concurrent.RejectedExecutionException; public class AbortPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的\"最大池大小\"和\"核心池大小\"都为1(THREADS_SIZE)，\"线程池\"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue(CAPACITY)); // 设置线程池的拒绝策略为\"抛出异常\" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); try { // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i CallerRunsPolicy 示例 import java.lang.reflect.Field; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy; public class CallerRunsPolicyDemo { private static final int THREADS_SIZE = 1; private static final int CAPACITY = 1; public static void main(String[] args) throws Exception { // 创建线程池。线程池的\"最大池大小\"和\"核心池大小\"都为1(THREADS_SIZE)，\"线程池\"的阻塞队列容量为1(CAPACITY)。 ThreadPoolExecutor pool = new ThreadPoolExecutor(THREADS_SIZE, THREADS_SIZE, 0, TimeUnit.SECONDS, new ArrayBlockingQueue(CAPACITY)); // 设置线程池的拒绝策略为\"CallerRunsPolicy\" pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 新建10个任务，并将它们添加到线程池中。 for (int i = 0; i Callable和Future Callable 和 Future 是比较有趣的一对组合。当我们需要获取线程的执行结果时，就需要用到它们。Callable用于产生结果，Future用于获取结果。 1. Callable Callable 是一个接口，它只包含一个call()方法。Callable是一个返回结果并且可能抛出异常的任务。 为了便于理解，我们可以将Callable比作一个Runnable接口，而Callable的call()方法则类似于Runnable的run()方法。 Callable的源码如下： public interface Callable { V call() throws Exception; } 说明：从中我们可以看出Callable支持泛型。 2. Futurejava Future 是一个接口。它用于表示异步计算的结果。提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。 说明：Future用于表示异步计算的结果。它的实现类是FutureTask，在讲解FutureTask之前，我们先看看Callable, Future, FutureTask它们之间的关系图，如下： 说明： (01) RunnableFuture是一个接口，它继承了Runnable和Future这两个接口。RunnableFuture的源码如下： public interface RunnableFuture extends Runnable, Future { void run(); } (02) FutureTask实现了RunnableFuture接口。所以，我们也说它实现了Future接口。 Callable和Future的基本用法 import java.util.concurrent.Callable; import java.util.concurrent.Future; import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; import java.util.concurrent.ExecutionException; class MyCallable implements Callable { @Override public Integer call() throws Exception { int sum = 0; // 执行任务 for (int i=0; i 1. submit() submit()在java/util/concurrent/AbstractExecutorService.java中实现 说明：submit()通过newTaskFor(task)创建了RunnableFuture对象ftask。它的源码如下： protected RunnableFuture newTaskFor(Callable callable) { return new FutureTask(callable); } 2. FutureTask的构造函数 public FutureTask(Callable callable) { if (callable == null) throw new NullPointerException(); // callable是一个Callable对象 this.callable = callable; // state记录FutureTask的状态 this.state = NEW; // ensure visibility of callable } 3. FutureTask的run()方法 我们继续回到submit()的源码中。 在newTaskFor()新建一个ftask对象之后，会通过execute(ftask)执行该任务。此时ftask被当作一个Runnable对象进行执行，最终会调用到它的run()方法；ftask的run()方法在java/util/concurrent/FutureTask.java中实现， 说明：run()中会执行Callable对象的call()方法，并且最终将结果保存到result中，并通过set(result)将result保存。之后调用FutureTask的get()方法，返回的就是通过set(result)保存的值。 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/多线程_生产者消费者.html":{"url":"chapters/多线程_生产者消费者.html","title":"多线程_生产者消费者","keywords":"","body":"生产者消费者synchronized版本lock+condition的同步BlockingQueue版实现Disruptor方式提高消费者的响应时间：选择合适的策略CPU Cache的优化：解决伪共享问题并行流水线 [TOC] 生产者消费者 1. Java生产者消费者的三种实现 https://blog.csdn.net/xindoo/article/details/80004003 Java生产者消费者是最基础的线程同步问题，java岗面试中还是很容易遇到的，之前没写过多线程的代码，面试中被问到很尬啊，面完回来恶补下。在网上查到大概有5种生产者消费者的写法，分别如下。 用synchronized对存储加锁，然后用object原生的wait() 和 notify()做同步。 用concurrent.locks.Lock，然后用condition的await() 和signal()做同步。 直接使用concurrent.BlockingQueue。 使用PipedInputStream/PipedOutputStream。 使用信号量semaphore。 synchronized版本 import java.util.LinkedList; import java.util.Queue; public class ProducerAndConsumer { private final int MAX_LEN = 10; private Queue queue = new LinkedList(); class Producer extends Thread { @Override public void run() { producer(); } private void producer() { while(true) { synchronized (queue) { while (queue.size() == MAX_LEN) { queue.notify(); System.out.println(\"当前队列满\"); try { queue.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } queue.add(1); queue.notify(); System.out.println(\"生产者生产一条任务，当前队列长度为\" + queue.size()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } } } class Consumer extends Thread { @Override public void run() { consumer(); } private void consumer() { while (true) { synchronized (queue) { while (queue.size() == 0) { queue.notify(); System.out.println(\"当前队列为空\"); try { queue.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } queue.poll(); queue.notify(); System.out.println(\"消费者消费一条任务，当前队列长度为\" + queue.size()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } } } public static void main(String[] args) { ProducerAndConsumer pc = new ProducerAndConsumer(); Producer producer = pc.new Producer(); Consumer consumer = pc.new Consumer(); producer.start(); consumer.start(); } } lock+condition的同步 import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * version 1 doesn't use synchronized to improve performance */ public class ProducerAndConsumer1 { private final int MAX_LEN = 10; private Queue queue = new LinkedList(); private final Lock lock = new ReentrantLock(); private final Condition condition = lock.newCondition(); class Producer extends Thread { @Override public void run() { producer(); } private void producer() { while(true) { lock.lock(); try { while (queue.size() == MAX_LEN) { System.out.println(\"当前队列满\"); try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } queue.add(1); condition.signal(); System.out.println(\"生产者生产一条任务，当前队列长度为\" + queue.size()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } finally { lock.unlock(); } } } } class Consumer extends Thread { @Override public void run() { consumer(); } private void consumer() { while (true) { lock.lock(); try { while (queue.size() == 0) { System.out.println(\"当前队列为空\"); try { condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } queue.poll(); condition.signal(); System.out.println(\"消费者消费一条任务，当前队列长度为\" + queue.size()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } finally { lock.unlock(); } } } } public static void main(String[] args) { ProducerAndConsumer pc = new ProducerAndConsumer(); Producer producer = pc.new Producer(); Consumer consumer = pc.new Consumer(); producer.start(); consumer.start(); } } BlockingQueue版实现 import java.util.Random; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; public class ProducerAndConsumer { private BlockingQueue queue = new LinkedBlockingQueue(10); class Producer extends Thread { @Override public void run() { producer(); } private void producer() { while(true) { try { queue.put(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"生产者生产一条任务，当前队列长度为\" + queue.size()); try { Thread.sleep(new Random().nextInt(1000)+500); } catch (InterruptedException e) { e.printStackTrace(); } } } } class Consumer extends Thread { @Override public void run() { consumer(); } private void consumer() { while (true) { try { queue.take(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"消费者消费一条任务，当前队列长度为\" + queue.size()); try { Thread.sleep(new Random().nextInt(1000)+500); } catch (InterruptedException e) { e.printStackTrace(); } } } } public static void main(String[] args) { ProducerAndConsumer pc = new ProducerAndConsumer(); Producer producer = pc.new Producer(); Consumer consumer = pc.new Consumer(); producer.start(); consumer.start(); } } Disruptor方式 // 摘自《Java高并发程序设计》 // https://blog.csdn.net/sunhaoning/article/details/64131362 // BlockigQueue用于实现生产者和消费者一个不错的选择。它可以很自然地实现作为生产者和消费者的内存缓冲区。但是BlockigQueue并不是一个高性能的实现，它完全使用锁和阻塞等待来实现线程间的同步。在高并发场合，它的性能并不是特别的优越。就像之前我已经提过的：ConcurrentLinkedQueue是一个高性能的队列，但是BlockingQueue只是为了方便数据共享。 // 而ConcurrentLinkedQueue的秘诀就在于大量使用了无锁的CAS操作。同理，如果我们使用CAS来实现生产者-消费者模式，也同样可以获得可观的性能提升。不过正如大家所见，使用CAS进行编程是非常困难的，但有一个好消息是，目前有一个现成的Disruptor框架，它已经帮助我们实现了这一个功能。 // Disruptor框架是由LMAX公司开发的一款高效的无锁内存队列。它使用无锁的方式实现了一个环形队列，非常适合于实现生产者和消费者模式，比如事件和消息的发布。在Disruptor中，别出心裁地使用了环形队列（RingBuffer）来代替普通线性队列，这个环形队列内部实现为一个普通的数组。对于一般的队列，势必要提供队列同步head和尾部tail两个指针，用于出队和入队，这样无疑就增加了线程协作的复杂度。但如果队列是环形的，则只需要对外提供一个当前位置cursor，利用这个指针既可以进入入队也可以进行出队操作。由于环形队列的缘故，队列的总大小必须事先指定，不能动态扩展。为了能够快速从一个序列（sequence）对应到数组的实际位置（每次有元素入队，序列就加1），Disruptor要求我们必须将数组的大小设置为2的整数次方。这样通过sequence &(queueSize-1)就能立即定位到实际的元素位置index。这个要比取余（%）操作快得多。 // 首先，我们还是需要一个代表数据的PCData： public class PCData { private long value; public void set(long value) { this.value = value; } public long get(){ return value; } } // 消费者实现为WorkHandler接口，它来自Disruptor框架 public class Consumer implements WorkHandler＜PCData＞ { @Override public void onEvent(PCData event) throws Exception { System.out.println(Thread.currentThread().getId() + \":Event: --\" + event.get() * event.get() + \"--\"); } } // 还需要一个产生PCData的工厂类。它会在Disruptor系统初始化时，构造所有的缓冲区中的对象实例 public class PCDataFactory implements EventFactory＜PCData＞ { public PCData newInstance() { return new PCData(); } } // 生产者 public class Producer { private final RingBuffer＜PCData＞ ringBuffer; public Producer(RingBuffer＜PCData＞ ringBuffer) { this.ringBuffer = ringBuffer; } public void pushData(ByteBuffer bb) { long sequence = ringBuffer.next(); // Grab the next sequence try { PCData event = ringBuffer.get(sequence); // Get the entry in the Disruptor // for the sequence event.set(bb.getLong(0)); // Fill with data } finally { ringBuffer.publish(sequence); } } } // 主函数 public static void main(String[] args) throws Exception { Executor executor = Executors.newCachedThreadPool(); PCDataFactory factory = new PCDataFactory(); // Specify the size of the ring buffer, must be power of 2. int bufferSize = ; Disruptor＜PCData＞ disruptor = new Disruptor＜PCData＞(factory, bufferSize, executor, ProducerType.MULTI, new BlockingWaitStrategy() ); disruptor.handleEventsWithWorkerPool( new Consumer(), new Consumer(), new Consumer(), new Consumer()); disruptor.start(); RingBuffer＜PCData＞ ringBuffer = disruptor.getRingBuffer(); Producer producer = new Producer(ringBuffer); ByteBuffer bb = ByteBuffer.allocate(8); for (long l = 0; true; l++) { bb.putLong(0, l); producer.pushData(bb); Thread.sleep(0); System.out.println(\"add data \"+l); } } 8:Event: --0-- add data 0 11:Event: --1-- add data 1 10:Event: --4-- add data 2 9:Event: --9-- add data 3 根据Disruptor的官方报告，Disruptor的性能要比BlockingQueue至少高一个数量级以上。 提高消费者的响应时间：选择合适的策略 当有新数据在Disruptor的环形缓冲区中产生时，消费者如何知道这些新产生的数据呢？或者说，消费者如何监控缓冲区中的信息呢？为此，Disruptor提供了几种策略，这些策略由WaitStrategy接口进行封装，主要有以下几种实现。 BlockingWaitStrategy：这是默认的策略。使用BlockingWaitStrategy和使用BlockingQueue是非常类似的，它们都使用锁和条件（Condition）进行数据的监控和线程的唤醒。因为涉及到线程的切换，BlockingWaitStrategy策略是最节省CPU，但是在高并发下性能表现最糟糕的一种等待策略。 SleepingWaitStrategy：这个策略也是对CPU使用率非常保守的。它会在循环中不断等待数据。它会先进行自旋等待，如果不成功，则使用Thread.yield()让出CPU，并最终使用LockSupport.parkNanos(1)进行线程休眠，以确保不占用太多的CPU数据。因此，这个策略对于数据处理可能产生比较高的平均延时。它比较适合于对延时要求不是特别高的场合，好处是它对生产者线程的影响最小。典型的应用场景是异步日志。 YieldingWaitStrategy：这个策略用于低延时的场合。消费者线程会不断循环监控缓冲区变化，在循环内部，它会使用Thread.yield()让出CPU给别的线程执行时间。如果你需要一个高性能的系统，并且对延时有较为严格的要求，则可以考虑这种策略。使用这种策略时，相当于你的消费者线程变身成为了一个内部执行了Thread.yield()的死循环。因此，你最好有多于消费者线程数量的逻辑CPU数量（这里的逻辑CPU，我指的是“双核四线程”中的那个四线程，否则，整个应用程序恐怕都会受到影响。 BusySpinWaitStrategy：这个是最疯狂的等待策略了。它就是一个死循环！消费者线程会尽最大努力疯狂监控缓冲区的变化。因此，它会吃掉所有的CPU资源。你只有在对延迟非常苛刻的场合可以考虑使用它（或者说，你的系统真的非常繁忙）。因为在这里你等同开启了一个死循环监控，所以，你的物理CPU数量必须要大于消费者线程数。注意，我这里说的是物理CPU，如果你在一个物理核上使用超线程技术模拟两个逻辑核，另外一个逻辑核显然会受到这种超密集计算的影响而不能正常工作。 CPU Cache的优化：解决伪共享问题 ​ 什么是伪共享问题呢？我们知道，为了提高CPU的速度，CPU有一个高速缓存Cache。在高速缓存中，读写数据的最小单位为缓存行（Cache Line），它是从主存（memory）复制到缓存（Cache）的最小单位，一般为32字节到128字节。 ​ 如果两个变量存放在一个缓存行中时，在多线程访问中，可能会相互影响彼此的性能。如图5.4所示，假设X和Y在同一个缓存行。运行在CPU1上的线程更新了X，那么CPU2上的缓存行就会失效，同一行的Y即使没有修改也会变成无效，导致Cache无法命中。接着，如果在CPU2上的线程更新了Y，则导致CPU1上的缓存行又失效（此时，同一行的X又变得无法访问）。这种情况反反复复发生，无疑是一个潜在的性能杀手。如果CPU经常不能命中缓存，那么系统的吞吐量就会急剧下降。 并行流水线 1. 借鉴《Java高并发程序设计》第5.6节 2. 计算(B+C)*B/2，那么这个运行过程就是无法并行的。原因是，如果B+C没有执行完成，则永远算不出(B+C)*B，这就是数据相关性。如果线程执行时，所需的数据存在这种依赖关系，那么，就没有办法将它们完美的并行化。 那遇到这种情况时，有没有什么补救措施呢？答案是肯定的，那就是借鉴日常生产中的流水线思想。 比如，现在要生产一批小玩偶。小玩偶的制作分为四个步骤，第一要组装身体，第二要在身体上安装四肢和头部，第三，给组装完成的玩偶穿上一件漂亮的衣服，第四，就可以包装出货了。为了加快制作玩具的进度，我们不可能叫四个人同时加工一个玩具，因为这四个步骤有着严重的依赖关系。如果没有身体，就没有地方安装四肢，如果没有组装完成，就不能穿衣服，如果没有穿上衣服，就不能包装发货。因此，找四个人来做一个玩偶是毫无意义的。 但是，如果你现在要制作的不是1只玩偶，而是1万只玩偶，那情况就不同了。你可以找四个人，第一个人只负责组装身体，完成后交给第二个人；第二个人只负责安装头部和四肢，交付第三人；第三人只负责穿衣服，并交付第四人；第四人只负责包装发货。这样所有人都可以一起工作，共同完成任务，而整个时间周期也能缩短到原来的1/4左右，这就是流水线的思想。一旦流水线满载，每次只需要一步（假设一个玩偶需要四步）就可以产生一个玩偶 类似的思想可以借鉴到程序开发中。即使(B+C)*B/2无法并行，但是如果你需要计算一大堆B和C的值，你依然可以将它流水化。首先将计算过程拆分为三个步骤： P1:A＝B+C P2:D＝A×B P3:D=D/2 上述步骤中P1、P2和P3均在单独的线程中计算，并且每个线程只负责自己的工作。此时，P3的计算结果就是最终需要的答案。 P1接收B和C的值，并求和，将结果输入给P2。P2求乘积后输入给P3。P3将D除以2得到最终值。一旦这条流水线建立，只需要一个计算步骤就可以得到(B+C)*B/2的结果。 // 为了实现这个功能，我们需要定义一个在线程间携带结果进行信息交换的载体： public class Msg { public double i; public double j; public String orgStr=null; } // P1计算的是加法： public class Plus implements Runnable { public static BlockingQueue＜Msg＞ bq=new LinkedBlockingQueue＜Msg＞(); @Override public void run() { while(true){ try { Msg msg=bq.take(); msg.j=msg.i+msg.j; Multiply.bq.add(msg); } catch (InterruptedException e) { } } } } // 上述代码中，P1取得封装了两个操作数的Msg，并进行求和，将结果传递给乘法线程P2（第9行）。当没有数据需要处理时，P1进行等待。 // P2计算乘法： public class Multiply implements Runnable { public static BlockingQueue＜Msg＞ bq = new LinkedBlockingQueue＜Msg＞(); @Override public void run() { while (true) { try { Msg msg = bq.take(); msg.i = msg.i * msg.j; Div.bq.add(msg); } catch (InterruptedException e) { } } } } //和P1非常类似，P2计算相乘结果后，将中间结果传递给除法线程P3。 //P3计算除法： public class Div implements Runnable { public static BlockingQueue＜Msg＞ bq = new LinkedBlockingQueue＜Msg＞(); @Override public void run() { while (true) { try { Msg msg = bq.take(); msg.i = msg.i / 2; System.out.println(msg.orgStr + \"=\" + msg.i); } catch (InterruptedException e) { } } } } // P3将结果除以2后输出最终的结果。 // 最后是提交任务的主线程，这里，我们提交0万个请求，让线程组进行计算： public class PStreamMain { public static void main(String[] args) { new Thread(new Plus()).start(); new Thread(new Multiply()).start(); new Thread(new Div()).start(); for (int i = 1; i ＜= ; i++) { for (int j = 1; j ＜= ; j++) { Msg msg = new Msg(); msg.i = i; msg.j = j; msg.orgStr = \"((\" + i + \"+\" + j + \")*\" + i + \")/2\"; Plus.bq.add(msg); } } } } 上述代码第行，将数据提交给P1加法线程，开启流水线的计算。在多核或者分布式场景中，这种设计思路可以有效地将有依赖关系的操作分配在不同的线程中进行计算，尽可能利用多核优势。 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/IDEA快捷键.html":{"url":"chapters/IDEA快捷键.html","title":"IDEA快捷键","keywords":"","body":"自动代码查询快捷键其他快捷键svn快捷键调试快捷键重构IDEA异常处理idea 源发行版 8 需要目标发行版 1.8十大Intellij IDEA快捷键智能提示重构代码生成编辑查找打开其他辅助 [TOC] 参考: https://mp.weixin.qq.com/s/r70Q0eqy5-R1CrwihREeQA （IntelliJ IDEA 快捷键终极大全，速度收藏！） 自动代码 常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。 例如要输入for(User user : users)只需输入user.for+Tab ； 再比如，要输入Date birthday = user.getBirthday()只需输入user.getBirthday().var+Tab即可。 代码标签输入完成后，按Tab，生成代码。 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate） fori/sout/psvm + Tab Ctrl+Alt+T 生成try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+J 自动代码 Ctrl+Shift+J，整合两行为一行 CTRL+空格 代码提示 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q，可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 查询快捷键 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 CTRL+ALT+ left/right 前后导航编辑过的地方 ALT+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Shift+Alt+N 查找类中的方法或变量 双击SHIFT 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源 CTRL+SHIFT+O 弹出显示查找内容 Ctrl+W 选中代码，连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/*...*/ ） Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 Alt+6 查找TODO 其他快捷键 SHIFT+ENTER 另起一行 CTRL+Z 倒退(撤销) CTRL+SHIFT+Z 向前(取消撤销) CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+F4 关闭当前窗口 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） svn快捷键 ctrl+k 提交代码到SVN ctrl+t 更新代码 调试快捷键 其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。推荐：Intellij IDEA Debug 调试技巧。 alt+F8 debug时选中查看值 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F8，查看断点 F7，步入 Shift+F7，智能步入 Alt+Shift+F7，强制步入 F8，步过 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 重构 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 IDEA异常处理 idea 源发行版 8 需要目标发行版 1.8 1，Project Structure里确认两个地方:Project sdk以及project language level 2，Project Structure->Modules里Sources里的Language level 3，settings->java Compiler ->target bytecode Version 这些个地方需要一致。 十大Intellij IDEA快捷键 Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 智能提示 Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。推荐：Intellij Idea非常6的10个姿势！ 用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 重构 Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。推荐： Intellij IDEA 那些隐藏好用的小技巧 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。 此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。关注Java技术栈微信公众号，在后台回复关键字：IDEA，可以获取一份栈长整理的 IDEA 最新技术干货。 代码生成 这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。 后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 编辑 编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。 另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 推荐：Intellij IDEA 撸码最头大的问题。 查找打开 类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 关注Java技术栈微信公众号，在后台回复关键字：IDEA，可以获取一份栈长整理的 IDEA 最新技术干货。 其他辅助 以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建：Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试：Ctrl+Alt+T创建单元测试用例。 Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试：F7/F8/F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Spring注解_介绍.html":{"url":"chapters/Spring注解_介绍.html","title":"Spring注解_介绍","keywords":"","body":"Java中的注解到底是如何工作的？什么是注解？为什么要引入注解？编写自定义的Annotation注解用例ADF(应用程序框架)和注解 [TOC] Java中的注解到底是如何工作的？ Java中的注解到底是如何工作的？ Java 必须掌握的 12 种 Spring 常用注解！ java中的注解，真的很重要，你理解了嘛 自Java5.0版本引入注解之后，它就成为了Java平台中非常重要的一部分。开发过程中，我们也时常在应用代码中会看到诸如@Override，@Deprecated这样的注解。 这篇文章中，我将向大家讲述到底什么是注解，为什么要引入注解，注解是如何工作的，如何编写自定义的注解(通过例子)，什么情况下可以使用注解以及最新注解和ADF(应用开发框架)。这会花点儿时间，所以为自己准备一杯咖啡，让我们来进入注解的世界吧。 https://www.zhihu.com/question/64671972 Spring和SpringBoot比较，解惑区别 用Spring Boot颠覆Java应用开发 什么是注解？ 用一个词就可以描述注解，那就是元数据，即一种描述数据的数据。所以，可以说注解就是源代码的元数据。比如，下面这段代码： @Override public String toString() { return \"This is String Representation of current object.\"; } 上面的代码中，我重写了toString()方法并使用了@Override注解。但是，即使我不使用@Override注解标记代码，程序也能够正常执行。 那么，该注解表示什么？这么写有什么好处吗？事实上，@Override告诉编译器这个方法是一个重写方法(描述方法的元数据)，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。 如果我不小心拼写错误，例如将toString()写成了toStrring(){double r}，而且我也没有使用@Override注解，那程序依然能编译运行。但运行结果会和我期望的大不相同。现在我们了解了什么是注解，并且使用注解有助于阅读程序。推荐阅读：Spring MVC常用注解，你会几个？ Annotation是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述元数据的一种工具。 为什么要引入注解？ 使用Annotation之前(甚至在使用之后)，XML被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现XML的维护越来越糟糕了。 他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。 如果你在Google中搜索“XML vs. annotations”，会看到许多关于这个问题的辩论。最有趣的是XML配置其实就是为了分离代码和配置而引入的。 上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。 假如你想为应用设置很多的常量或参数，这种情况下，XML是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用Annotation会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。 另一个很重要的因素是Annotation定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记interfaces，注释，transient关键字等等。每个程序员按照自己的方式定义元数据，而不像Annotation这种标准的方式。 目前，许多框架将XML和Annotation两种方式结合使用，平衡两者之间的利弊。 编写自定义的Annotation 在讲述这部分之前，建议你首先下载Annotation的示例代码AnnotationsSample.zip 。下载之后放在你习惯使用的IDE中，这些代码会帮助你更好的理解Annotation机制。 推荐阅读：Java 必须掌握的 12 种 Spring 常用注解！ 编写Annotation非常简单，可以将Annotation的定义同接口的定义进行比较。我们来看两个例子：一个是标准的注解@Override，另一个是用户自定义注解@Todo。 @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 对于@Override注释你可能有些疑问，它什么都没做，那它是如何检查在父类中有一个同名的函数呢。当然，不要惊讶，我是逗你玩的。 @Override注解的定义不仅仅只有这么一点代码。这部分内容很重要，我不得不再次重复：Annotations仅仅是元数据，和业务逻辑无关。 理解起来有点困难，但就是这样。如果Annotations不包含业务逻辑，那么必须有人来实现这些逻辑。元数据的用户来做这个事情。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息。Annotations的用户(同样是一些代码)来读取这些信息并实现必要的逻辑。 当我们使用Java的标注Annotations(例如@Override)时，JVM就是一个用户，它在字节码层面工作。到这里，应用开发人员还不能控制也不能使用自定义的注解。因此，我们讲解一下如何编写自定义的Annotations。 我们来逐个讲述编写自定义Annotations的要点。上面的例子中，你看到一些注解应用在注解上。 J2SE5.0版本在 java.lang.annotation提供了四种元注解，专门注解其他的注解： @Documented – 注解是否将包含在JavaDoc中 @Retention – 什么时候使用该注解 @Target? – 注解用于什么地方 @Inherited – 是否允许子类继承该注解 @Documented–一个简单的Annotations标记注解，表示是否将注解信息添加在java文档中。 @Retention– 定义该注解的生命周期。 RetentionPolicy.SOURCE – 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 RetentionPolicy.CLASS – 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。 RetentionPolicy.RUNTIME – 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 @Target – 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方。 需要说明的是：属性的注解是兼容的，如果你想给7个属性都添加注解，仅仅排除一个属性，那么你需要在定义target包含所有的属性。 ElementType.TYPE:用于描述类、接口或enum声明 ElementType.FIELD:用于描述实例变量 ElementType.METHOD ElementType.PARAMETER ElementType.CONSTRUCTOR ElementType.LOCAL_VARIABLE ElementType.ANNOTATION_TYPE 另一个注释 ElementType.PACKAGE 用于记录java文件的package信息 @Inherited – 定义该注释和子类的关系 那么，注解的内部到底是如何定义的呢？Annotations只支持基本类型、String及枚举类型。注释中所有的属性被定义成方法，并允许提供默认值。 指定子类可以继承父类的注解，只能是类上的注解，方法和字段的注解不能继承。即如果父类上的注解是@Inherited修饰的就能被子类继承。 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Todo { public enum Priority {LOW, MEDIUM, HIGH} public enum Status {STARTED, NOT_STARTED} String author() default \"Yash\"; Priority priority() default Priority.LOW; Status status() default Status.NOT_STARTED; } 下面的例子演示了如何使用上面的注解。 @Todo(priority = Todo.Priority.MEDIUM, author = \"Yashwant\", status = Todo.Status.STARTED) public void incompleteMethod1() { //Some business logic is written //But it’s not complete yet } 如果注解中只有一个属性，可以直接命名为“value”，使用时无需再标明属性名。 @interface Author{ String value(); } @Author(\"Yashwant\") public void someMethod() { } 但目前为止一切看起来都还不错。我们定义了自己的注解并将其应用在业务逻辑的方法上。现在我们需要写一个用户程序调用我们的注解。这里我们需要使用反射机制。如果你熟悉反射代码，就会知道反射可以提供类名、方法和实例变量对象。 所有这些对象都有getAnnotation()这个方法用来返回注解信息。我们需要把这个对象转换为我们自定义的注释(使用 instanceOf()检查之后)，同时也可以调用自定义注释里面的方法。看看以下的实例代码，使用了上面的注解: Class businessLogicClass = BusinessLogic.class; for(Method method : businessLogicClass.getMethods()) { 　　Todo todoAnnotation = (Todo)method.getAnnotation(Todo.class); 　　if(todoAnnotation != null) { 　　　　System.out.println(\" Method Name : \" + method.getName()); 　　　　System.out.println(\" Author : \" + todoAnnotation.author()); 　　　　System.out.println(\" Priority : \" + todoAnnotation.priority()); 　　　　System.out.println(\" Status : \" + todoAnnotation.status()); 　　} } jdk1.8又提供了以下两个元注解 @Native 指定字段是一个常量，其值引用native code。 @Repeatable 注解上可以使用重复注解，即可以在一个地方可以重复使用同一个注解，像spring中的包扫描注解就使用了这个。 所有元注解定义在java.lang.annotation包下面，其中Annotation是注解的基本接口，所有的注解都继承这个接口 自定义注解： 　　使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 　　定义注解格式： public @interface 注解名 {定义体} 　　注解参数的可支持数据类型： 所有基本数据类型（int,float,boolean,byte,double,char,long,short) String类型 Class类型 enum类型 Annotation类型 以上所有类型的数组 　　Annotation类型里面的参数该怎么设定: 第一, 只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　 第二, 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;　　 第三, 如果只有一个参数成员,最好把参数名称设为\"value\",后加小括号.例:下面的注解就只有一个参数成员，是一个String数组。 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Entrance { String[] value() default {}; } 注解元素的默认值： 　　注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Entrance { public String name() default \"\"; } 注解用例 注解的功能很强大，Spring和Hebernate这些框架在日志和有效性中大量使用了注解功能。注解可以应用在使用标记接口的地方。不同的是标记接口用来定义完整的类，但你可以为单个的方法定义注释，例如是否将一个方法暴露为服务。推荐阅读：Spring Boot 最核心的 25 个注解，都是干货！ 在最新的servlet3.0中引入了很多新的注解，尤其是和servlet安全相关的注解。 HandlesTypes –该注解用来表示一组传递给ServletContainerInitializer的应用类。 HttpConstraint – 该注解代表所有HTTP方法的应用请求的安全约束，和ServletSecurity注释中定义的HttpMethodConstraint安全约束不同。 HttpMethodConstraint – 指明不同类型请求的安全约束，和ServletSecurity 注解中描述HTTP协议方法类型的注释不同。 MultipartConfig –该注解标注在Servlet上面，表示该Servlet希望处理的请求的 MIME 类型是 multipart/form-data。 ServletSecurity 该注解标注在Servlet继承类上面，强制该HTTP协议请求遵循安全约束。 WebFilter – 该注解用来声明一个Server过滤器； WebInitParam – 该注解用来声明Servlet或是过滤器的中的初始化参数，通常配合 @WebServlet 或者 @WebFilter 使用。 WebListener –该注解为Web应用程序上下文中不同类型的事件声明监听器。 WebServlet –该注解用来声明一个Servlet的配置。 ADF(应用程序框架)和注解 现在我们开始讨论文章的最后一部分了。应用程序框架，被称为ADF，由Oracle开发用来创建Oracle融合应用。我们已经了解了注解的优缺点，也知道如何编写自定义的注解，但我们应该将注解应用在ADF的哪部分呢？ADF是否提供了一些朴素的注解？ 很好的问题，确实在ADF中大量使用注解有一些限制。之前提到的应用框架如Spring和Hibernate使用AOP(面向侧面的程序设计)。在AOP中，框架提供了一种机制，在事件的预处理和后续处理中注入代码。 例如：你有一个钩子用来在方法执行之前和之后添加代码，所以你可以在这些地方编写你的用户代码。ADF不使用AOP。如果我们有任何注解的用例可用，我们可能需要通过继承的方式实现。 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Spring注解_常用注解.html":{"url":"chapters/Spring注解_常用注解.html","title":"Spring注解_常用注解","keywords":"","body":"12种 Spring 常用注解声明bean的注解注入bean的注解java配置类相关注解切面(AOP)相关注解@Bean的属性支持@Value注解环境切换异步相关定时任务相关@Enable*注解说明测试相关注解SpringMVC相关注解spring 三种装配机制 [TOC] 12种 Spring 常用注解 声明bean的注解 @Component 组件，没有明确的角色 @Service 在业务逻辑层使用（service层） @Repository 在数据访问层使用（dao层） @Controller 在展现层使用，控制器的声明（Controller层） 注入bean的注解 ANNOTATION PACKAGE SOURCE @Resource javax.annotation Java JSR-250 @Inject javax.inject Java JSR-330 @Autowired org.springframework.bean.factory Spring 2.5+ JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。 @Resource,@Autowired,@Inject3种注入方式详解 @Autowired：由Spring提供 默认按类型装配，找不到或者找到多个则报错。 如果要按名称装配，需要结合Spring另外一个注解Qualifier(\"name\")使用。 默认必须装配requred=true，如果可以为空，可以设置为false，在Spring4+结合jdk8+的情况下还可以使用Optional和false同等的效果，如 @Autowired private Optional userService; @Inject：由JSR-330提供 和@Autowired类似，可以完全代替@Autowired，但这个没有required属性，要求bean必须存在。 如果要按名称装配，需要结合javax另外一个注解N(\"name\")使用。 @Resource：由JSR-250提供 它有两个关键的属性：name－名称，type－类型 1、如果指定了name,type，则从Spring容器中找一个名称和类型相当应的一个bean，找不到则报错。 2、如果只指定了name，则从Spring容器中找一个名称和name一样的bean，找不到则报错。 3、如果只指定了type，则从Spring容器中找一个类型和type一样的bean，找不到或者找到多个则报错。 4、如果没有指定参数，则默认找字段名称装配，找不到则按类型装配，找不到则报错。 都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。 Spring常用的三种注入方式 Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：构造方法注入，setter注入，基于注解的注入。 1. 构造方法注入 在spring的配置文件中注册UserService，将UserDaoJdbc通过constructor-arg标签注入到UserService的某个有参数的构造方法 如果只有一个有参数的构造方法并且参数类型与注入的bean的类型匹配，那就会注入到该构造方法中。 public class UserService implements IUserService { private IUserDao userDao; public UserService(IUserDao userDao) { this.userDao = userDao; } public void loginUser() { userDao.loginUser(); } } 问题一：如果有多个有参数的构造方法并且每个构造方法的参数列表里面都有要注入的属性，那userDaoJdbc会注入到哪里呢？ public class UserService implements IUserService { private IUserDao userDao; private User user; public UserService(IUserDao userDao) { System.out.println(\"这是有一个参数的构造方法\"); this.userDao = userDao; } public UserService(IUserDao userDao, User user) { System.out.println(\"这是有两个参数的构造方法\"); this.userDao = userDao; this.user = user; } public void loginUser() { userDao.loginUser(); } } 结果：会注入到只有一个参数的构造方法中，并且经过测试注入哪一个构造方法与构造方法的顺序无关 问题二：如果只有一个构造方法，但是有两个参数，一个是待注入的参数，另一个是其他类型的参数，那么这次注入可以成功吗？ public class UserService implements IUserService { private IUserDao userDao; private User user; public UserService(IUserDao userDao, User user) { this.userDao = userDao; this.user = user; } public void loginUser() { userDao.loginUser(); } } 结果：失败了，即使在costract-arg标签里面通过name属性指定要注入的参数名userDao也会失败. 问题三：如果我们想向有多个参数的构造方法中注入值该在配置文件中怎么写呢？ public class UserService implements IUserService { private IUserDao userDao; private User user; public UserService(IUserDao userDao, User user) { this.userDao = userDao; this.user = user; } public void loginUser() { userDao.loginUser(); } } 参考写法：通过name属性指定要注入的值，与构造方法参数列表参数的顺序无关 问题四：如果有多个构造方法，每个构造方法只有参数的顺序不同，那通过构造方法注入多个参数会注入到哪一个呢？ public class UserService implements IUserService { private IUserDao userDao; private User user; public UserService(IUserDao userDao, User user) { System.out.println(\"这是第二个构造方法\"); this.userDao = userDao; this.user = user; } public UserService(User user, IUserDao userDao) { System.out.println(\"这是第一个构造方法\"); this.userDao = userDao; this.user = user; } public void loginUser() { userDao.loginUser(); } } 结果：哪个构造方法在前就注入哪一个，这种情况下就与构造方法顺序有关。 2. setter方法注入 配置文件如下： --> 注：上面这两种写法都可以,spring会将name值的每个单词首字母转换成大写，然后再在前面拼接上”set”构成一个方法名,然后去对应的类中查找该方法,通过反射调用,实现注入。 切记：name属性值与类中的成员变量名以及set方法的参数名都无关，只与对应的set方法名有关，下面的这种写法是可以运行成功的 public class UserService implements IUserService { private IUserDao userDao1; public void setUserDao(IUserDao userDao1) { this.userDao1 = userDao1; } public void loginUser() { userDao1.loginUser(); } } 还有一点需要注意：如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错。 3. 基于注解的注入 @Resource：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。 @Resource @Qualifier(\"userDaoMyBatis\") private IUserDao userDao; public UserService(){} @Resource装配顺序 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配 @Autowired：spring注解，默认是以byType的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byName的方式去查找。 @Autowired @Qualifier(\"userDaoJdbc\") private IUserDao userDao; java配置类相关注解 @Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上） @Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上） @Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上） @ComponentScan 用于对Component进行扫描，相当于xml中的（类上） @WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解 切面(AOP)相关注解 Spring支持AspectJ的注解式切面编程。 @Aspect 声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。 @After 在方法执行之后执行（方法上） @Before 在方法执行之前执行（方法上） @Around 在方法执行之前与之后执行（方法上） @PointCut 声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上） @Bean的属性支持 @Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean） 其设置类型包括： Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）, Protetype （每次调用新建一个bean）, Request （web项目中，给每个http request新建一个bean）, Session （web项目中，给每个http session新建一个bean）, GlobalSession（给每一个 global http session新建一个Bean实例） @StepScope 在Spring Batch中还有涉及 @PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod @PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod @Value注解 @Value 为属性注入值（属性上） 支持如下方式的注入： 》注入普通字符 @Value(\"Michael Jackson\")String name; 》注入操作系统属性 @Value(\"#{systemProperties['os.name']}\")String osName; 》注入表达式结果 @Value(\"#{ T(java.lang.Math).random() * 100 }\") String randomNumber; 》注入其它bean属性 @Value(\"#{domeClass.name}\")String name; 》注入文件资源 @Value(\"classpath:com/hgs/hello/test.txt\")String Resource file; 》注入网站资源 @Value(\"http://www.javastack.cn\")Resource url; 》注入配置文件 Value(\"${book.name}\")String bookName; 注入配置使用方法： ① 编写配置文件（test.properties） book.name=《三体》 ② @PropertySource 加载配置文件(类上) @PropertySource(\"classpath:com/hgs/hello/test/test.propertie\") ③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。 环境切换 @Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上） @Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上） 异步相关 @EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上），点击这里了解使用详情。 @Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务） 定时任务相关 @EnableScheduling 在配置类上使用，开启计划任务的支持（类上） @Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持） @Enable*注解说明 这些注解主要用来开启对xxx的支持。 @EnableAspectJAutoProxy 开启对AspectJ自动代理的支持 @EnableAsync 开启异步方法的支持 @EnableScheduling 开启计划任务的支持 @EnableWebMvc 开启Web MVC的配置支持 @EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持 @EnableJpaRepositories 开启对SpringData JPA Repository的支持 @EnableTransactionManagement 开启注解式事务的支持 @EnableTransactionManagement 开启注解式事务的支持 @EnableCaching 开启注解式的缓存支持 测试相关注解 @RunWith 运行器，Spring中通常用于对JUnit的支持 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类 @ContextConfiguration(classes={TestConfig.class}) SpringMVC相关注解 @EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。 @Controller 声明该类为SpringMVC中的Controller @RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上） @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上） @RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前） @PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。 @RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。 @ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， 这对所有注解了 @RequestMapping的控制器内的方法有效。 @ExceptionHandler 用于全局处理控制器里的异常 @InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。 @ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。 spring 三种装配机制 隐式的自动装配bean 在《Spring实战》这本书中将自动装配分为了两个部分（组件扫描和自动装配）： 组件扫描：Spring会自动发现应用上下文（Spring容器）中所创建的bean； 自动装配：Spring自动满足bean之间的依赖 1、创建可被发现的bean package soundsystem; public interface CompactDisc{ void play(); } 创建带有@Component注解的CompactDisc接口的一个实现类，这个类会被Spring扫描到并自动创建bean package soundsystem; import ... @Component public class SgtPeppers implements CompactDisc{ private String title = \"Sgt, Pepper's Lonely Hearts Club Band\"; private String artist = \"The Beatles\"; public void play(){ System.out.println(\"Playing \" + title + \" By \" + artist); } } 使用@ComponentScan注解启动组件扫描，@ComponentScan 默认会扫描与配置类相同的包以及其下所有的子包，这样，被@Component注解修饰的类就会被发现 package soundsystem; import ... @Configuration @ComponentScan public class CDPlayerConfig{} 也可以使用XML配置的方式来启动组件扫描 2、为组件扫描的 bean 命名 若直接使用 @Component 注解来声明一个 bean，bean 的名字默认为类名首字母小写。 例如，如下 SgtPeppers 类的默认 bean 名称为 sgtPeppers @Component() public class SgtPeppers implements CompactDisc{ ... } 可以在 @Component 注解中说明此 bean 的名称： @Component(\"lonelyHeartClub\") public class SgtPeppers implements CompactDisc{ ... } 此外，也可以使用另外一种为 bean 命名的方式： package soundsystem; import javax.inject.Named; @Named(\"lonelyHeartClub\") public class SgtPeppers implements CompactDisc{ ... } Spring 支持将 @Named 作为 @Component 注解的替代方案，两者之间有一些细微的差异，但在大多数场景下，它们是可以相互替换的。 推荐使用 @Component 注解，因为 @Named 注解并不能清楚的表明它是做什么的 3、设置组件扫描的基础包 在之前的案列中，我们没有为 @ComponentScan 注解设置任何属性，这意味着，按照默认规则，它会以配置类所在包作为基础包（ base package ）来扫描组件. 在之前的案列中，我们没有为 @ComponentScan 注解设置任何属性，这意味着，按照默认规则，它会以配置类所在包作为基础包（ base package ）来扫描组件. 有一个原因会促使我们要明确的设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。 为了指定不同的包，只需要在 @ComponentScan 的 value 属性中指明包的名称： @Configuration @ComponentScan(\"soundsystem\") public class CDPlayerConfig{} 或者，如果你想更加明确的表名你所设置的是基础包，那么你可以通过 basePackages 属性进行配置： @Configuration @ComponentScan(basePackages=\"soundsystem\") public class CDPlayerConfig{} 如果你想扫描多个包，只需要将 basePackages 属性的值设置为要扫描包的一个数组即可： @Configuration @ComponentScan(basePackages={\"soundsystem\",\"video\"}) public class CDPlayerConfig{} 注意到，basePackages 属性的值是一个 String 类型的数组，这样配置没有问题，但却是不安全的，如果要重构代码的话，这些包的名字可能会被修改，从而导致包扫描出现错误，除了将包设置为简单的 String 类型之外，@ComponentScan 还提供了另一种方法，那就是将其指定为要扫描包中所含的类或接口。 @Configuration @ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class}) public class CDPlayerConfig{} 你可以在包中设置一个专门用来进行包扫描的空标记接口，这样，可以避免对任何实际应用的代码进行重构后，包扫描出现错误。 4、通过为 bean 添加注解实现自动装配 如果我们的应用程序所有对象都是独立的， 彼此之间没有任何依赖，那么仅仅使用Spring的扫描功能就算完事了,它会自动的帮我们把Java对象创建.但是如果对象与对象之间如果存在相互依赖的联系时,我们就需要用的Spring给我们提供的自动装配了. @Component public class CDPlayer implements MediaPlayer{ private CompactDisc cd; @Autowired public CDPlayer(CompacrDisc cd){ this.cd = cd; } public void play(){ cd.play(); } } 以上示例的构造器上添加了 @Autowired 注解，这表明当 Spring 创建 CDPlayer bean 的时候，会通过这个构造器进行实例化并传入一个 CompactDisc 类型的 bean。 @Autowired 注解不仅能够用在构造器上，还可以用在属性设置的 Setter 方法上。 实际上，Setter 方法并没有什么特殊之处，@Autowired 注解可以用在类的任何方法上：如下，@Autowired 注解完全能够发挥作用 @Autowired public void insertDisc(CompactDisc cd){ this.cd = cd; } 不管是构造器、Setter 方法还是其他方法，Spring 都会尝试满足方法参数上所声明的依赖，假如有且仅有一个 bean 依赖需求的话，那么这个 bean 就会被装填进来。 如果没有匹配的 bean，那么在应用上下文创建的时候，Spring 会抛出一个异常。为了避免异常的出现，你可以将 @Autowired 的 required 属性设置为 false： @Autowired(required=false) public CDPlayer(CompactDisc cd){ this.cd = cd; } 如果有多个 bean 都能满足依赖关系的话，Spring 也将会抛出一个异常，表明没有明确指定要选择那个 bean 进行装配。 总结一下，自动装配bean的过程： 一、把需要被扫描的类，添加 @Component注解，使它能够被Spring自动发现。 二、通过显示的设置Java代码 @ComponentScan注解或XML配置，让Spring开启组件扫描，并将扫描的结果类创建bean。 三、@Autowried注解能偶实现bean的自动装配，实现依赖注入。 处理自动装配的歧义性问题，Spring. 处理自动装配的歧义性 通过java代码装配bean 通XML中装配bean Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Spring注解_Spring入门篇.html":{"url":"chapters/Spring注解_Spring入门篇.html","title":"Spring注解_Spring入门篇","keywords":"","body":"Spring入门篇概述Spring IOC容器接口及面向接口编程Bean容器初始化Spring的常用注入方式Spring Bean装配Bean的生命周期Aware接口Bean的自动装配Bean的ResourcesBean的定义及作用域Autowired注解说明@Qualifier注解基于Java的容器注解基于泛型的装配JSR支持说明Spring AOP基本概念AOP基本概念和特点配置切面和切入点Advice应用Introduction应用Advisors [TOC] Spring入门篇 那些年，让我们一起着迷的Spring http://spring.io https://spring.io/projects/spring-framework 概述 spring是一个开源框架，是一个轻量级的控制反转(IOC)和面向切面（AOP)的容器框架 -从大小与开销两方面而言Spring都是轻量的 -通过控制反转（IoC）的技术达到松耦合的目的 -提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发 -包含并管理应用对象的配置和生命周期，这个意义上是一种容器 -将简单的组件配置、组合成为复杂的应用，这个意义上是框架 Java 程序员必须掌握的 5 个注解！ Spring作用 容器 · 提供了对多种技术的支持 -JMS -MQ支持 -UnitTest AOP（事务管理、日志等） · 提供了众多方便应用的辅助类（JDBC Template等） · 对主流应用框架（Hibernate等）提供了良好的支持 适用范围 构建企业应用（SpringMVC+Spring+Hibernate/ibatis) 单独使用Bean容器（Bean管理） 单独使用AOP进行切面处理 其他的Spring功能，如：对消息的支持等 在互联网中的应用 什么是框架 ·框架的特点 -半成品 -封装了特定的处理流程和控制逻辑 -成熟的、不断升级改进的软件 ·框架与类库的区别 -框架一般是封装了逻辑、高内聚的，类库则是松散的工具组合 -框架专注于某一领域，类库则是更通用的 为什么使用框架 ·软件系统日趋复杂 ·重用度高，开发效率和质量提高 ·软件设计人员要专注于对领域的了解，使需求分析更充分 ·易于上手、快速解决问题 Spring IOC容器 接口及面向接口编程 接口 ·用于沟通的中介物的抽象化 ·实体把自己提供给外界的一种抽象化说明，用以由内部操作分 离出外部沟通方法，使其能被修改内部而不影响外界其他实体 与其交互的方式 ·对应Java接口即声明，声明了哪些方法是对外公开提供的 ·在Java8中，接口可以拥有方法体 面向接口编程 结构设计中，分清层次及调用关系，每层只向外（上层）提供 一组功能接口，各层间仅依赖接口而非实现类 接口实现的变动不影响各层间的调用，这一点在公共服务中尤为重要 “面向接口编程”中的“接口”是用于隐藏具体实现和实现多态性的组件 什么是IOC IOC:控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护 DI（依赖注入）是其一种实现方式 目的：创建对象并且组装对象之间的关系 扩展理解 2004年，Martin Fowler探讨了同一个问题，既然IOC是控制 反转，那么到底是“哪些方面的控制被反转了呢？”，经过详 细地分析和论证后，他得出了答案：“获得依赖对象的过程被 反转了”。控制被反转之后，获得依赖对象的过程由自身管理 变为了由IOC容器主动注入。于是，他给“控制反转”取了一 个更合适的名字叫做“依赖注入（Dependency Injection) \"。他的这个答案，实际上给出了实现IOC的方法：注入。所 谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖 关系注入到对象之中。 单元测试 下载junit-*.jar并引入工程 创建UnitTestBase类，完成对Spring配置文件的加载、销毁 所有的单元测试类都继承自UnitTestBase，通过它的 getBean方法获取想要得到的对象 子类（具体执行单元测试的类）加注解： @RunWith(BlockJUnit4ClassRunner.class) 单元测试方法加注解：@Test 右键选择要执行的单元测试方法执行或者执行一个类的全部单 元测试方法 Bean容器初始化 基础：两个包 -org.springframework.beans -org.springframework.context -BeanFactory提供配置结构和基本功能，加载并初始化Bean -ApplicationContext保存了Bean对象并在Spring中被广泛使用 方式，ApplicationContext -本地文件 -Classpath -Web应用中依赖servlet或Listener Bean容器初始化 ·文件 FileSystemXmlApplicationContext context= new FileSystemXmlApplicationContext(\"F:/workspace/appcontext.xml\"); ·Classpath caspatxnlApplicstionc ontext context= new ClaspathxmlAplicationcontextrclasspathispring-contextxml); .Web应用 org.springframework.web.context.ContextLoaderListener context org.springframework.web.context.ContextLoaderServlet 1 Spring的常用注入方式 Spring注入 Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为 常用的两种注入方式 -设值注入 import com.imooc.ioc.injection.dao.InjectionDAO; public class InjectionServicelmpl implements InjectionService{ private InjectionDAO injectionDAO; //设值注入 public void setlnjectionDAO(InjectionDAO injectionDAO) { this.injectionDAO=injectionDAO; } public void save(String arg) { //模拟业务操作 System.outprintin(CService接收参数：+arg); arg=arg +\":\"+this.hashCode0; injectionDAO.save(arg); } } ​ -构造注入 I import com.imooc.ioc.injection.dao.InjectionDAO; public class InjectionServicelmpl implements InjectionService{ private InjectionDAO injectionDAO; //构造器注入 public InjectionServicelmpl(InjectionDAO injectionDAO) { this.injectionDAO=injectionDAO; } public void save(String arg) { //模拟业务操作 System.outprintin(CService接收参数：+arg); arg=arg +\":\"+this.hashCode0; injectionDAO.save(arg); } } Spring Bean装配 Bean装配，从Spring到Spring Boot Bean配置项 Class Scope Constructor arguments Properties Autowiring mode lazy-initialization mode Initialization/destruction method Bean的作用域 singleton:单例，指一个Bean容器中只存在一份 prototype：每次请求（每次使用）创建新的实例，destroy 方式不生效 request:每次http请求创建一个实例且仅在当前request内 有效 session:同上，每次http请求创建，当前session内有效 global session:基于portlet的web中有效（portlet定义了 global session),如果是在web中，同session Bean的生命周期 生命周期 -定义 -初始化 -实现org.springframework.beans.factory.InitializingBean接口 ，覆盖afterPropertiesSet方法 public class ExamplelnitializingBean implements InitializingBean{ @Override public void afterPropertiesSet0 throws Exception{ //do something } } -配置init-method public class ExampleBean { public void init(){ //do some initialization work } } -使用 -销毁 -实现org.springframework.beans.factory.DisposableBean接口 ，覆盖destroy方法 public class ExampleDisposableBean implements DisposableBean{ @Override public void destroy0 throws Exception{ //do something } } 配置destroy-method public class ExampleBean { public void cleanup(){ //do some destruction work (like releasing pooled connections) } } 配置全局默认初始化、销毁方法 优先顺序 InitializingBean和DisposableBean(定义完需实现) 配置init-method和destroy-method(定义完需实现) 默认(可选) Aware接口 Spring中提供了一些以Aware结尾的接口，实现了Aware接 口的bean在被初始化之后，可以获取相应资源 通过Aware接口，可以对Spring相应资源进行操作（一定要慎 重） 为对Spring进行简单的扩展提供了方便的入口 Spring中的aware接口 import org.springframework.beans.BeansException; import org.springframework.beans.factory.BeanNameAware; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; public class MoocBeanName implements BeanNameAware, ApplicationContextAware { private String beanName; @Override public void setBeanName(String name) { this.beanName = name; System.out.println(\"MoocBeanName : \" + name); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(\"setApplicationContext : \" + applicationContext.getBean(this.beanName).hashCode()); } } Bean的自动装配 Bean的自动装配（Autowiring) No:不做任何操作 byName:根据属性名自动装配。此选项将检查容器并根据名字 查找与属性完全一致的bean，并将其与属性自动装配 public class AutoWiringDAO { public void say(String word) { System.out.println(\"AutoWiringDAO : \" + word); } } public class AutoWiringService { private AutoWiringDAO autoWiringDAO; public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) { System.out.println(\"setAutoWiringDAO\"); this.autoWiringDAO = autoWiringDAO; } public void say(String word) { this.autoWiringDAO.say(word); } } byType:如果容器中存在一个与指定属性类型相同的bean，那 么将与该属性自动装配；如果存在多个该类型bean，那么抛出 异常，并指出不能使用byType方式进行自动装配；如果没有找 到相匹配的bean，则什么事都不发生 Constructor:与byType方式类似，不同之处在于它应用于构造器参数。如果容器中没有找到与构造器参数类型一致的bean，那么抛出异常 public class AutoWiringService { private AutoWiringDAO autoWiringDAO; public AutoWiringService(AutoWiringDAO autoWiringDAO) { System.out.println(\"AutoWiringService\"); this.autoWiringDAO = autoWiringDAO; } public void say(String word) { this.autoWiringDAO.say(word); } } Bean的Resources 针对于资源文件的统一接口Resources -UrlResource：URL对应的资源，根据一个URL地址即可构建 -ClassPathResource：获取类路径下的资源文件 -FileSystemResource:获取文件系统里面的资源 -ServletContextResource:ServletContext封装的资源，用于访问ServletContext环境下的资源 -InputStreamResource:针对于输入流封装的资源 -ByteArrayResource:针对于字节数组封装的资源 ResourceLoader 所有的application contexts都实现了ResourceLoader接口，因此在Resource实例中都可以使用application contexts。 public interface ResourceLoader{ Resource getResource(String location); } Resource template=ctx.getResource(\"some/resource/path/myTemplate.txt\"); Resource template=ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\"); Resource template=ctx.getResource(\"file:/some/resource/path/myTemplate.txt\"); import java.io.IOException; import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.core.io.Resource; public class MoocResource implements ApplicationContextAware { private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } public void resource() throws IOException { Resource resource = applicationContext.getResource(\"config.txt\"); System.out.println(resource.getFilename()); System.out.println(resource.contentLength()); } } Bean的定义及作用域 Classpath扫描与组件管理 从Spring3.0开始，Spring JavaConfig项目提供了很多特性 ，包括使用java而不是XML定义bean，比如@Configuration,@Bean,@Import,@DependsOn @Component是一个通用注解，可用于任何bean @Repository,@Service,@Controller是更有针对性的注解 -@Repository通常用于注解DAO类，即持久层 -@Service通常用于注解Service类，即服务层 -@Controller通常用于Controller类，即控制层（MVC） 类的自动检测及Bean的注册 ·Spring可以自动检测类并注册Bean到ApplicationContext中 @Service bublic class SimpleMovielister{ private MovieFinder movieFinder; @Autovired public SimpleMovieLister(MovieFinder movieFinder){ this.movieFinder=movieFinder; } } @Repository public class JpaMovieFinder implements MovieFinder{ //implementation elided for clarity } context:annotation-config 通过在基于XML的Spring配置如下标签（请注意包含上下文 命名空间） \\仅会查找在同一个applicatcontext中的Bean注解 类的自动检测及Bean的注册 为了能够检测这些类并注册相应的Bean，需要下面内容 \\包含，通常在使用前者后，不用再使用后者，前者包含后者全部功能 AutowiredAnnotationBeanPostProcessor和 CommonAnnotationBeanPostProcessor也会被包含进来 使用过滤器进行自定义扫描 默认情况下，类被自动发现并注册bean的条件是：使用 @Component,@Repository,@Service,@Controller注解或者使用@Component的自定义注解 可以通过过滤器修改上面的行为，如:下面例子的XML配置忽略所有的@Repository注解并用“Stub”代替 还可使用use-default-filters=\"false\"禁用自动发现与注册 定义Bean 扫描过程中组件被自动检测，那么Bean名称是由 BeanNameGenerator生成的（@Component, @Repository,@Service,@Controller都会有个name属性用 于显式设置Bean Name) @Service(\"myMovieLister\") Repository public class SimpleMovieLister {} @Repository public class MovieFinderImpl implements MovieFinder{} 可自定义bean命名策略，实现BeanNameGenerator接口， 并一定要包含一个无参数构造函器 作用域（Scope) 通常情况下自动查找的Spring组件，其scope是singleton，Spring2.5提供了一个标识scope的注解@Scope @Scope(\"prototype\") @Repository public class MovieFinderImpl implements MovieFinder{} 也可以自定义scope策略，实现ScopeMetadataResolver接 口并提供一个无参构造器，比如在多线程中 proxyMode属性 @Scope(\"prototype\" proxyMode=ScopedProxyMode.TARGET_CLASS ) public class MovieFinderImpl implements MovieFinder{} Autowired注解说明 @Required @Required注解适用于bean属性的setter方法 这个注解仅仅表示，受影响的bean属性必须在配置时被填充， 通过在bean定义或通过自动装配一个明确的属性值 public class SimpleMovieLister { private MovieFinder movieFinder; @Required public void setMovieFinder(MovieFinder movieFinder){ this.movieFinder=movieFinder; } } @Autowired 可以将@Autowired注解为“传统\"的setter方法 private MovieFinder movieFinder; @Autovired public void setMovieFinder(MovieFinder movieFinder) { this.moviesinder=movieFinder; } } 可用于构造器或成员变量 @Autovired private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autovired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao){ this.customerPreferenceDao=customerPreferenceDao; } 默认情况下，如果因找不到合适的bean将会导致autowiring 失败抛出异常，可以通过下面的方式避免 public class simpleMovieLister{ private MovieFinder movieFinder; @Autovired(required=false) public void setMovieFinder(MovieFinder movieFinder){ this.movieFinder=movieFinder; } } 每个类只能有一个构造器被标记为required=true @Autowired的必要属性，建议使用@Required注解 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.imooc.beanannotation.injection.dao.InjectionDAO; @Service public class InjectionServiceImpl implements InjectionService { // 方式一 // @Autowired private InjectionDAO injectionDAO; // 方式二 @Autowired public InjectionServiceImpl(InjectionDAO injectionDAO) { this.injectionDAO = injectionDAO; } // 方式三 // @Autowired public void setInjectionDAO(InjectionDAO injectionDAO) { this.injectionDAO = injectionDAO; } @Override public void save(String arg) { System.out.println(\"Service接收参数：\" + arg); injectionDAO.save(arg + \":\" + this.hashCode()); } } 可以使用@Autowired注解那些众所周知的解析依赖性接口， 比如：BeanFactory，ApplicationContext,Environment, ResourceLoader,ApplicationEventPublisher,and MessageSource public class MovieRecommender { @Autovired private ApplicationContext context; public MovieRecommender(){} } 可以通过添加注解给需要该类型的数组的字段或方法，以提供ApplicationContext中的所有特定类型的bean private Set movieCatalogs; @Autovired public void seMovieCatalogs(Set movieCatalogs){( this.movieCatalogs=movieCatalogs; } 可以用干装配kew为string的Map private Map moviecatalogs; @Aucovired pablic void setMovieCatalogs(Map movieCatalogs){ this.movieCatalogs=movieCatalogs; } 如果希望数组有序，可以让bean实现 org.springframework.core.Ordered接口或使用的@Order注解，并且只针对数组有效 @Autowired是由Spring BeanPostProcessor处理的，所以不能在自己的BeanPostProcessor或 BeanFactoryPostProcessor类型应用这些注解，这些类型必须通过XML或者Spring的@Bean注解加载 public interface BeanInterface {} import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Order(2) @Component public class BeanImplOne implements BeanInterface { } @Order(1) @Component public class BeanImplTwo implements BeanInterface { } import java.util.List; import java.util.Map; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class BeanInvoker { @Autowired private List list; public void say() { if (null != list && 0 != list.size()) { System.out.println(\"list...\"); for (BeanInterface bean : list) { System.out.println(bean.getClass().getName()); } } else { System.out.println(\"List list is null\"); } } } list... com.imooc.beanannotation.multibean.BeanImplTwo com.imooc.beanannotation.multibean.BeanImplOne import java.util.List; import java.util.Map; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class BeanInvoker { @Autowired private Map map; public void say() { if (null != map && 0 != map.size()) { System.out.println(\"map...\"); for (Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey() + \" \" + entry.getValue().getClass().getName()); } } else { System.out.println(\"Map map is null\"); } } } map... beanImplTwo com.imooc.beanannotation.multibean.BeanImplTwo beanImplOne com.imooc.beanannotation.multibean.BeanImplOne @Qualifier注解 按类型自动装配可能多个bean实例的情况，可以使用Spring的@Qualifier注解缩小范围(或指定唯一)，也可以用于指定单独的构造器参数或方法参数 可用于注解集合类型变量 主要由xml定义和java注解实现这两种方式 如果通过名字进行注解注入，主要使用的不是@Autowired( 即使在技术上能够通过@Qualifier定bean的名字），替代方式是使用JSR-250@Resource注解，它是通过其独特的名称 来定义来识别特定的目标（这是一个与所声明的类型是无关的 匹配过程） 因语义差异，集合或Map类型的bean无法通过@Autowired 来注入，因为没有类型匹配到这样的bean，为这些bean使用 @Resource注解，通过唯一名称引用集合或Map的bean @Autowired适用于fields,constructors,multi-argument methods这些允许在参数级别使用@Qualifier注解缩小范围的情况 @Resource适用于成员变量、只有一个参数的setter方法，所以在目标是构造器或一个多参数方法时，最好的方式是使用qualifiers 可以定义自己的Qualifier @Component public class BeanImplOne implements BeanInterface { } @Component public class BeanImplTwo implements BeanInterface { } import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class BeanInvoker { @Autowired @Qualifier(\"beanImplTwo\") private BeanInterface beanInterface; public void say() { if (null != beanInterface) { System.out.println(beanInterface.getClass().getName()); } else { System.out.println(\"beanInterface is null...\"); } } } com.imooc.beanannotation.multibean.BeanImplTwo 基于Java的容器注解 @Bean标识一个用于配置和初始化一个由SpringloC容器管理的新对象的方法，类似于XML配置文件的 可以在Spring的@Component注解的类中使用@Bean注解 任何方法（仅仅是可以） 上一点中，通常使用的是@Configuration 等价于 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class StoreConfig { // 若没有指明name，则默认为方法名 // @Bean @Bean(name=\"stringStore\" initMethod=\"init\" destoryMethod=\"cleanup\") public StringStore stringStore() { return new StringStore(); } } 使用@ImportResource和@Value 注解进行资源文件读取 等价于 @Configuration ImportResource(\"classpath:/com/acme/properties-config.xm1\") public class AppConfig{ @Value(\"$(jdbc.url)\") private String url; @Value(\"$(jdbc.username)\") private String username; @Value(\"jdbc.password)\") private String password; @Bean public DataSource dataSource(){ return new DriverManagerDataSource(url,username,password); } } # properties-config.xm1 jdbc.username=root password=root url=127.00.1 基于泛型的装配 > > public interface Store {} public class StringStore implements Store {} public class IntegerStore implements Store {} import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.ImportResource; @Configuration @ImportResource(\"classpath:config.xml\") public class StoreConfig { @Autowired private Store s1; @Autowired private Store s2; @Bean public StringStore stringStore() { return new StringStore(); } @Bean public IntegerStore integerStore() { return new IntegerStore(); } @Bean(name = \"stringStoreTest\") public Store stringStoreTest() { System.out.println(\"s1 : \" + s1.getClass().getName()); System.out.println(\"s2 : \" + s2.getClass().getName()); return new StringStore(); } } CustomAutowireConfigurer CustomAutowireConfigurer是 BeanFactoryPostProcessor的子类，通过它可以注册自己的 qualifier注解类型（即使没有使用Spring的@Qualifier 注解） example.CustomQualifier 该AutowireCandidateResolver决定自动装配的候选者 -每个bean定义的autowire-candidate值 -任何中的default-autowire-candidates -@Qualifier注解及使用CustomAutowireConfigurer的自定义类型 JSR支持说明 Spring AOP基本概念 Spring AOP是什么?你都拿它做什么? AOP基本概念和特点 什么是AOP AOP：Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能 的统一维护的一种技术 主要的功能是：日志记录，性能统计，安全控制，事务处理， 异常处理等等 AOP实现方式 预编译 -AspectJ 运行期动态代理（JDK动态代理、CGLib动态代理） -SpringAOP JbossAOP AOP几个相关概念 名称 说明 切面(Aspect) 一个关注点的模块化，这个关注点可能会横切多个对象 连接点(Joinpoint) 程序执行过程中的某个特定的点 通知(Advice) 在切面的某个特定的连接点上执行的动作 切入点(Pointcut) 匹配连接点的断言，在AOP中通知和一个切入点表达式关联 引入(Introduction) 在不修改类代码的前提下，为类添加新的方法和属性 目标对象(Target Object) 被一个或者多个切面所通知的对象 AOP代理(AOP Proxy) AOP框架创建的对象，用来实现切面契约(aspect contract)(包括通知方法执行等功能） 织入(Weaving) 把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象，分为：编译时织入、类加载时织入、执行时织入 Advice的类型 名称 说明 前置通知(Before advice) 在某连接点(join point)之前执行的通 知，但不能阻止连接点前的执行(除非它抛出一个异常） 返回后通知(After returning advice) (After returning advice)在某连接点(join point)正常完成后执行的通知 抛出异常后通知(After throwing advice) 在方法抛出异常退出时执行的通知 后通知(After((finally) advice) 当某连接点退出的时候执行的通知(不论是正常返回还是异常退出） 环绕通知(Around Advice) 包围一个连接点(join point)的通知 Spring框架中AOP的用途 提供了声明式的企业服务，特别是EJB的替代服务的声明 允许用户定制自己的方面，以完成OOP与AOP的互补使用 Spring的AOP实现 纯java实现，无需特殊的编译过程，不需要控制类加载器层次 目前只支持方法执行连接点(通知Spring Bean的方法执行) 不是为了提供最完整的AOP实现(尽管它非常强大)；而是侧重于提供一种AOP实现和Spring IoC容器之间的整合，用于帮助解决企业应用中的常见问题 Spring AOP不会与AspectU竞争，从而提供综合全面的AOP解决方案 有接口和无接口的Spring AOP实现区别 Spring AOP默认使用标准的JavaSE动态代理作为AOP代理， 这使得任何接口(或者接口集)都可以被代理 Spring AOP中也可以使用CGLIB代理(如果一个业务对象并没有实现一个接口) 配置切面和切入点 Schema-based AOP Spring所有的切面和通知器都必须放在一个内 （可以配置包含多个元素）， 每一个 \\可以包含pointcut，advisor和aspect元素 （它们必须按照这个顺序进行声明 ) \\风格的配置大量使用了Spring的自动代理机制 | 表达式 | 含义 | | ------------------------------------------------------------ | ------------------------------------------------------------ | | execution(public*(..)) | 切入点为执行所有public方法时 | | execution( set(..)) | 切入点为执行所有set开始的方法时 | | execution( com.service.Service.(..)) | 切入点为执行AccountService类中的所有方法时 | | execution( com.xyz.service..(.)) | 切入点为执行com.xyz.service包下的所有方法时 | | execution( com.xyz.service...(..)) | 切入点为执行com.xyz.service包及其子包下的所有方法时 | | within(com.xyz.service.) | (only in Spring AOP) | | within(com.xyz.service..*) | (only in Spring AOP) within用于匹配指定类型内的方法执行 | | this(com.xyz.service.AccountService) | (only in Spring AOP)this用于匹配当前AOP代理对象类型的执行方法 | | target(com.xyz.service.AccountService) | (only in Spring AOP)target 用于匹配当前目标对象类型的执行方法 | | @annotation(org.springframework.transaction.annota tion.Transactional) | (only in Spring AOP)args 用于匹配当前执行的方法传入的参数为指定类型的执行方法 | Advice应用 public class AspectBiz { public void biz() { System.out.println(\"AspectBiz biz.\"); // throw new RuntimeException(); } } import org.aspectj.lang.ProceedingJoinPoint; public class MoocAspect { public void before() { System.out.println(\"MoocAspect before.\"); } public void afterReturning() { System.out.println(\"MoocAspect afterReturning.\"); } public void afterThrowing() { System.out.println(\"MoocAspect afterThrowing.\"); } public void after() { System.out.println(\"MoocAspect after.\"); } } // 输出 MoocAspect before. AspectBiz biz. MoocAspect afterReturning. MoocAspect after Around advice 通知方法的第一个参数必须是ProceedingJoinPoint类型 public Object around(ProceedingJoinPoint pjp) { Object obj = null; try { System.out.println(\"MoocAspect around 1.\"); obj = pjp.proceed(); System.out.println(\"MoocAspect around 2.\"); } catch (Throwable e) { e.printStackTrace(); } return obj; } Advice parameters public class AspectBiz { public void biz() { System.out.println(\"AspectBiz biz.\"); } public void init(String bizName, int times) { System.out.println(\"AspectBiz init : \" + bizName + \" \" + times); } } import org.aspectj.lang.ProceedingJoinPoint; public class MoocAspect { public Object aroundInit(ProceedingJoinPoint pjp, String bizName, int times) { System.out.println(bizName + \" \" + times); Object obj = null; try { System.out.println(\"MoocAspect aroundInit 1.\"); obj = pjp.proceed(); System.out.println(\"MoocAspect aroundInit 2.\"); } catch (Throwable e) { e.printStackTrace(); } return obj; } } Introduction应用 允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象 由\\中的\\元素声明 该元素用于声明所匹配的类型拥有一个新的parent（因此得名） schema-defined aspects只支持singleton model public interface Fit { void filter(); } public class FitImpl implements Fit { @Override public void filter() { System.out.println(\"FitImpl filter.\"); } } @Test public void testFit0{ Fit fit=(Fit)super.getBean(\"aspectBiz\"); fit.filter0; } // 输出 FitImpl filter. Advisors advisor就像一个小的自包含的方面，只有一个advice 切面自身通过一个bean表示，并且必须实现某个advice 接口，同时，advisor也可以很好的利用AspectJ的切入 点表达式 Spring通过配置文件中\\元素支持advisor 实际使用中，大多数情况下它会和transactional advice 配合使用 为了定义一个advisor的优先级以便让advice可以有序， 可以使用order属性来定义advisor的顺序 import org.aspectj.lang.ProceedingJoinPoint; import org.springframework.core.Ordered; import org.springframework.dao.PessimisticLockingFailureException; public class ConcurrentOperationExecutor implements Ordered { private static final int DEFAULT_MAX_RETRIES = 2; private int maxRetries = DEFAULT_MAX_RETRIES; private int order = 1; public void setMaxRetries(int maxRetries) { this.maxRetries = maxRetries; } public int getOrder() { return this.order; } public void setOrder(int order) { this.order = order; } public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { int numAttempts = 0; PessimisticLockingFailureException lockFailureException; do { numAttempts++; System.out.println(\"Try times : \" + numAttempts); try { return pjp.proceed(); } catch (PessimisticLockingFailureException ex) { lockFailureException = ex; } } while (numAttempts import org.springframework.dao.PessimisticLockingFailureException; import org.springframework.stereotype.Service; @Service public class InvokeService { public void invoke() { System.out.println(\"InvokeService ......\"); } public void invokeException() { throw new PessimisticLockingFailureException(\"\"); } } @Test public void testSave0{ InvokeService service=super.getBeaninvokeService\"); service.invoke0; System.out printin0. service.invokeException0; } // 输出 Try times:1 InvokeService... Try times:1 Try times:2 Try times:3 Try times:4 Try error:4 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_集合.html":{"url":"chapters/Java基础_集合.html","title":"Java基础_集合","keywords":"","body":"集合 [TOC] 集合 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_泛型.html":{"url":"chapters/Java基础_泛型.html","title":"Java基础_泛型","keywords":"","body":"泛型 [TOC] 泛型 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_打jar包.html":{"url":"chapters/Java基础_打jar包.html","title":"Java基础_打jar包","keywords":"","body":"详细步骤assembly.xmlpom.xmlHycTest.java命令行 [TOC] 详细步骤 assembly.xml test jar false ${project.build.directory}/test-classes / **/*.class **/*.properties **/*.xml false pom.xml com.code.hyc test 1.0 4.0.0 hycCall jar maven-assembly-plugin 2.3 src/main/resources/assembly.xml make-assembly package single com.code.hyc.HycTest org.apache.maven.plugins maven-dependency-plugin copy-dependencies package copy-dependencies ${project.build.directory}/lib false true HycTest.java public class HycTest{ public static void main(String[] args) throws Throwable { System.out.println(\"打包成功！\"); } } 执行maven->clean->package 在target将hycCall.jar移动到lib文件夹下，此时lib文件夹和hycCal-testl.jar就是可以执行的jar包了 命令行 // 命令行debug模式(-Xms4G -Xmx8G -XX:PermSize=4G -XX:MaxPermSize=8G为指定内存大小) java -Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -jar -Xms4G -Xmx8G -XX:PermSize=4G -XX:MaxPermSize=8G -Djava.ext.dirs=./lib mist-calculate-1.0-test.jar // 后台执行模式(nohup xxx &) nohup java -jar -Xms4G -Xmx8G -XX:PermSize=4G -XX:MaxPermSize=8G -Djava.ext.dirs=./lib mist-calculate-1.0-test.jar & // 日志查看 tail -10f nohup.out // 查看java命令的进程 ps -a | grep java // 杀死指定线程号 kill -9 线程号 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_正则匹配.html":{"url":"chapters/Java基础_正则匹配.html","title":"Java基础_正则匹配","keywords":"","body":"正则匹配 [TOC] 正则匹配 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_反射机制.html":{"url":"chapters/Java基础_反射机制.html","title":"Java基础_反射机制","keywords":"","body":"反射机制Class类的使用动态加载类获取方法信息获取成员变量构造函数信息方法反射的基本操作通过反射了解集合泛型的本质jOOR反射api [TOC] 反射机制 反射——Java高级开发必须懂的 Java高级特性——反射 Class类的使用 Class类 在面向对象的世界里，万事万物皆对象。 java语言中，静态的成员、普通数据类型类是不是对象呢？ 类是谁的对象呢？ 类是对象，类是java.lang.Class类的实例对象 这个对象到底如何表示？ There is a class named Class class Foo { void print() { System.out.println(\"foo\"); } } public class ClassDemo1 { public static void main(String[] args) { // 第一种表示方式--->实际在告诉我们任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; // 第二种表达方式 已经知道该类的对象通过getClass方法 // 类也是对象，是Class类的实例对象 // 这个对象我们称为该类的类类型 // 不管c1 or c2都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象 Class c2 = new Foo().getClass(); System.out.println(c1 == c2); //第三种表达方式 Class c3 = null; try { c3 = Class.forName(\"com.imooc.reflect.Foo\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } System.out.println(c2 == c3); // 我们完全可以通过类的类类型创建该类的对象实例---->通过c1 or c2 or c3创建Foo的实例对象 try { Foo foo = (Foo) c1.newInstance();//需要有无参数的构造方法 foo.print(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } // 输出 true true foo 动态加载类 Class类 Class.forName(“类的全称\"） 不仅表示了类的类类型，还代表了动态加载类 · 请大家区分编译、运行编译时刻加载类是静态加载类、运行时刻加载类是动态加载类 interface OfficeAble { void start(); } class Word implements OfficeAble { @Override public void start() { System.out.println(\"word..starts.…\"); } } class Excel implements OfficeAble { @Override public void start() { System.out.println(\"Excel..starts.…\"); } } public class OfficeBetter { public static void main(String[] args) { try { // 动态加载类，在运行时刻加载 Class c = Class.forName(\"com.imooc.reflect.Word\"); // 通过类类型，创建该类对象 OfficeAble oa = (OfficeAble) c.newInstance(); oa.start(); } catch (Exception e) { e.printStackTrace(); } } } // 输出 word..starts.… 获取方法信息 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class ClassUtil { /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * @param obj 该对象所属类的信息 */ static void printClassMethodMessage(Object obj){ // 要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();//传递的是哪个子类的对象 c就是该子类的类类型 //获取类的名称 System.out.println(\"类的名称是:\"+c.getName()); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods(); //c.getDeclaredMethods() for(int i = 0; i 得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) { System.out.print(class1.getName()+\",\"); } System.out.println(\")\"); } } } public class ClassDemo3 { public static void main(String[] args) { String s = \"hello\"; ClassUtil.printClassMethodMessage(s); Integer n1 = 1; ClassUtil.printClassMethodMessage(n1); } } // 输出 类的名称是:java.lang.String boolean equals(java.lang.Object,) java.lang.String toString() int hashCode() int compareTo(java.lang.String,) ... 获取成员变量构造函数信息 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class ClassUtil { /** * 获取成员变量的信息 */ public static void printFieldMessage(Object obj) { Class c = obj.getClass(); /* * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ //Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) { //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+\" \"+fieldName); } } } public class ClassDemo4 { public static void main(String[] args) { ClassUtil.printFieldMessage(\"hello\"); System.out.println(\"=============\"); ClassUtil.printFieldMessage(new Integer(1)); } } // 输出 [C value int hash long serialVersionUID [Ljava.io.ObjectStreamField; serialPersistentFields java.util.Comparator CASE_INSENSITIVE_ORDER ============= int MIN_VALUE int MAX_VALUE java.lang.Class TYPE ... import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; public class ClassUtil { /** * 打印对象的构造函数的信息 * @param obj */ public static void printConMessage(Object obj){ Class c = obj.getClass(); /* * 构造函数也是对象 * java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ //Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) { System.out.print(constructor.getName()+\"(\"); //获取构造函数的参数列表--->得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) { System.out.print(class1.getName()+\",\"); } System.out.println(\")\"); } } } public class ClassDemo5 { public static void main(String[] args) { ClassUtil.printConMessage(\"hello\"); ClassUtil.printConMessage(new Integer(1)); } } // 输出 java.lang.String([B,int,int,) java.lang.String([B,java.nio.charset.Charset,) java.lang.String([B,java.lang.String,) ... 方法反射的基本操作 方法的反射 如何获取某个方法 方法的名称和方法的参数列表才能唯一决定某个方法 方法反射的操作method.invoke(对象，参数列表） import java.lang.reflect.Method; class A { public void print() { System.out.println(\"helloworld\"); } public void print(int a, int b) { System.out.println(a + b); } public void print(String a, String b) { System.out.println(a.toUpperCase() + \",\" + b.toLowerCase()); } } public class MethodDemo1 { public static void main(String[] args) { // 获取方法名称和参数列表来决定 // getMethod获取的是public的方法 // getDelcaredMethod自己声明的方法 A a1 = new A(); Class c = a1.getClass(); try { // 1.获取方法print(int,int) // Method m = c.getMethod(\"print\", new Class[]{int.class,int.class}); Method m = c.getMethod(\"print\", int.class, int.class); // 方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同 // Object o = m.invoke(a1,new Object[]{10,20}); Object o = m.invoke(a1, 10, 20); System.out.println(\"==================\"); // 2.获取方法print(String,String) Method m1 = c.getMethod(\"print\", String.class, String.class); o = m1.invoke(a1, \"hello\", \"WORLD\"); System.out.println(\"===================\"); // 3.获取方法print() // Method m2 = c.getMethod(\"print\", new Class[]{}); Method m2 = c.getMethod(\"print\"); // m2.invoke(a1, new Object[]{}); m2.invoke(a1); } catch (Exception e) { e.printStackTrace(); } } } // 输出 30 ================== HELLO,world =================== helloworld 通过反射了解集合泛型的本质 可以用反射绕过泛型 import java.lang.reflect.Method; import java.util.ArrayList; public class MethodDemo4 { public static void main(String[] args) { ArrayList list = new ArrayList(); ArrayList list1 = new ArrayList(); list1.add(\"hello\"); //list1.add(20);错误的 Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); //反射的操作都是编译之后的操作 /* * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效， * 绕过编译就无效了 * 验证：我们可以通过方法的反射来操作，绕过编译 */ try { Method m = c2.getMethod(\"add\", Object.class); m.invoke(list1, 20);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); System.out.println(list1); /*for (String string : list1) { System.out.println(string); }*///现在不能这样遍历 } catch (Exception e) { e.printStackTrace(); } } } // 输出 true 2 [hello, 20] jOOR反射api jOOR反射api org.jooq joor 0.9.5 import org.joor.Reflect; /** * 基于Joor的反射学习 */ private static void joorReflex() { Properties pro = GetProperties.getPro(pathname); String fruitClass = pro.getProperty(\"apple\"); Reflect reflect = Reflect.on(fruitClass).create(); reflect.call(\"setPrice\",25.4); // 为包装类建立一个代理 Fruit fruitProxy = Reflect.on(fruitClass).create().as(Fruit.class); Reflect.on(fruitProxy).call(\"setPrice\",13.2); Fruit fruit = FruitFactory.getInstance(fruitClass); Reflect.on(fruit).call(\"setPrice\",17.6); System.out.println(); } Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_对象正反序列化.html":{"url":"chapters/Java基础_对象正反序列化.html","title":"Java基础_对象正反序列化","keywords":"","body":"对象正反序列化 [TOC] 对象正反序列化 import java.io.*; import java.util.Base64; /** * 对象编码工具类 */ public class ObjEncodeUtil { public static String encodeBase64(Object object) { if (object == null) { return null; } ObjectOutputStream oos = null; String result; try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(object); result = Base64.getEncoder().encodeToString(bos.toByteArray()); } catch (IOException e) { throw new RuntimeException(e); } finally { try { if (oos != null) { oos.close(); } } catch (IOException e) { e.printStackTrace(); } } return result; } public static T decodeBase64(String str) { ObjectInputStream ois = null; T result; try { ByteArrayInputStream bis = new ByteArrayInputStream(Base64.getDecoder().decode(str)); ois = new ObjectInputStream(bis); result = (T) ois.readObject(); } catch (IOException | ClassNotFoundException e) { throw new RuntimeException(e); } finally { if (ois != null) { try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } return result; } } class Bean{ int length; double width; public Bean() { } public Bean(int length, double width) { this.length = length; this.width = width; } public int getLength() { return length; } public void setLength(int length) { this.length = length; } public double getWidth() { return width; } public void setWidth(double width) { this.width = width; } } Bean bean = new Bean(5,3.2); String modelStr = ObjEncodeUtil.encodeBase64(bean); Bean bean2 = ObjEncodeUtil.decodeBase64(modelStr); import com.alibaba.fastjson.JSON; ModelBean bean = new ModelBean(); String jsonResult = JSON.toJSONString(bean); ModelBean bean2 = JSON.parseObject(jsonResult, ModelBean.class); Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_读取配置文件.html":{"url":"chapters/Java基础_读取配置文件.html","title":"Java基础_读取配置文件","keywords":"","body":"读取配置文件读取properties配置文件读取xml配置文件Spring 读取properties文件利用第三方配置工具owner读取配置文件 [TOC] 读取配置文件 读取properties配置文件 properties类中的主要方法 1）getProperty(String key) 用指定的键在此属性列表中搜索属性。也就是通过参数key，得到key所对应的value。 2）load(InputStream inStream) 从输入流中读取属性列表（键和元素对）。以供getProperty( String key)来搜索。 3）setProperty(String key, String value) 调用Hashtable的方法put 。他通过调用基类的put方法来设置键-值对。 4）store(OutputStream out, String comments) 以适合使用load方法加载到Properties表中的格式，将此Properties表中的属性列表（键和元素对）写入输出流。与load方法相反，该方法将键-值对写入到指定的文件中去。 5）clear() 清除所有装载的键-值对。该方法在基类中提供 apple=src.main.java.per.hyc.ReflexAndInvokeTest.Apple orange=src.main.java.per.hyc.ReflexAndInvokeTest.Orange import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.util.Properties; /** * 获取properties文件的配置 */ public class GetProperties { public static Properties getPro(String pathname) { Properties pro = new Properties(); File f = new File(pathname); try { if (f.exists()) { pro.load(new FileInputStream(f)); } //建立一个新的属性文件，同时设置好默认内容 else { pro.setProperty(\"apple\", \"per.hyc.ReflexAndInvokeTest.Apple\"); pro.setProperty(\"orange\", \"per.hyc.ReflexAndInvokeTest.Orange\"); pro.store(new FileOutputStream(f), \"FRUIT CLASS\"); } } catch (Exception e) { e.printStackTrace(); } return pro; } } 读取xml配置文件 per.hyc.designPattern.Bridge.Blue per.hyc.designPattern.Bridge.SmallPen import javax.xml.parsers.*; import org.w3c.dom.*; import java.io.*; /** * 使用java反射创建具体的颜色和画笔 */ public class XMLUtilPen { // 该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 public static Object getBean(String args) { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\".\\\\src\\\\main\\\\resources\\\\configPen.xml\")); Node classNode = null; NodeList nl = doc.getElementsByTagName(\"className\"); if (args.equals(\"color\")) { //获取包含类名的文本节点 classNode = nl.item(0).getFirstChild(); } else if (args.equals(\"pen\")) { //获取包含类名的文本节点 classNode = nl.item(1).getFirstChild(); } String cName = classNode.getNodeValue(); //通过类名生成实例对象并将其返回 return Class.forName(cName).newInstance(); } catch (Exception e) { e.printStackTrace(); return null; } } } Spring 读取properties文件 Java中读取Properties配置文件的几种方式 @ConfigurationProperties(prefix = \"student\") @Value Environment 详见项目springbootdemo 利用第三方配置工具owner读取配置文件 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_解析与生成XML.html":{"url":"chapters/Java基础_解析与生成XML.html","title":"Java基础_解析与生成XML","keywords":"","body":"解析与生成XMLDom方式Dom4j方式JDom方式Sax方式xml解析 [TOC] 解析与生成XML Java生成xml文件的四种方式 四种生成和解析XML文档的方法详解（介绍+优缺点比较+示例） Java 自定义生成与解析（Dom4J）XML 文件 四种方式总结: 1.dom基于tree，sax基于事件，JDOM和DOM4J基于底层API 2.dom生成的内容会保存到内存中，方便删除和修改 3.sax不能修改已经生成的标签 4.添加JUnit在Libraries选择Add Library中的JUnit即可 【DOM】 DOM方式生成xml是基于DOM树的结构，整个DOM树会存在内存中，所以使用DOM方式可以频繁的修改xml的内容，但是因为DOM树是存在内存中的，所以对内存消耗较大。DOM方式比较适用于需要频繁删改的情况。 【SAX】 SAX方式生成xml是逐步写入的，也就是说，在SAX写入时，已经写入的部分是无法再回头修改的，因为SAX是基于事件驱动的，在写完一个标签之后是不能回头的，也因此，SAX的效率比较快，但是不能进行删改。 【JDOM】 JDOM方式不是Java提供的基本的生成xml方式，使用时需要导入额外的jar包，但是它是基于基础的API实现的。 【DOM4J】 DOM4J方式也不是Java提供的基本生成xml的方式，使用时也需要导入额外的jar包，它也是基于基础的API实现的，它功能强大，性能优异，在实际开发中经常使用。 DOM方式是最慢的，SAX方式反而是最快的，DOM4J方式仅次于SAX方式。 Dom方式 > > import org.junit.Test; import org.w3c.dom.DOMConfiguration; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.w3c.dom.bootstrap.DOMImplementationRegistry; import org.w3c.dom.ls.DOMImplementationLS; import org.w3c.dom.ls.LSOutput; import org.w3c.dom.ls.LSSerializer; import org.xml.sax.InputSource; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.StringReader; import java.util.ArrayList; import java.util.List; import java.io.File; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import org.junit.Test; import org.w3c.dom.Document; import org.w3c.dom.Element; public class DomXml { @Test public void test(){ Long start = System.currentTimeMillis(); createXml(); System.out.println(\"运行时间：\"+ (System.currentTimeMillis() - start)); } /** * 生成xml方法 */ public static void createXml() { try { // 创建解析器工厂 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder db = factory.newDocumentBuilder(); Document document = db.newDocument(); // 不显示standalone=\"no\" document.setXmlStandalone(true); Element bookstore = document.createElement(\"bookstore\"); // 向bookstore根节点中添加子节点book Element book = document.createElement(\"book\"); Element name = document.createElement(\"name\"); // 不显示内容 name.setNodeValue(\"不好使\"); name.setTextContent(\"雷神\"); book.appendChild(name); // 为book节点添加属性 book.setAttribute(\"id\", \"1\"); // 将book节点添加到bookstore根节点中 bookstore.appendChild(book); // 将bookstore节点（已包含book）添加到dom树中 document.appendChild(bookstore); // 方式一: 保存xml文件 // 创建TransformerFactory对象 // TransformerFactory tff = TransformerFactory.newInstance(); // 创建 Transformer对象 // Transformer tf = tff.newTransformer(); // 输出内容是否使用换行 // tf.setOutputProperty(OutputKeys.INDENT, \"yes\"); // 创建xml文件并写入内容 // tf.transform(new DOMSource(document), new StreamResult(new File(\"book1.xml\"))); // System.out.println(\"生成book1.xml成功\"); // 方式二: 转字符串 // 创建TransformerFactory对象 TransformerFactory transformerFactory = TransformerFactory.newInstance(); // 创建Transformer对象 Transformer transformer = transformerFactory.newTransformer(); // 设置输出数据时换行 // tf.setOutputProperty(OutputKeys.INDENT, \"yes\"); // xml格式化 ByteArrayOutputStream bos = new ByteArrayOutputStream(); transformer.transform(new DOMSource(document), new StreamResult(bos)); String xmlString = bos.toString(); System.out.println(new String(prettyXml(xmlString))); } catch (Exception e) { e.printStackTrace(); System.out.println(\"生成book1.xml失败\"); } } } /** * 格式化输出 * * @param xmlStr: xml文档字符串 * @return 格式化xml */ private static byte[] prettyXml(String xmlStr) { byte[] data = null; StringReader stringReader = null; try { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); stringReader = new StringReader(xmlStr); InputSource is = new InputSource(stringReader); Document doc = db.parse(is); data = prettyXml(doc); } catch (Exception e) { throw new RuntimeException(e); } finally { if (stringReader != null) { stringReader.close(); } } return data; } /** * 格式化输出 * * @param node: 文档树节点 * @return 格式化完的节点 */ private static byte[] prettyXml(Node node) { ByteArrayOutputStream byteArrayOutputStream = null; byte[] data = null; try { DOMImplementationRegistry registry = DOMImplementationRegistry.newInstance(); DOMImplementationLS impl = (DOMImplementationLS) registry.getDOMImplementation(\"XML 3.0\"); LSSerializer serializer = impl.createLSSerializer(); DOMConfiguration domConfiguration = serializer.getDomConfig(); boolean isSupport = domConfiguration.canSetParameter(\"format-pretty-print\", true); if (isSupport) { domConfiguration.setParameter(\"format-pretty-print\", true); } LSOutput output = impl.createLSOutput(); output.setEncoding(\"UTF-8\"); byteArrayOutputStream = new ByteArrayOutputStream(); output.setByteStream(byteArrayOutputStream); serializer.write(node, output); data = byteArrayOutputStream.toByteArray(); } catch (Exception e) { throw new RuntimeException(e); } finally { if (byteArrayOutputStream != null) { try { byteArrayOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } return data; } 雷神 Dom4j方式 > > import java.io.File; import java.io.FileOutputStream; import org.dom4j.Document; import org.dom4j.DocumentHelper; import org.dom4j.Element; import org.dom4j.io.OutputFormat; import org.dom4j.io.XMLWriter; import org.junit.Test; public class Dom4jXml { @Test public void test(){ Long start = System.currentTimeMillis(); createXml(); System.out.println(\"运行时间：\"+ (System.currentTimeMillis() - start)); } /** * 生成xml方法 */ public static void createXml(){ try { // 1、创建document对象 Document document = DocumentHelper.createDocument(); // 2、创建根节点rss Element rss = document.addElement(\"rss\"); // 3、向rss节点添加version属性 rss.addAttribute(\"version\", \"2.0\"); // 4、生成子节点及子节点内容 Element channel = rss.addElement(\"channel\"); Element title = channel.addElement(\"title\"); title.setText(\"国内最新新闻\"); // 5、设置生成xml的格式 OutputFormat format = OutputFormat.createPrettyPrint(); // 设置编码格式 format.setEncoding(\"UTF-8\"); // 6、生成xml文件 File file = new File(\"rss.xml\"); XMLWriter writer = new XMLWriter(new FileOutputStream(file), format); // 设置是否转义，默认使用转义字符 writer.setEscapeText(false); writer.write(document); writer.close(); System.out.println(\"生成rss.xml成功\"); } catch (Exception e) { e.printStackTrace(); System.out.println(\"生成rss.xml失败\"); } } } JDom方式 > > import java.io.File; import java.io.FileOutputStream; import org.jdom.Document; import org.jdom.Element; import org.jdom.output.Format; import org.jdom.output.XMLOutputter; import org.junit.Test; public class JDomXml { @Test public void test(){ Long start = System.currentTimeMillis(); createXml(); System.out.println(\"运行时间：\"+ (System.currentTimeMillis() - start)); } /** * 生成xml方法 */ public static void createXml(){ try { // 1、生成一个根节点 Element rss = new Element(\"rss\"); // 2、为节点添加属性 rss.setAttribute(\"version\", \"2.0\"); // 3、生成一个document对象 Document document = new Document(rss); Element channel = new Element(\"channel\"); rss.addContent(channel); Element title = new Element(\"title\"); title.setText(\"国内最新新闻\"); channel.addContent(title); Format format = Format.getCompactFormat(); // 设置换行Tab或空格 format.setIndent(\" \"); format.setEncoding(\"UTF-8\"); // 4、创建XMLOutputter的对象 XMLOutputter outputer = new XMLOutputter(format); // 5、利用outputer将document转换成xml文档 File file = new File(\"rssNew.xml\"); outputer.output(document, new FileOutputStream(file)); System.out.println(\"生成rssNew.xml成功\"); } catch (Exception e) { System.out.println(\"生成rssNew.xml失败\"); } } } Sax方式 > > > xml解析 > > > import org.springframework.util.Assert; Assert.notNull(featureDataRow, \"数据不能为空\"); Assert.noNullElements(featureDataRow.getColumns().values().toArray(), \"该样本存在null特征\"); Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_后台服务器开发.html":{"url":"chapters/Java基础_后台服务器开发.html","title":"Java基础_后台服务器开发","keywords":"","body":"后台服务器开发远程通信方式WebService平台技术常见通信协议常见通信方式webserver/servlet容器不同开发实现 [TOC] 后台服务器开发 远程通信方式 WebService平台技术 XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术 XML+XSD WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 SOAP WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。 SOAP协议 = HTTP协议 + XML数据格式 SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。 WSDL 好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。 WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。 WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 常见通信协议 浅谈几种通信方式(dubbo,webservice,restful) TCP/IP TCP/IP 协议是一个协议族。里面包括很多协议。UDP 只是其中的一个。因为TCP/IP比较重要所以用他两命名。 TCP和UDP tcp和udp都是传输协议，主要区别是tcp协议连接需要3次握手，断开需要四次握手，是通过流来传输的，就是确定连接后，一直发送信息，传完后断开。 udp不需要进行连接，直接把信息封装成多个报文，直接发送。所以udp的速度更快写，但是不保证数据的完整性和数据顺序(这个是可以在实现时通过验证手段来手动确定完整性)。 HTTP http协议是建立在TCP协议之上的一种应用，是Web联网的基础，最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。 从建立连接到关闭连接的过程称为“一次连接”。 SOCKET socket并不是一种协议，是在程序员层面上对TCP/IP协议的封装和应用。其实是一个调用接口，方便程序员使用TCP/IP协议栈而已。程序员通过socket来使用tcp/ip协议。 但是socket并不是一定要使用tcp/ip协议，Socket编程接口在设计的时候，就希望也能适应其他的网络协议。 RPC RPC(Remote Procedure Call)—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。 在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 SOAP 简单对象访问协议是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计成在WEB上交换结构化的和固化的信息。 常见通信方式 Webservice 效率不高基于soap协议，其主要的特点是跨语言、跨平台的。项目中不推荐使用，可用于不同公司间接口的调用。 restful http+json。很多项目中应用。如果服务太多，服务之间调用关系混乱，需要治疗服务。 dubbo 使用rpc协议进行远程调用，直接使用socket通信。传输效率高，并且可以统计出系统之间的调用关系、调用次数。使用Java语言开发，只能用于Java语言开发的项目间的通信，不具备跨语言，跨平台的特点！ webservice之Restful风格 webservice之Restful风格 使用restful风格的webservice 也就是cxf发布的webservice的地址是restful风格的 使用restful风格发布的webservice不采用soap协议 ，轻量级 速度快，采用http传输协议。 SOAP webserivce 和 RESTful webservice 对比及区别 RESTful跟WebService的区别 webserver/servlet容器 关于tomcat和jetty对比(不喜欢jetty的勿看) tomcat与jetty的区别 Jetty篇一之初识Jetty 相同点 Tomcat和Jetty都是一种Servlet引擎，他们都支持标准的servlet规范和JavaEE的规范。 架构比较 Jetty的架构比Tomcat的更为简单。 Jetty的架构是基于Handler来实现的，主要的扩展功能都可以用Handler来实现，扩展简单。 Tomcat的架构是基于容器设计的，进行扩展是需要了解Tomcat的整体设计结构，不易扩展。 性能比较 Jetty和Tomcat性能方面差异不大。 Jetty可以同时处理大量连接而且可以长时间保持连接，适合于web聊天应用等等。 Jetty的架构简单，因此作为服务器，Jetty可以按需加载组件，减少不需要的组件，减少了服务器内存开销，从而提高服务器性能。 Jetty默认采用NIO结束在处理I/O请求上更占优势，在处理静态资源时，性能较高。 Tomcat适合处理少数非常繁忙的链接，也就是说链接生命周期短的话，Tomcat的总体性能更高。 Tomcat默认采用BIO处理I/O请求，在处理静态资源时，性能较差。 其它比较 Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好。 Tomcat目前应用比较广泛，对JavaEE和Servlet的支持更加全面，很多特性会直接集成进来。 Google 选择 Jetty, 放弃 Tomcat Jetty的基本架构 Tomcat的基本架构 不同开发实现 > > > 花了近十年的时间，整理出史上最全面Java面试题 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java基础_四舍五入.html":{"url":"chapters/Java基础_四舍五入.html","title":"Java基础_四舍五入","keywords":"","body":"四舍五入 [TOC] 四舍五入 ROUND_UP：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。 ROUND_DOWN：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。 ROUND_CEILING：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。 ROUND_FLOOR：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。 HALF_UP：最近数字舍入(5进)。这是我们最经典的四舍五入。 HALF_DOWN：最近数字舍入(5舍)。在这里5是要舍弃的。 HAIL_EVEN：银行家舍入法。 public class Test { public static void main(String[] args) { double a = 1.66728D; double b = 1.33333D; double c = 1.00000D; BigDecimal aa = new BigDecimal(a); BigDecimal bb = new BigDecimal(b); BigDecimal cc = new BigDecimal(c); System.out.println(aa.setScale(2, BigDecimal.ROUND_UP)); System.out.println(aa.setScale(2, BigDecimal.ROUND_DOWN)); System.out.println(bb.setScale(2, BigDecimal.ROUND_UP)); System.out.println(bb.setScale(2, BigDecimal.ROUND_DOWN)); System.out.println(cc.setScale(2, BigDecimal.ROUND_UP)); System.out.println(cc.setScale(2, BigDecimal.ROUND_DOWN)); System.out.println(\"-------------------------------------\"); System.out.println(aa.setScale(2, RoundingMode.UP)); System.out.println(aa.setScale(2, RoundingMode.DOWN)); System.out.println(bb.setScale(2, RoundingMode.UP)); System.out.println(bb.setScale(2, RoundingMode.DOWN)); System.out.println(cc.setScale(2, RoundingMode.UP)); System.out.println(cc.setScale(2, RoundingMode.DOWN)); } } 1.67 1.66 1.34 1.33 1.00 1.00 ------------------------------------- 1.67 1.66 1.34 1.33 1.00 1.00 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java进阶_反射.html":{"url":"chapters/Java进阶_反射.html","title":"Java进阶_反射","keywords":"","body":"反射概念基本概念代码的三个阶段Java内存类加载过程类加载与ClassLoader类初始化时机类加载器的作用自定义网络类加载Class对象获取方式反操作泛型Class对象功能获取功能Field：成员变量Constructor:构造方法Method：方法对象getName方法关于获取成员方法们的另外两个方法 [TOC] 【黑马程序员-Java语言高级部分9.2】Java 反射 反射机制笔记 【狂神说Java】注解和反射 JAVA注解与反射和类的加载机制第十六个专题 反射概念 基本概念 框架：半成品软件，可以在框架的基础上进行软件开发，简化编码。 学习框架并不需要了解反射，但是要是想自己写一个框架，那么就要对反射机制有很深入的了解。 反射机制：将类的各个组成部分封装为其他对象，这就是反射机制。 反射的好处： 可以在程序运行过程中，操作这些对象。 可以解耦，提高程序的可扩展性。 假设我们使用的是new这种形式进行对象的实例化。此时如果在项目的某一个小模块中我们的一个实例类丢失了，那么在编译期间就会报错，以导致整个项目无法启动。 对于反射创建对象Class.forName(\"全类名\");这种形式，我们在编译期需要的仅仅只是一个字符串（全类名），在编译期不会报错，这样其他的模块就可以正常的运行，而不会因为一个模块的问题导致整个项目崩溃。这就是Spring框架中IOC控制反转的本质。 Reflection(反射)是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。 我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射 代码的三个阶段 Source源代码阶段：*.java被编译成*.class字节码文件。 Class类对象阶段：*.class字节码文件被类加载器加载进内存，并将其封装成Class对象（用于在内存中描述字节码文件），Class对象将原字节码文件中的成员变量抽取出来封装成数组Field[]，将原字节码文件中的构造函数抽取出来封装成数组Construction[]，在将成员方法封装成Method[]。 RunTime运行时阶段：创建对象的过程new。 Java内存 堆: 存放new的对象和数组，被所有的线程共享，不会存放别的对象引用 栈: 存放基本变量类型(会包含这个基本类型的具体数值)，引用对象的变量(会存放这个引用在堆里面的具体地址) 方法区: 可以被所有的线程共享，包含了所有的class和static变量 类加载过程 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。 类加载与ClassLoader 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象。 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化：执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。 类构造器是构造类信息的，不是构造该类对象的构造器。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。 类初始化时机 类主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 类加载器的作用 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间。不过JVM垃圾回收机制可以回收这些Class对象 类加载器作用是用来把类(class)装载进内存的。 JVM规范定义了如下类型的类的加载器。 public static void main(string[] args){ // 获取系统类的加载器 ClassLoader systemClassloader = ClassLoader.getsystemclassloade(); System.out.println(systemclassLoader); // 获取系统类加载器的父类加载器-一>扩展类加载器 ClassLoader parent = systemclassLoader.getParent(); System.out.println(parent); // 获取扩展类加载器的父类加载器-->根加载器（C/c++） ClassLoader parent1=parent.getParent(); System.out.println(parent1); // 测试当前类是哪个加载器加载的 ClassLoader classLoader = Class.forName(\"com.reflection.Test\").getClassLoader(); System.out.println(classLoader); // 测试JDK内置的类是谁加载的 classLoader = Class.forName(\"java.lang.object\").getclassLoader(); system.out.println(classloader); } 自定义网络类加载 import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; /** * 自定义网络类加载器 */ public class NetworkClassLoader extends ClassLoader { private String filePath; private String fileExtention = \".class\"; public NetworkClassLoader(String filePath) { this.filePath = filePath; } public Class findClass(String name) { System.out.println(\"findClass name=\" + name); byte[] bArr = null; try { bArr = loadClassData(name); } catch (IOException e) { e.printStackTrace(); } return defineClass(name, bArr, 0, bArr.length); } private byte[] loadClassData(String name) throws IOException { // name = \"annotatonreflection.NetworkClassLoader\"; name = name.replace(\".\", \"/\"); name += fileExtention; File file = new File(filePath, name); FileInputStream fileInputStream = new FileInputStream(file); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int len = -1; while ((len = fileInputStream.read()) != -1) { byteArrayOutputStream.write(len); } return byteArrayOutputStream.toByteArray(); } public static void main(String[] args) { NetworkClassLoader classLoader = new NetworkClassLoader(\"CDesktop\"); try { Class clazz = classLoader.loadClass(\"annotatonreflection.Person\"); Object obj = clazz.newInstance(); System.out.println(obj); // System.out.println(clazz.getClassLoader()); ClassLoader classLoader2 = clazz.getClassLoader(); while (classLoader2 != null) { System.out.println(classLoader2); classLoader2 = classLoader2.getParent(); } System.out.println(\"引导类加载器\"+classLoader2); //引导类加载器是null } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } } Class对象获取方式 获取Class对象的三种方式对应着java代码在计算机中的三个阶段 Source源代码阶段: Class.forName(\"全类名\")：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类。 Class类对象阶段: 类名.class：通过类名的属性class获取 多用于参数的传递 Runtime运行时阶段: 对象.getClass()：getClass()方法是定义在Objec类中的方法 多用于对象的获取字节码的方式 结论: 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，无论通过哪一种方式获取的Class对象都是同一个。 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。 Class clazz=Person.class； 已知某个类的实例，调用该实例的getClass（）方法获取Class对象 Class clazz=person.getClass()； 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException Class clazz=Class.forName(\"demo01.Student\"); 内置基本数据类型可以直接用类名.Type 还可以利用ClassLoader我们之后讲解 哪些类型可以有Class对象？ class: 外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。 interface: 接口 []: 数组 enum: 枚举 annotation: 注解@interface primitive type: 基本数据类型 void //所有关型Class public class Test{ public static void main(string[] args){ Class c1 = Object.class; // 类 Class c2 = Comparable.class; // 接口 class c3 = String[].class; // 一维数组 Class c4 = int[][].class; // 二维数组 Class c5 = Override.class; // 注解 Class c6 = ElementType.class; // 枚举 Class c7 = Integer.class; // 基本数据类型 Class c8 = void.class; // void Class c9 = Class.class; // class System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); System.out.println(c8); System.out.println(c9); int[] a = new int[10]; int[] b = new int[100]; system.out.println(a.getclass().hashcode(); } } @Test public void reflect() throws ClassNotFoundException { // 方式一：Class.forName(\"全类名\"); Class cls1 = Class.forName(\"com.test.domain.Person\"); //P erson自定义实体类 System.out.println(\"cls1 = \" + cls1); // 方式二：类名.class Class cls2 = Person.class; System.out.println(\"cls2 = \" + cls2); // 方式三：对象.getClass(); Person person = new Person(); Class cls3 = person.getClass(); System.out.println(\"cls3 = \" + cls3); // == 比较三个对象 System.out.println(\"cls1 == cls2 : \" + (cls1 == cls2)); //true System.out.println(\"cls1 == cls3 : \" + (cls1 == cls3)); //true // 方式四：基本内置类型的包装类都有一个Type属性 Class c4=Integer.TYPE; System.out.printin(c4); // 获得父类类型 Class c5=c1.getsuperclass(); System.out.printin(c5); } 反操作泛型 Method和Field、Constructor对象都有setAccessible）方法。 setAccessible作用是启动和禁用访问安全检查的开关。 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 使得原本无法访问的私有成员也可以访问 参数值为false则指示反射的对象应该实施Java语言访问检查 public class Test { public void testel(Map map,List list){ System.out.println(\"\"testo1\"); } public Maptesto2(){ System.out.println(\"testo2\"); return null; } public static void main(String[] args) throws NoSuchMethodException { Method method=Test11.class.getMethod(\"teste1\",Map.class,List.class); Type[] genericParameterTypes=method.getGenericParameterTypes(); for(Type genericParameterType:genericParameterTypes){ System.out.println(\"#\"+genericParameterType); if(genericParameterType instanceof ParameterizedType){ Type[] actualTypeArguments=((ParameterizedType)genericParameterType).getActualTypeArguments(); for (Type actualTypeArgument:actualTypeArguments){ System.out.println(actualTypeArgument); method=Test11.class.getMethod(name:\"testo2\",.…parameterTypes:null); Type genericReturnType=method.getGenericReturnType(); if(genericReturnType instanceof ParameterizedType){ Type[]actualTypeArguments=((ParameterizedType) genericReturnType).getActualTypeArguments(); for(Type actualTypeArgument:actualTypeArguments){ System.out.println(actualTypeArgument); } } } } } } } Class对象功能 获取功能 1）获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 2）获取构造方法们 Constructor[] getConstructors() Constructor getConstructor(类... parameterTypes) Constructor[] getDeclaredConstructors() Constructor getDeclaredConstructor(类... parameterTypes) 3）获取成员方法们 Method[] getMethods() Method getMethod(String name, 类... parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类... parameterTypes) 4）获取全类名和简单类名 String getName() Field：成员变量 设置值: void set(Object obj, Object value) 获取值: get(Object obj) 忽略访问权限修饰符的安全检查 setAccessible(true): 暴力反射 import lombok.Getter; import lombok.Setter; import lombok.ToString; @Setter @Getter @ToString public class Person { public String a; //最大范围public protected String b; //受保护类型 String c; //默认的访问权限 private String d; //私有类型 } // 测试getFields和getField(String name)方法 ** * 获取成员变量 * Field[] getFields() * Field getField(String name) */ @Test public void reflect() throws Exception { // 0. 获取Person的Class对象 Class personClass = Person.class; // 1. Field[] getFields()获取所有public修饰的成员变量 Field[] fields = personClass.getFields(); for(Field field : fields){ System.out.println(field); } System.out.println(\"=============================\"); // 2. Field getField(String name) Field a = personClass.getField(\"a\"); // 3. 获取成员变量a 的值 [也只能获取公有的，获取私有的或者不存在的字符会抛出异常] Person p = new Person(); Object value = a.get(p); System.out.println(\"value = \" + value); // 4 设置属性a的值 a.set(p,\"张三\"); System.out.println(p); } // 测试getDeclaredFields和getDeclaredField(String name)方法 /** * Field[] getDeclaredFields() * Field getDeclaredField(String name) */ @Test public void reflect3() throws Exception { Class personClass = Person.class; // Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Field[] declaredFields = personClass.getDeclaredFields(); for(Field filed : declaredFields){ System.out.println(filed); } System.out.println(\"===================================\"); // Field getDeclaredField(String name) Field d = personClass.getDeclaredField(\"d\"); //private String d; Person p = new Person(); // Object value1 = d.get(p); //会抛出异常 // System.out.println(\"value1 = \" + value1); //对于私有变量虽然能会获取到，但不能直接set和get //忽略访问权限修饰符的安全检查 d.setAccessible(true);//暴力反射 Object value2 = d.get(p); System.out.println(\"value2 = \" + value2); } 没有忽略访问修饰符直接访问抛出的异常 Constructor:构造方法 创建对象：T newInstance(Object... initargs) 注意：如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 import lombok.Getter; import lombok.Setter; import lombok.ToString; @Setter @Getter @ToString public class Person { private String name; private Integer age; //无参构造函数 public Person() {} //单个参数的构造函数，且为私有构造方法 private Person(String name){} //有参构造函数 public Person(String name, Integer age) { this.name = name; this.age = age; } } ````java /** 获取构造方法们 Constructor[] getConstructors() Constructor getConstructor(类... parameterTypes) */ @Test public void reflect4() throws Exception { Class personClass = Person.class; //Constructor[] getConstructors() Constructor[] constructors = personClass.getConstructors(); for(Constructor constructor : constructors){ // Constructor 对象reflect包下的 import java.lang.reflect.Constructor; System.out.println(constructor); } System.out.println(\"==========================================\"); // 获取无参构造函数 注意：Person类中必须要有无参的构造函数，不然抛出异常 Constructor constructor1 = personClass.getConstructor(); System.out.println(\"constructor1 = \" + constructor1); // 获取到构造函数后可以用于创建对象 Object person1 = constructor1.newInstance(); // Constructor类内提供了初始化方法newInstance();方法 System.out.println(\"person1 = \" + person1); System.out.println(\"==========================================\"); // 获取有参的构造函数// public Person(String name, Integer age) // 参数类型顺序要与构造函数内一致，且参数类型为字节码类型 Constructor constructor2 = personClass.getConstructor(String.class,Integer.class); System.out.println(\"constructor2 = \" + constructor2); // 创建对象 Object person2 = constructor2.newInstance(\"张三\", 23);// 获取的是有参的构造方法，就必须要给参数 System.out.println(person2); System.out.println(\"=========================================\"); // 对于一般的无参构造函数，我们都不会先获取无参构造器之后在进行初始化。 // 而是直接调用Class类内的newInstance()方法 Object person3 = personClass.newInstance(); System.out.println(\"person3 = \" + person3); // 我们之前使用的 Class.forName(\"\").newInstance // 其本质上就是调用了类内的无参构造函数来完成实例化的 // 以后在使用 Class.forName(\"\").newInstance; 反射创建对象时，一定要保证类内有无参构造函数 } ```` 对于getDeclaredConstructor方法和getDeclaredConstructors方法 getDeclaredConstructor方法可以获取到任何访问权限的构造器，而getConstructor方法只能获取public修饰的构造器。此外在构造器的对象内也有setAccessible(true);方法，并设置成true就可以操作了。 ​ 关于为什么要使用private访问权限的构造器，使用这个构造器不就不能外部访问了嘛，不也就无法进行实例化对象了吗？无法在类的外部实例化对象正是私有构造器的意义所在，在单例模式下经常使用，整个项目只有一个对象，外部无法实例化对象，可以在类内的进行实例化并通过静态方法返回（由于实例化的对象是静态的，故只有一个对象，也就是单例的）。 网上说这就是单例模式中的饿汉模式，不管是否调用，都创建一个对象。 class SingletonDemo{ // 私有化构造方法 private SingletonDemo(){ } // 创建一个对象 类内实例化（静态的对象） private static SingletonDemo singleton = new SingletonDemo(); // 提供public方法供外部访问，返回这个创建的对象 public static SingletonDemo getInstance(){ return singleton; } } public class Singleton { public static void main(String[] args) { SingletonDemo s1 = SingletonDemo.getInstance(); //输出对象的地址，如果有地址存在，则说明对象创建成功并获取到 System.out.println(s1); SingletonDemo s2 = SingletonDemo.getInstance(); //如果结果为true，则说明是同一个对象 System.out.println(s1==s2); //输出结果为true } } Method：方法对象 执行方法：Object invoke(Object obj, Object... args) 获取方法名称：String getName(); import lombok.Getter; import lombok.Setter; import lombok.ToString; @Setter @Getter @ToString public class Person { private String name; private Integer age; //无参构造函数 public Person() {} //有参构造函数 public Person(String name, Integer age) { this.name = name; this.age = age;} //无参方法 public void eat(){ System.out.println(\"eat...\"); } //重载有参方法 public void eat(String food){ System.out.println(\"eat...\"+food); } } invoke方法 /** * 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类... parameterTypes) */ @Test public void reflect5() throws Exception { Class personClass = Person.class; // 获取指定名称的方法 Method eat_method1 = personClass.getMethod(\"eat\"); // 执行方法 Person person = new Person(); Object rtValue = eat_method1.invoke(person); //如果方法有返回值类型可以获取到，没有就为null // 输出返回值 eat方法没有返回值，故输出null System.out.println(\"rtValue = \" + rtValue); System.out.println(\"--------------------------------------------\"); // 获取有参的构造函数 有两个参数 第一个方法名 第二个参数列表 ，不同的参数是不同的方法（重载） Method eat_method2 = personClass.getMethod(\"eat\", String.class); //执行方法 eat_method2.invoke(person,\"饭\"); System.out.println(\"============================================\"); //获取方法列表 Method[] methods = personClass.getMethods(); for(Method method : methods){ //注意：获取到的方法名称不仅仅是我们在Person类内看到的方法 System.out.println(method); //继承下来的方法也会被获取到（当然前提是public修饰的） } } getName方法 getName()方法获取的方法名是仅仅就是方法名（不带全类名），且不带有参数列表。 @Test public void reflect6() throws NoSuchMethodException { Class personClass = Person.class; Method[] methods = personClass.getMethods(); for(Method method : methods){ System.out.println(method); // 获取方法名 String name = method.getName(); System.out.println(name); } } 获取类名 getClass()方法是Object类的方法，需要注意一点获取的类名是全类名（带有路径） @Test public void reflect7(){ Class personClass = Person.class; String className = personClass.getName(); System.out.println(className); } 关于获取成员方法们的另外两个方法 同之前的叙述一样，带有Declared关键字的方法这两个方法，可以获取到任意修饰符的方法。同样的提供了setAccessible(true);方法进行暴力反射。 Method和Field、Constructor对象都有setAccessible）方法。 setAccessible作用是启动和禁用访问安全检查的开关。 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 使得原本无法访问的私有成员也可以访问>参数值为false则指示反射的对象应该实施Java语言访问检查 综上说述：对于反射机制来说，在反射面前没有公有私有，都可以通过暴力反射解决。 Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类... parameterTypes) method.setAccessible(true); //暴力反射 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Java进阶_注解.html":{"url":"chapters/Java进阶_注解.html","title":"Java进阶_注解","keywords":"","body":"注解基础概念预定义注解自定义注解元注解使用注解案例分析测试框架ORM实例 [TOC] 【黑马程序员-Java语言高级部分9.3】Java 注解 注解基础概念 注释：用文字描述程序的，给程序员看的 百度上的解释： Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制，是一种代码级别的说明。Java 语言中的类、方法、变量、参数和包等都可以被标注。 和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。 概念描述： JDK1.5 之后的新特性 用来说明程序的 使用注解：@注解名称 作用分类 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 编写文档：通过代码里标识的注解生成文档，API文档是通过抽取代码中的文档注释生成的。 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 大多数时候，我们会使用注解而不是自定义注解 注解给编译器和解析程序用 注解不是程序的一部分，可以理解为标签 预定义注解 @Override：检测被该注解标注的方法是否搜集继承自父类(接口)的，定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明 @Deprecated：将该注解标注的内容，表示已过时，定义在java.lang.Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择 @SuppressWarnings：压制警告，一般传递参数all，定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息。与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了 如@SuppressWarnings(\"all\")、@SuppressWarnings(\"all\")、@SuppressWarnings(\"unchecked\")、@SuppressWarnings(value={\"unchecked\",\"deprecation\"}) 自定义注解 基本格式 @元注解 public @interface 注解名称{} 注解的本质: 注解本质上就是一个接口，该接口默认继承java.lang.annotation.Annotation接口 // 将以下注解编译过后进行反编译，得到结果： // 1. 编译前 public @interface MyAnno{ String name default \"hyc\"; // 每一个方法实际上是声明了一个配置参数，本质上是抽象方法 // 方法的名称就是参数的名称 // 返回值类型就是参数的类型（返回值只能是基本类型，注解，String，Enum，以上类型的数组) // 可以通过default来声明参数的默认值 // 如果只有一个参数成员，一般参数名为value，那么value可以省略，直接赋值即可 // 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值 // 数组赋值时，值使用大括号包裹，如果数组中只有一个值，那么{}可以省略 } // 2. 反编译后 public interface MyAnno extends java.lang.annotation.Annotation{} 元注解 概念：用于描述注解的注解。 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明。这些类型和它们所支持的类在java.lang.annotation包中可以找到。 @Target：描述能够作用的位置（即：被描述的注解可以用在什么地方） @Target(value = {ElementType.TYPE,ElementType.METHOD,ElementType.FIELD}) //表示该MyAnno注解可以同时作用于类上，方法上和成员变量上 public @interface MyAnno {} 其中value中ElementType取值可以有以下几种情况： TYPE:可以作用在类上 METHOD:可以作用在方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段，用于描述注解的生命周期 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到字节码文件中，并被JVM读取到，一般自己定义的注解都加RUNTIME @Documented：描述该注解是否会被抽取到api文档中 @Inherited：描述注解是否被子类继承 使用注解 注解在程序中经常和反射一起使用，注解大多数来说都是用来替换配置文件的 import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.TYPE) //可以被作用在类上 @Retention(RetentionPolicy.RUNTIME) public @interface AnnoReflect { String className(); String methodName(); } // 使用注解的方式来淘汰配置文件(注释很重要)： import java.io.InputStream; import java.lang.reflect.Method; import java.util.Properties; @AnnoReflect(className = \"cn.other.annotation.AnnoTest\",methodName = \"play\") public class ReflectAnnotationTest { public static void main(String[] args) throws Exception { /** * 前提：不能改变该类的任何代码。可以创建任意类的对象，可以执行任意方法 * 即：拒绝硬编码 */ //1. 解析注解 //1.1 获取该类的字节码文件对象 Class rac = ReflectAnnotationTest.class; //1.2 获取上面的注解对象,其实就是在内存中生成了一个该注解接口的子类实现对象 AnnoReflect an = rac.getAnnotation(AnnoReflect.class); /* 相当于 public class AnnotationReflect implements AnnoReflect{ public String className(){ return \"cn.other.annotation.AnnoTest1\"; } public String methodName(){ return \"play\"; } } */ //2. 调用注解对象中定义的抽象方法，获取返回值 String className = an.className(); String methodName = an.methodName(); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); } } 在程序中使用注解：获取注解中定义的属性值 获取注解定义的位置的对象 (Class, Method, Field) 获取指定的注解：getAnnotation(Class) 调用注解中的抽象方法获取配置的属性值 案例分析 测试框架 需求：设计一个框架，检测一个类中的方法使用有异常，并进行统计。 public class calculator { @Check public void add(){ System.out.println(\"1+0=\"+(1+0)); } @Check public void sub(){ System.out.println(\"1-0=\"+(1-0)); } @Check public void mul(){ System.out.println(\"1*0=\"+(1*0)); } @Check public void div(){ System.out.println(\"1/0=\"+(1/0)); } public void show(){ System.out.println(\"今天天气真不错！\"); } } // 自定义一个注解 @Retention(RetentionPolicy.RUNTIME) //运行时 @Target(ElementType.METHOD) //加在方法前面 public @interface Check {} 编写一个类专门用于检查(注意注释)： import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; // 简单的测试框架 // 当主方法执行后，会自动自行检测所有方法(加了check注解的方法)，判断方法是否有异常并记录 public class TestCheck { public static void main(String[] args) throws IOException { //1. 创建计算机对象 calculator c = new calculator(); //2. 获取字节码文件对象 Class cls = c.getClass(); //3. 获取所有方法 Method[] methods = cls.getMethods(); int num = 0; //记录出现异常的次数 BufferedWriter bw = new BufferedWriter(new FileWriter(\"bug.txt\")); for(Method method:methods){ //4. 判断方法上是否有Check注解 if(method.isAnnotationPresent(Check.class)){ //5. 有注解就执行,捕获异常 try { method.invoke(c); } catch (Exception e) { e.printStackTrace(); //6.将异常记录在文件中 num++; bw.write(method.getName()+\"方法出异常了\"); bw.newLine(); bw.write(\"异常的名称是：\"+e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(\"异常原因：\"+e.getCause().getMessage()); bw.newLine(); bw.write(\"=====================\"); bw.newLine(); } } } bw.write(\"本次测试一共出现\"+num+\"次异常\"); bw.flush(); bw.close(); } } 运行TestCheck类中的主方法，就会自动检查所有注解@Check的方法是否异常： ORM实例 // 类名的注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface Tablekuang{ string value(); } // 属性的注解 @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface Fieldkuang{ String columnName(); string type(); int length(); } @Tablekuang(\"db_student\") class student{ @Fieldkuang(columnName=\"db_id\",type=\"int\",length =10) private int id; @Fieldkuang(columnName=\"db_age\",type=\"int\",length=10) private int age; @Fieldkuang(columnName =\"db_name\",type =\"\"varchar\",length=3) private String name; public student(){} public student(int id,int age,String name){ this.id=id; this.age=age; this.name=name; } } public static void main(string[] args) throws ClassNotFoundException { Class c1=Class.forName(\"com.huangy.reflection.Student\"); //通过反射获得注解 Annotation[] annotations=c1.getAnnotations(); annotations.foreach(System.out::println); //获得注解的alue的值。 Tablekuang tablekuang =(Tablekuang)c1.getAnnotation(Tablekuang.class); System.out.printn(ablekuang.value()); //获得类指定的注解 Field f=c1.getDeclaredField(\"name\"); Fieldkuang annotation=f.getAnnotation(Fieldkuang.class); System.out.println(annotation.columnName()); System.out.println(annotation.type()); System.out.println(annotation.length()); } Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/MySQL_基础.html":{"url":"chapters/MySQL_基础.html","title":"MySQL_基础","keywords":"","body":"基础概念数据库软件SQL基础DDL: 操作数据库、表操作数据库：CRUD操作表DML: 增删改表中数据DQL: 查询表中的记录语法基础查询条件查询排序查询聚合函数分组查询分页查询DCL：管理用户和授权用户管理添加用户删除用户修改用户密码忘记密码查询用户权限管理查询权限授予权限撤销权限 [TOC] 【黑马程序员-Java语言高级部分10】MySQL入门学习 基础概念 数据库的英文单词： DataBase(简称DB) 数据库: 用于存储和管理数据的仓库 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 -- SQL 常见的数据库软件 数据库软件 安装 卸载 去mysql的安装目录找到my.ini文件 复制 datadir=\"C:/ProgramData/MySQL/MySQL Server 5.5/Data/\" 卸载MySQL 删除C:/ProgramData目录下的MySQL文件夹。 配置 MySQL服务启动 手动 cmd--> services.msc 打开服务的窗口 使用管理员打开cmd net start mysql : 启动mysql的服务 net stop mysql:关闭mysql服务 MySQL登录 mysql -uroot -p密码 mysql -hip -uroot -p连接目标的密码 mysql --host=ip --user=root --password=连接目标的密码 MySQL退出(exit or quit) MySQL目录结构 MySQL安装目录：basedir=\"D:/develop/MySQL/\" 配置文件 my.ini MySQL数据目录：datadir=\"C:/ProgramData/MySQL/MySQL Server 5.5/Data/\" 几个概念 数据库：文件夹 表：文件 数据：数据 SQL基础 什么是SQL Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3种注释 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 多行注释: / 注释 / SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL: 操作数据库、表 操作数据库：CRUD C(Create): 创建 创建数据库： create database 数据库名称; 创建数据库，判断不存在，再创建： create database if not exists 数据库名称; 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk create database if not exists db4 character set gbk; R(Retrieve)：查询 查询所有数据库的名称: show databases; 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; U(Update): 修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; D(Delete): 删除 删除数据库 drop database 数据库名称; 判断数据库存在，存在再删除 drop database if exists 数据库名称; 使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 use 数据库名称; 操作表 C(Create): 创建 create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); 注意：最后一列，不需要加逗号（,） 数据库类型： int：整数类型 age int, double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串 name varchar(20): 姓名最大20个字符 zhangsan 8个字符 张三 2个字符 创建表: create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); 复制表： create table 表名 like 被复制的表名; R(Retrieve): 查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; U(Update): 修改 修改表名 alter table 表名 rename to 新的表名; 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; D(Delete):删除 drop table 表名; drop table if exists 表名 ; DML: 增删改表中数据 添加数据： insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); 注意: 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据： delete from 表名 [where 条件] 注意: 如果不加条件，则删除表中所有记录。 如果要删除所有记录 delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 修改数据： update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; 注意: 如果不加任何条件，则会将表中所有记录全部修改。 备用 DQL: 查询表中的记录 语法 select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定; 基础查询 多个字段的查询 select 字段名1，字段名2... from 表名； 注意：如果查询所有字段，则可以使用*来替代字段列表。 去除重复: distinct 计算列 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 如果该字段为null后的替换值。 起别名 as：as也可以省略 备用 条件查询 where子句后跟条件 运算符 > 、= 、= 、<> BETWEEN...AND IN( 集合) LIKE：模糊查询 占位符： _: 单个任意字符 %：多个任意字符 IS NULL and 或 && or 或 || not 或 ! 示例 -- 查询年龄大于20岁 SELECT * FROM student WHERE age > 20; SELECT * FROM student WHERE age >= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age <> 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age >= 20 && age = 20 AND age 备用 排序查询 语法：order by 子句 order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... 排序方式： ASC：升序，默认的。 DESC：降序。 注意： 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 聚合函数 将一列数据作为一个整体，进行纵向的计算 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注意：聚合函数的计算，排除null值。 解决方案： 选择不包含非空的列进行计算 IFNULL函数 分组查询 语法：group by 分组字段； 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。 having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id) > 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数 > 2; 分页查询 语法：limit 开始的索引,每页查询的条数; 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 limit 是一个MySQL\"方言\" -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 DCL：管理用户和授权 用户管理 添加用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 删除用户 DROP USER '用户名'@'主机名'; 修改用户密码 UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名'; UPDATE USER SET PASSWORD = PASSWORD('abc') WHERE USER = 'lisi'; SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码'); SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123'); 忘记密码 管理员运行cmd net stop mysql --停止mysql服务 使用无验证方式启动mysql服务 mysqld --skip-grant-tables 使用无验证方式启动mysql服务 打开新的cmd窗口,直接输入mysql命令，敲回车就可以登录成功 use mysql; update user set password = password('你的新密码') where user = 'root'; 关闭两个窗口 打开任务管理器，手动结束mysqld.exe 的进程 启动mysql服务，使用新密码登录 查询用户 -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; -- * 通配符： % 表示可以在任意主机使用用户登录数据库 权限管理 查询权限 SHOW GRANTS FOR '用户名'@'主机名'; SHOW GRANTS FOR 'lisi'@'%'; 授予权限 -- 授予权限 grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 撤销权限 -- 撤销权限 revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%'; Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/MySQL_约束.html":{"url":"chapters/MySQL_约束.html","title":"MySQL_约束","keywords":"","body":"约束唯一约束：unique主键约束：primary key外键约束：foreign key级联操作 [TOC] MySQL约束与设计 约束 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 非空约束：not null，值不能为null -- 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); -- 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; -- 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束：unique 值不能重复 -- 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); -- 注意mysql中，唯一约束限定的列的值可以有多个null -- 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; -- 在创建表后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; 主键约束：primary key 注意： 含义：非空且唯一 一张表只能有一个字段为主键 主键就是表中记录的唯一标识 -- 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); -- 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; -- 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; -- 自动增长： -- 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 -- 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); -- 删除自动增长 ALTER TABLE stu MODIFY id INT; -- 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 外键约束：foreign key 让表于表产生关系，从而保证数据的正确性。 -- 在创建表时，可以添加外键 create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); -- 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; -- 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作 -- 添加级联操作 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE; -- 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/MySQL_多表查询.html":{"url":"chapters/MySQL_多表查询.html","title":"MySQL_多表查询","keywords":"","body":"sql准备内连接查询隐式内连接显式内连接外连接查询左外连接右外连接子查询子查结果是单行单列子查询结果是多行单列子查询结果是多行多列多表查询练习附录 [TOC] MySQL多表查询与事务的操作 sql准备 # 创建部门表 CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO dept (NAME) VALUES ('开发部'),('市场部'),('财务部'); # 创建员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('孙悟空','男',7200,'2013-02-24',1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('猪八戒','男',3600,'2010-12-02',2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('唐僧','男',9000,'2008-08-08',2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('白骨精','女',5000,'2015-10-07',3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES('蜘蛛精','女',4500,'2011-03-14',1); 内连接查询 从哪些表中查询数据、条件是什么、查询哪些字段 隐式内连接 使用where条件消除无用数据 -- 查询所有员工信息和对应的部门信息 SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`; -- 查询员工表的名称，性别。部门表的名称 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称 FROM emp t1, dept t2 WHERE t1.`dept_id` = t2.`id`; 显式内连接 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 外连接查询 左外连接 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； -- 查询的是左表所有数据以及其交集部分。 -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； -- 查询的是右表所有数据以及其交集部分 SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 子查询 概念：查询中嵌套查询，称嵌套查询为子查询 -- 查询工资最高的员工信息 -- 1 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); 子查结果是单行单列 子查询可以作为条件，使用运算符去判断。 运算符： > >= -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary 子查询结果是多行单列 子查询可以作为条件，使用运算符in来判断 -- 查询'财务部'和'市场部'所有的员工信息 SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部'; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = '财务部' OR NAME = '市场部'); 子查询结果是多行多列 子查询可以作为一张虚拟表参与查询 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > '2011-11-11') t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` > '2011-11-11' 多表查询练习 见表语句详见附录 -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 /* 分析： 1.员工编号，员工姓名，工资，需要查询emp表 职务名称，职务描述 需要查询job表 2.查询条件 emp.job_id = job.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description` -- 职务描述 FROM emp t1, job t2 WHERE t1.`job_id` = t2.`id`; -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 /* 分析： 1. 员工编号，员工姓名，工资 emp 职务名称，职务描述 job 部门名称，部门位置 dept 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description`, -- 职务描述 t3.`dname`, -- 部门名称 t3.`loc` -- 部门位置 FROM emp t1, job t2,dept t3 WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`; -- 3.查询员工姓名，工资，工资等级 /* 分析： 1.员工姓名，工资 emp 工资等级 salarygrade 2.条件 emp.salary >= salarygrade.losalary and emp.salary -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 /* 分析： 1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept 工资等级 salarygrade 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */ SELECT t1.`ename`, t1.`salary`, t2.`jname`, t2.`description`, t3.`dname`, t3.`loc`, t4.`grade` FROM emp t1,job t2,dept t3,salarygrade t4 WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`; -- 5.查询出部门编号、部门名称、部门位置、部门人数 /* 分析： 1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表 2.使用分组查询。按照emp.dept_id完成分组，查询count(id) 3.使用子查询将第2步的查询结果和dept表进行关联查询 */ SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.total FROM dept t1, (SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2 WHERE t1.`id` = t2.dept_id; -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 /* 分析： 1.姓名 emp， 直接上级的姓名 emp emp表的id 和 mgr 是自关联 2.条件 emp.id = emp.mgr 3.查询左表的所有数据，和 交集数据 使用左外连接查询 */ SELECT t1.ename, t1.mgr, t2.`id`, t2.`ename` FROM emp t1 LEFT JOIN emp t2 ON t1.`mgr` = t2.`id`; 附录 -- 部门表 CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,'教研部','北京'), (20,'学工部','上海'), (30,'销售部','广州'), (40,'财务部','深圳'); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, '董事长', '管理整个公司，接单'), (2, '经理', '管理部门员工'), (3, '销售员', '向客人推销产品'), (4, '文员', '使用办公软件'); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20), (1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30), (1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30), (1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20), (1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30), (1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30), (1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10), (1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20), (1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10), (1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30), (1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20), (1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30), (1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20), (1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10); -- 工资等级表 CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资 ); -- 添加5个工资等级 INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); -- 需求： -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 -- 3.查询员工姓名，工资，工资等级 -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 -- 5.查询出部门编号、部门名称、部门位置、部门人数 -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/MySQL_事务.html":{"url":"chapters/MySQL_事务.html","title":"MySQL_事务","keywords":"","body":"基本介绍事务四大特征事务隔离级别演示例子事务提交 [TOC] MySQL多表查询与事务的操作 基本介绍 概念：一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作： 事务四大特征 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 事务隔离级别 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题 存在问题 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别 read uncommitted：读未提交(产生的问题：脏读、不可重复读、幻读) A事务还没执行提交，B事务已经可以查到数据了 read committed：读已提交 (Oracle)(产生的问题：不可重复读、幻读) A事务执行提交，B事务在同一次查询中查到已被修改的数据 repeatable read：可重复读 (MySQL默认)(产生的问题：幻读) 忽略A事务执行状态，B事务在同一次查询中数据不会变化 serializable：串行化(可以解决所有的问题) 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别 select @@tx_isolation; 数据库设置隔离级别 set global transaction isolation level 级别字符串; 演示 set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2; 例子 CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES ('zhangsan', 1000), ('lisi', 1000); SELECT * FROM account; UPDATE account SET balance = 1000; -- 张三给李四转账 500 元 -- 0. 开启事务 START TRANSACTION; -- 失败的话会回滚到这里 -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = 'zhangsan'; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = 'lisi'; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 事务提交 自动提交： mysql就是自动提交的 一条DML(增删改)语句会自动提交一次事务 手动提交： Oracle 数据库默认是手动提交事务 需要先开启事务，再提交 修改事务的默认提交方式： 查看事务的默认提交方式 SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 修改默认提交方式 set @@autocommit = 0; Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/MySQL_数据库设计.html":{"url":"chapters/MySQL_数据库设计.html","title":"MySQL_数据库设计","keywords":"","body":"表间关系关系分类案例设计范式基本概念示例普通表1NF2NF3NF数据库备份和还原 [TOC] 表间关系 MySQL约束与设计 关系分类 一对一(了解)： 如：人和身份证 分析：一个人只有一个身份证，一个身份证只能对应一个人 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键 一对多(多对一)： 如：部门和员工 分析：一个部门有多个员工，一个员工只能对应一个部门 实现方式：在多的一方建立外键，指向一的一方的主键 多对多： 如：学生和课程 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 案例 -- 创建旅游线路分类表 tab_category -- cid 旅游线路分类主键，自动增长 -- cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); -- 创建旅游线路表 tab_route /* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 */ CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT '男', telephone VARCHAR(11), email VARCHAR(100) ); /*创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 */ CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 设计范式 基本概念 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 分类: 第一范式(1NF)：每一列都是不可分割的原子数据项 第二范式(2NF)：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 函数依赖：A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号-->姓名 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：(学号, 课程名称) --> 分数 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：(学号, 课程名称) -- > 姓名 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号-->系名，系名-->系主任 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：(学号, 课程名称) 主属性：码属性组中的所有属性 非主属性：除了码属性组的属性 第三范式(3NF)：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 示例 普通表 学号 姓名 系名 系主任 课程名称 分数 10010 张无忌 经济系 张三丰 高等数学 95 10010 张无忌 经济系 张三丰 大学英语 87 10010 张无忌 经济系 张三丰 计算机基础 65 10011 令狐冲 法律系 任我行 法理学 77 10011 令狐冲 法律系 任我行 大学英语 87 10011 令狐冲 法律系 任我行 法律社会学 65 10012 杨过 法律系 任我行 法律社会学 95 10012 杨过 法律系 任我行 法理学 97 10012 杨过 法律系 任我行 大学英语 99 1NF 学号 姓名 系名 系主任 课程名称 分数 10010 张无忌 经济系 张三丰 高等数学 95 10010 张无忌 经济系 张三丰 大学英语 87 10010 张无忌 经济系 张三丰 计算机基础 65 10011 令狐冲 法律系 任我行 法理学 77 10011 令狐冲 法律系 任我行 大学英语 87 10011 令狐冲 法律系 任我行 法律社会学 65 10012 杨过 法律系 任我行 法律社会学 95 10012 杨过 法律系 任我行 法理学 97 10012 杨过 法律系 任我行 大学英语 99 计算机系 殷天正 存在的问题： 存在非常严重的数据冗余(重复)：姓名、系名、系主任 数据添加存在问题：添加新开设的系和系主任时，数据不合法 数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。 2NF 选课表 学号 课程名称 分数 10010 高等数学 95 10010 大学英语 87 10010 计算机基础 65 10011 法理学 77 10011 大学英语 87 10011 法律社会学 65 10012 法律社会学 95 10012 法理学 97 10012 大学英语 99 学生表 学号 姓名 系名 系主任 10010 张无忌 经济系 张三丰 10011 令狐冲 法律系 任我行 10012 杨过 法律系 任我行 计算机系 殷天正 存在的问题： 数据添加存在问题：添加新开设的系和系主任时，数据不合法 数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。 3NF 选课表 学号 课程名称 分数 10010 高等数学 95 10010 大学英语 87 10010 计算机基础 65 10011 法理学 77 10011 大学英语 87 10011 法律社会学 65 10012 法律社会学 95 10012 法理学 97 10012 大学英语 99 学生表 学号 姓名 系名 10010 张无忌 经济系 10011 令狐冲 法律系 10012 杨过 法律系 系表 系名 系主任 经济系 张三丰 法律系 任我行 计算机系 殷天正 刚刚所有的三个问题全部被解决掉！！！ 数据库备份和还原 命令行： 备份： mysqldump -u用户名 -p密码 数据库名称 > 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行文件 (source 文件路径) 图形化工具： Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/JDBC_JDBC基础.html":{"url":"chapters/JDBC_JDBC基础.html","title":"JDBC_JDBC基础","keywords":"","body":"基础概念快速入门关键对象DriverManager(驱动管理对象)Connection(数据库连接对象)Statement(执行sql的对象)ResultSet(结果集对象)PreparedStatement(执行sql的对象)JDBC工具类修改记录添加记录删除记录执行DDL语句查询并封装JDBC控制事务 [TOC] 【黑马程序员-Java语言高级部分11】JDBC 基础概念 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC笔记 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键-->Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 代码实现 // 1. 导入驱动jar包 // 2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 3.获取数据库连接对象 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\"); // 4.定义sql语句 String sql = \"update account set balance = 500 where id = 1\"; // 5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); // 6.执行sql int count = stmt.executeUpdate(sql); // 7.处理结果 System.out.println(count); // 8.释放资源 stmt.close(); conn.close(); 关键对象 DriverManager(驱动管理对象) 功能： // 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 // 写代码使用： Class.forName(\"com.mysql.jdbc.Driver\"); // 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); } } // 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 // 2. 获取数据库连接： // 方法：static Connection getConnection(String url, String user, String password) // 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 Connection(数据库连接对象) 获取执行sql 的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement(执行sql的对象) boolean execute(String sql) ：可以执行任意的sql 了解 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值>0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql): 执行DQL(select)语句 示例: Statement stmt = null; Connection conn = null; try { // 1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 2. 定义sql String sql = \"insert into account values(null,'王五',3000)\"; // 3. 获取Connection对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); // 4. 获取执行sql的对象 Statement stmt = conn.createStatement(); // 5. 执行sql int count = stmt.executeUpdate(sql);//影响的行数 // 6. 处理结果 System.out.println(count); if(count > 0){ System.out.println(\"添加成功！\"); }else{ System.out.println(\"添加失败！\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { // 7. 释放资源 // 避免空指针异常 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } ResultSet(结果集对象) boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数): 获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(\"balance\") // 循环判断游标是否是最后一行末尾。 while(rs.next()){ // 获取数据 // 6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); } PreparedStatement(执行sql的对象) QL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户随便，输入密码：a' or 'a' = 'a sql：select * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' 解决sql注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 驱动jar包 mysql-connector-java-5.1.37-bin.jar 注册驱动 获取数据库连接对象 Connection 定义sql sql的参数使用?作为占位符。 如：select * from user where username=? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值 setXxx(位置编号, 参数值) 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 优点 可以防止SQL注入 效率更高 JDBC工具类 目的：简化书写 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性 解决：配置文件 jdbc.properties url=jdbc:mysql:///db3 user=root password=root driver=com.mysql.jdbc.Driver import java.io.FileReader; import java.io.IOException; import java.net.URL; import java.sql.*; import java.util.Properties; /** * JDBC工具类 */ public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式--->ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); //2. 加载文件 pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 修改记录 package cn.itcast.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; /** * account表 修改记录 */ public class JDBCDemo3 { public static void main(String[] args) { Connection conn = null; Statement stmt = null; try { //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //3.定义sql String sql = \"update account set balance = 1500 where id = 3\"; //4.获取执行sql对象 stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql); //6.处理结果 System.out.println(count); if(count > 0){ System.out.println(\"修改成功！\"); }else{ System.out.println(\"修改失败\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { //7.释放资源 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 添加记录 package cn.itcast.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; /** * account表 添加一条记录 insert 语句 */ public class JDBCDemo2 { public static void main(String[] args) { Statement stmt = null; Connection conn = null; try { //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2. 定义sql String sql = \"insert into account values(null,'王五',3000)\"; //3.获取Connection对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count > 0){ System.out.println(\"添加成功！\"); }else{ System.out.println(\"添加失败！\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 删除记录 package cn.itcast.jdbc; import cn.itcast.util.JDBCUtils; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Statement; /** * account表 删除一条记录 */ public class JDBCDemo4 { public static void main(String[] args) { Connection conn = null; Statement stmt = null; try { //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //conn = JDBCUtils.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //3.定义sql String sql = \"delete from account where id = 3\"; //4.获取执行sql对象 stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql); //6.处理结果 System.out.println(count); if(count > 0){ System.out.println(\"删除成功！\"); }else{ System.out.println(\"删除失败\"); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { //7.释放资源 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 执行DDL语句 package cn.itcast.jdbc; import java.sql.*; /** * 执行DDL语句 */ public class JDBCDemo7 { public static void main(String[] args) { Connection conn = null; Statement stmt = null; ResultSet rs = null; try { //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //3.定义sql String sql = \"select * from account\"; //4.获取执行sql对象 stmt = conn.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); //6.处理结果 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { //7.释放资源 if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } } 查询并封装 import cn.itcast.domain.Emp; import cn.itcast.util.JDBCUtils; import java.sql.*; import java.util.ArrayList; import java.util.List; /** * * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 */ public class JDBCDemo8 { public static void main(String[] args) { List list = new JDBCDemo8().findAll2(); System.out.println(list); System.out.println(list.size()); } /** * 查询所有emp对象 * @return */ public List findAll(){ Connection conn = null; Statement stmt = null; ResultSet rs = null; List list = null; try { //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //3.定义sql String sql = \"select * from emp\"; //4.获取执行sql的对象 stmt = conn.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); //6.遍历结果集，封装对象，装载集合 Emp emp = null; list = new ArrayList(); while(rs.next()){ //获取数据 int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); // 创建emp对象,并赋值 emp = new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); //装载集合 list.add(emp); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } return list; } /** * 演示JDBC工具类 * @return */ public List findAll2(){ Connection conn = null; Statement stmt = null; ResultSet rs = null; List list = null; try { /* //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\");*/ conn = JDBCUtils.getConnection(); //3.定义sql String sql = \"select * from emp\"; //4.获取执行sql的对象 stmt = conn.createStatement(); //5.执行sql rs = stmt.executeQuery(sql); //6.遍历结果集，封装对象，装载集合 Emp emp = null; list = new ArrayList(); while(rs.next()){ //获取数据 int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); // 创建emp对象,并赋值 emp = new Emp(); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); //装载集合 list.add(emp); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return list; } } JDBC控制事务 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤同时成功或同时失败。 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() ，当所有sql都执行完提交事务 回滚事务：rollback() ，在catch中回滚事务 import cn.itcast.util.JDBCUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; /** * 事务操作 */ public class JDBCDemo10 { public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = \"update account set balance = balance - ? where id = ?\"; //2.2 李四 + 500 String sql2 = \"update account set balance = balance + ? where id = ?\"; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); } catch (Exception e) { //事务回滚 try { if(conn != null) { conn.rollback(); } } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); } } } Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/JDBC_JDBC连接池.html":{"url":"chapters/JDBC_JDBC连接池.html","title":"JDBC_JDBC连接池","keywords":"","body":"数据库连接池C3P0Druid [TOC] 【黑马程序员-Java语言高级部分11】JDBC 数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处：节约资源+用户访问高效 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：Connection.close()。 如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0 数据库连接池技术 步骤： 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/db4 root root 5 10 3000 com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/db3 root root 5 8 1000 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接： getConnection // 1. 创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); // 2. 获取连接对象 Connection conn = ds.getConnection(); Druid 数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件： druid.properties形式 可以叫任意名称，可以放在任意目录下 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///db3 username=root password=root # 初始化连接数量 initialSize=5 # 最大连接数 maxActive=10 # 最大等待时间 maxWait=3000 加载properties配置文件 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 获取连接：getConnection // 3. 加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); // 4. 获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); // 5. 获取连接 Connection conn = ds.getConnection(); JDBCUtils.java import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import java.io.IOException; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; /** * Druid连接池的工具类 */ public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ close(null,stmt,conn); } public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } } Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/JDBC_JDBCTemplate.html":{"url":"chapters/JDBC_JDBCTemplate.html","title":"JDBC_JDBCTemplate","keywords":"","body":"Spring JDBC主要功能使用示例 【黑马程序员-Java语言高级部分11】JDBC Spring JDBC 主要功能 Spring框架对JDBC的简单封装。 提供了一个JDBCTemplate对象简化JDBC的开发 步骤： 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update(): 执行DML语句。增、删、改语句 queryForMap(): 查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList(): 查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query(): 查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper(类型.class) queryForObject()：查询结果，将结果封装为对象 一般用于聚合函数的查询 使用示例 import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; import java.util.Date; public class JdbcTemplateDemo { //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = \"update emp set salary = 10000 where id = 1001\"; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\"; int count = template.update(sql, 1015, \"郭靖\", 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = \"delete from emp where id = ?\"; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = \"select * from emp where id = ? or id = ?\"; Map map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = \"select * from emp\"; List> list = template.queryForList(sql); for (Map stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = \"select * from emp\"; List list = template.query(sql, new RowMapper() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = \"select * from emp\"; List list = template.query(sql, new BeanPropertyRowMapper(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = \"select count(id) from emp\"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } } import java.sql.Date; public class Emp { private Integer id; private String ename; private Integer job_id; private Integer mgr; private Date joindate; private Double salary; private Double bonus; private Integer dept_id; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public Integer getJob_id() { return job_id; } public void setJob_id(Integer job_id) { this.job_id = job_id; } public Integer getMgr() { return mgr; } public void setMgr(Integer mgr) { this.mgr = mgr; } public Date getJoindate() { return joindate; } public void setJoindate(Date joindate) { this.joindate = joindate; } public Double getSalary() { return salary; } public void setSalary(Double salary) { this.salary = salary; } public Double getBonus() { return bonus; } public void setBonus(Double bonus) { this.bonus = bonus; } public Integer getDept_id() { return dept_id; } public void setDept_id(Integer dept_id) { this.dept_id = dept_id; } @Override public String toString() { return \"Emp{\" + \"id=\" + id + \", ename='\" + ename + '\\'' + \", job_id=\" + job_id + \", mgr=\" + mgr + \", joindate=\" + joindate + \", salary=\" + salary + \", bonus=\" + bonus + \", dept_id=\" + dept_id + '}'; } } Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"chapters/Spark集群搭建.html":{"url":"chapters/Spark集群搭建.html","title":"Spark集群搭建","keywords":"","body":"spark环境搭建版本总览scala免密登录修改主机名(非必须)生成秘钥对秘钥上传服务器公钥查看免密检测hadoop新建用户(非必须)安装配置文件从节点设置hadoop启动和测试主要命令常见问题spark安装安装配置日志配置主要命令常见问题pyspark环境配置基础环境graphx环境配置远程解释器配置连接配置解释器其它功能测试例子本地连接常见问题 [TOC] spark环境搭建 版本总览 (ray37) [root@Slave03 huangyc]# java -version java version \"1.8.0_281\" (ray37) [root@Slave03 huangyc]# hadoop version Hadoop 3.2.1 Compiled with protoc 2.5.0 (ray37) [root@Slave03 huangyc]# scala -version Scala code runner version 2.12.15 -- Copyright 2002-2021, LAMP/EPFL and Lightbend, Inc. (ray37) [root@Slave03 huangyc]# sh /usr/spark-3.0/bin/spark-shell Spark context Web UI available at http://Slave03:4040 Welcome to ____ __ / __/__ ___ _____/ /__ _\\ \\/ _ \\/ _ `/ __/ '_/ /___/ .__/\\_,_/_/ /_/\\_\\ version 3.0.3 /_/ Using Scala version 2.12.10 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_281) scala 下载并安装scala 下载 scala-2.12 安装rpm -ivh scala-2.12.15.rpm 查看scala版本scala -version 配置环境 查询包中文件安装位置 -l： rpm -ql 包名 编辑/etc/profile，文件末尾添加配置 # 配置scala环境变量 export SCALA_HOME=/usr/share/scala/bin export PATH=$PATH:$SCALA_HOME 执行source /etc/profile令其生效 其他节点同样配置即可 免密登录 修改主机名(非必须) 查看主机名用hostname 修改主机名/etc/hostname 修改后重启服务器reboot 配置host文件vi /etc/hosts 192.168.123.21 Slave00 192.168.123.23 Slave02 192.168.123.24 Slave03 /etc/init.d/network restart 生成秘钥对 使用 RSA 类型的加密类型来创建密钥对 # 生成秘钥(-f换名字好像不行) ssh-keygen -t rsa # 配置本机免密 cat id_rsa.pub>>authorized_keys -f 参数表示指定密钥对生成位置与名称 密钥对通常放在 ~/.ssh目录下 回车即可创建密钥对，需要输入密码如果不需要为密钥对进行加密，那么可以一路回车 有需要清空文件的可以执行truncate -s 0 authorized_keys 创建成功之后，可以看到 .ssh 目录下多了两个文件，分别是： id_key：密钥对的私钥，通常放在客户端 id_rsa.pub：密钥对中的公钥，通常放在服务端 秘钥上传服务器 文件权限 sudo chmod -R 700 ~/.ssh sudo chmod -R 600 ~/.ssh/authorized_keys 将your_key.pub 公钥文件上传至需要连接的服务器 # 方式一：追加在其他服务器文件末尾(本机不需要) cat ~/.ssh/id_rsa.pub | ssh root@192.168.123.21 \"cat - >> ~/.ssh/authorized_keys\" cat ~/.ssh/id_rsa.pub | ssh root@192.168.123.23 \"cat - >> ~/.ssh/authorized_keys\" cat ~/.ssh/id_rsa.pub | ssh root@192.168.123.24 \"cat - >> ~/.ssh/authorized_keys\" # 方式二 ssh-copy-id -i ~/.ssh/id_key.pub root@192.168.123.21 ssh-copy-id -i ~/.ssh/id_key.pub root@192.168.123.23 ssh-copy-id -i ~/.ssh/id_key.pub root@192.168.123.24 -i 参数表示使用指定的密钥，-p参数表示指定端口，ssh 的默认端口是 22 公钥查看 本地的公钥文件上传在服务器的.ssh/authorized_keys 文件中 cat ~/.ssh/authorized_keys 免密检测 ssh Slaver00 ssh Slaver02 ssh Slaver03 hadoop 新建用户(非必须) 新建hadoop用户 useradd -m hadoop -s /bin/bash 修改hadoop用户密码 passwd hadoop 切换用户 su hadoop 新建文件夹 mkdir /home/hadoop/apps mkdir /home/hadoop/data 关闭防火墙 systemctl stop firewalld systemctl disable firewalld 关闭selinux vim /etc/sysconfig/selinux 修改SELINUX=enforcing为SELINUX=disabled 安装 下载并解压hadoop到/usr/hadoop-3.2.0 下载 hadoop-3.2.0，解压到/usr/hadoop-3.2.0 配置环境变量 export HADOOP_HOME=/usr/hadoop-3.2.0 export PATH=$PATH:$HADOOP_HOME 执行source /etc/profile令其生效 查看hadoop版本，hadoop version 配置文件 Hadoop配置文件的配置，需要配置的文件有几个分别是 hadoop-env.sh core-site.xml hdfs-site.xml mapred-site.xml yarn-site.xml workers文件 这些文件均可以在/usr/hadoop-3.2.0/etc/hadoop下找到 workers文件 Slave00 Slave02 Slave03 # 主节点 旧版本以及网上的教程是修改etc/hadoop/slaves文件，但是新版已经移除了这一个文件，取而代之的是workers文件，上述设置代表我的集群有三个datanode结点 hadoop_env.sh 在hadoop根目录下执行mkdir pids，用于存放pid文件 export JAVA_HOME=${JAVA_HOME} #设置JAVA_HOME的路径，需要再次指明 export HADOOP_HOME=${HADOOP_HOME} export HADOOP_PID_DIR=/usr/hadoop-3.2.0/pids # pid文件根目录，不设置的默认值为/tmp，一段时间后/tmp下的文件会被清除，导致无法关闭hadoop集群 # 解决启动时警告 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native 注意的是，如果之前没有设置JAVA_HOME的环境变量，此处直接这样引用会出现错误，改用绝对路径即可消除错误。 core-site.xml fs.defaultFS hdfs://Slave03:9000 hadoop.tmp.dir /home/huangyc/hadoop_data/data/tmp hdfs-site.xml dfs.namenode.secondary.http-address Slave03:50090 dfs.namenode.http.address Slave03:50070 dfs.replication 2 dfs.namenode.name.dir file:///data/hadoop/hdfs/nn dfs.datanode.data.dir file:///data/hadoop/hdfs/dn mapred-site.xml mapreduce.framework.name yarn mapreduce.jobhistory.address Slave03:10020 mapreduce.jobhistory.webapp.address Slave03:19888 yarn-site.xml yarn.resourcemanager.hostname Slave03 yarn.nodemanager.aux-services mapreduce_shuffle yarn.nodemanager.local-dirs file:///data/hadoop/yarn/nm 从节点设置 将hadoop目录拷贝到从节点的对应目录 仿照主节点对应的数据目录设置，设置对应的数据目录（即/data一系列目录） hadoop启动和测试 第一次开启时首先要初始化hdfs cd /usr/hadoop-3.2.0 ./bin/hdfs namenode -format 此处需要注意一个问题，第二次开启不需要再次初始化，遇到问题需要再次初始化，建议删除存放文件 上述配置文件中指明了存放数据的文件为dfs，到时候删除即可 主节点启动 cd /usr/hadoop-3.2.0/sbin # 启动前 ./start-all.sh 查看进程 # 主节点 [root@Slave03 sbin]# jps 28260 SecondaryNameNode 28810 ResourceManager 27706 DataNode 30236 Jps 29341 NodeManager 27326 NameNode # 从节点 [root@Slave00 sbin]# jps 3570 DataNode 4115 NodeManager 22413 Worker 27503 Jps 查看对应的数据结点是否正确 [root@Slave03 sbin]# hdfs dfsadmin -report Configured Capacity: 160982630400 (149.93 GB) Present Capacity: 82032381952 (76.40 GB) DFS Remaining: 82032345088 (76.40 GB) DFS Used: 36864 (36 KB) DFS Used%: 0.00% Replicated Blocks: Under replicated blocks: 0 Blocks with corrupt replicas: 0 Missing blocks: 0 Missing blocks (with replication factor 1): 0 Low redundancy blocks with highest priority to recover: 0 Pending deletion blocks: 0 Erasure Coded Block Groups: Low redundancy block groups: 0 Block groups with corrupt internal blocks: 0 hdfs主页Slave03:50070，如果不行，试试默认端口9870 hadoop主页Slave03:8088 主要命令 启动集群: ./sbin/start-all.sh 关闭集群: ./sbin/stop-all.sh 常见问题 stop-all.sh的时候hadoop的相关进程都无法停止 解决方案: 参考spark的常见问题，Hadoop的pid命名规则： pid=$HADOOP_PID_DIR/hadoop-$HADOOP_IDENT_STRING-$command.pid 因此，这里的pid文件名为: hadoop-root-datanode.pid hadoop-root-namenode.pid hadoop-root-nodemanager.pid hadoop-root-resourcemanager.pid hadoop-root-secondarynamenode.pid 通过jps查看相关进程的pid，恢复这些pid文件即可使用stop-all.sh停止hadoop，根治方案参考spark常见问题部分 spark安装 安装配置 下载解压，复制到/usr/spark-3.0 配置环境变量vi /etc/profile # 配置spark环境 export SPARK_HOME=/usr/spark-3.0 export PATH=$PATH:$SPARK_HOME/bin 执行source /etc/profile令其生效 配置spark-env.sh 将conf文件夹下的spark-env.sh.template重命名为spark-env.sh，并添加以下内容： 在spark根目录下执行mkdir pids，用于存放pid文件 # 环境变量 export JAVA_HOME=/usr/java/jdk1.8.0_281-amd64 export SCALA_HOME=/usr/share/scala export HADOOP_HOME=/usr/hadoop-3.2.1 # 详细配置 export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop export SPARK_MASTER_HOST=Slave03 export SPARK_LOCAL_DIRS=/usr/spark-3.0 export SPARK_DRIVER_MEMORY=16g # 内存 export SPARK_EXECUTOR_MEMORY=8g # 执行内存 export SPARK_WORKER_CORES=4 # cpu核心数 export SPARK_PID_DIR=/usr/spark-3.0/pids # pid文件根目录，不设置的默认值为/tmp，一段时间后/tmp下的文件会被清除，导致无法关闭spark集群 配置slaves 将conf文件夹下的slaves.template重命名为slaves，并添加以下内容： Slave00 Slave02 Slave03 # 主节点 配置从节点(将spark目录复制到其他节点的同一个目录下) scp -r root@192.168.123.24:/usr/spark-3.0 /usr/ 在sbin目录下使用start-all.sh启动集群 启动成功后，我们在浏览器输入Slave03:8080看到有三个结点，就代表我们安装成功了。 如果发现启动错误，请查看logs目录下的日志，自行检查配置文件！ 日志配置 配置spark的执行日志等级，进入到spark根目录下的conf目录 cp log4j.properties.template log4j.properties，修改配置如下 # Set everything to be logged to the console log4j.rootCategory=WARN, console log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.target=System.err log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=%d{yy/MM/dd HH:mm:ss} %p %c{1}: %m%n # Set the default spark-shell log level to WARN. When running the spark-shell, the # log level for this class is used to overwrite the root logger's log level, so that # the user can have different defaults for the shell and regular Spark apps. log4j.logger.org.apache.spark.repl.Main=WARN # Settings to quiet third party logs that are too verbose log4j.logger.org.sparkproject.jetty=WARN log4j.logger.org.sparkproject.jetty.util.component.AbstractLifeCycle=ERROR log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper=INFO log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter=INFO log4j.logger.org.apache.parquet=ERROR log4j.logger.parquet=ERROR # SPARK-9183: Settings to avoid annoying messages when looking up nonexistent UDFs in SparkSQL with Hive support log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler=FATAL log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry=ERROR # 关闭警告 # WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR 主要命令 启动集群: ./sbin/start-all.sh 关闭集群: ./sbin/stop-all.sh 常见问题 stop-all.sh的时候spark的相关进程都无法停止 $SPARK_PID_DIR中存放的是pid文件，就是要停止进程的pid。其中$SPARK_PID_DIR默认是在系统的/tmp目录 系统每隔一段时间就会清除/tmp目录下的内容。到/tmp下查看一下，果然没有相关进程的pid文件了。 这才导致了stop-all.sh无法停止集群。 解决方案: $SPARK_PID_DIR下新建pid文件，pid文件命名规则如下 $SPARK_PID_DIR/spark-$SPARK_IDENT_STRING-$command-$instance.pid $SPARK_PID_DIR默认是/tmp $SPARK_IDENT_STRING是登录用户$USER，我的集群中用户名是root $command是调用spark-daemon.sh时的参数，有两个： org.apache.spark.deploy.master.Master org.apache.spark.deploy.worker.Worker $instance也是调用spark-daemon.sh时的参数，我的集群中是1 因此pid文件名如下(名字不对的情况下，可以执行./start-all.sh，重新启动查看后，再执行./stop-all.sh进行本次集群的关闭，注意这里关闭的是本次打开的，之前无法关闭的进程仍然还在)： spark-root-org.apache.spark.deploy.master.Master-1.pid spark-root-org.apache.spark.deploy.worker.Worker-1.pid 通过jps查看相关进程的pid，将pid保存到对应的pid文件即可，之后调用spark的stop-all.sh，即可正常停止spark集群 要根治这个问题，只需要在集群所有节点都设置$SPARK_PID_DIR，$HADOOP_PID_DIR和$YARN_PID_DIR即可 # 修改hadoop-env.sh，增加： export HADOOP_PID_DIR=/home/ap/cdahdp/app/pids # 修改yarn-env.sh，增加： export YARN_PID_DIR=/home/ap/cdahdp/app/pids # 修改spark-env.sh，增加： export SPARK_PID_DIR=/home/ap/cdahdp/app/pids pyspark 环境配置 基础环境 spark集群服务器配置环境变量，vi /etc/profile export PYSPARK_PYTHON=/root/anaconda3/envs/ray37/bin/python3.7 export PYSPARK_DRIVER_PYTHON=/root/anaconda3/envs/ray37/bin/python3.7 执行source /etc/profile使其生效 安装pyspark库 # 这里需要注意版本需要和spark的版本一致 pip install pyspark==3.0.3 # 在安装pyspark时默认会装上对应的py4j，如果没有的话，手动安装下 pip install py4j==0.10.9 对于spark服务器和work间环境不一致的情况 方式一: 重新安装python虚拟环境，使得路径完全一致 方式二: 配置软链接 ln -s 源文件 目标文件 # 需要事先建好路径 ln -s /opt/anaconda/install/envs/ray37/bin/python3.7 /root/anaconda3/envs/ray37/bin/python3.7 在服务器 liunx 环境上修改查看python的包路径site-package from distutils.sysconfig import get_python_lib print(get_python_lib()) graphx环境 安装graphframes pip install graphframes==0.6 去graphframes官网下载对应jar包，这里spark集群是3.0.3，所以可以下载Version: 0.8.2-spark3.0-s_2.12这个版本的 复制到spark根目录下的jars目录中，集群中每个节点都需要 如果还会出错，可以把该jar包也复制一份到python环境下 /opt/anaconda/install/envs/ray37/lib/python3.7/site-packages/pyspark/jars 配置远程解释器 配置连接 配置连接的远程服务器 打开Pycharm -> Tools -> Deployment -> Configuration 点击加号，选择SFTP，给服务器取一个名字 点击SSH configuration后面的省略号 输入服务器IP地址和账号密码，结束后测试一下连接情况 Connection Parameters下的心跳可以设置10秒 确认后，保存退出当前窗口 点击自动检测 ，选择远程服务器的工作路径 这里选的是，自己提前新建的空文件夹/home/huangyc/hyc_test Mappings下选择Local path，配置当前项目的路径 保存，退出 配置解释器 选择远程的解释器 点击move即可next 配置路径，远程的选择自己之前新建的/home/huangyc/hyc_test Automatically upload ...表示会自动上传项目到服务器中 其它功能 在Pycharm上显示远程代码：选择Tools -->Deployment-->Browse Remote Host 更新代码：将本地代码上传到服务器上Tools -->Deployment-->upload to 服务器上代码下载到本地代码上Tools -->Deployment-->Download from 测试例子 简单词统计 + pagerank例子 #!/usr/bin/env Python # -- coding: utf-8 -- \"\"\" @version: v1.0 @author: huangyc @file: connenct_test.py @Description: @time: 2022/1/25 14:49 \"\"\" import os import platform import traceback from typing import List from graphframes import * from pyspark import SparkConf from pyspark.sql import SparkSession from pyspark.sql import functions as F py_root = \"/root/anaconda3/envs/ray37/bin/python3.7\" os.environ[\"PYSPARK_PYTHON\"] = py_root os.environ[\"PYSPARK_DRIVER_PYTHON\"] = py_root is_local_py: bool = True if is_local_py and platform.system().lower() == 'windows': os.environ['JAVA_HOME'] = 'G:\\Java\\jdk1.8.0_201' os.environ[\"SPARK_HOME\"] = r\"E:\\PycharmWS\\remote_spark\\spark-3.0\" class PySparkClient: def __init__(self, appname: str, master: str): conf = SparkConf().setAppName(appname).setMaster(master) # spark资源配置 conf.set(\"spark.driver.maxResultSize\", \"4g\") conf.set(\"spark.executor.num\", \"4\") conf.set(\"spark.executor.memory\", \"2g\") conf.set(\"spark.executor.cores\", \"4\") conf.set(\"spark.cores.max\", \"16\") conf.set(\"spark.driver.memory\", \"2g\") try: self.spark = SparkSession.builder.config(conf=conf).getOrCreate() self.sc = self.spark.sparkContext except: traceback.print_exc() # 返回出错信息 def word_count(self, log_file: str): if not self.sc: return log_data = self.sc.textFile(log_file).cache() words_rdd = log_data.flatMap(lambda sentence: sentence.split(\" \")) res = words_rdd.countByValue() res_rdd = words_rdd.filter(lambda k: len(k) > 0).map(lambda word: (word, 1)).reduceByKey(lambda a, b: a + b) # 将rdd转为collection并打印 res_rdd_coll = res_rdd.takeOrdered(5, lambda x: -x[1]) for line in res_rdd_coll: print(line) def simple_test(self, words: List[str]): if not self.sc: return counts = self.sc.parallelize(words).count() print(\"Number of elements in RDD is %i\" % counts) test = self.spark.createDataFrame( [('001', '1', 100, 87, 67, 83, 98), ('002', '2', 87, 81, 90, 83, 83), ('003', '3', 86, 91, 83, 89, 63), ('004', '2', 65, 87, 94, 73, 88), ('005', '1', 76, 62, 89, 81, 98), ('006', '3', 84, 82, 85, 73, 99), ('007', '3', 56, 76, 63, 72, 87), ('008', '1', 55, 62, 46, 78, 71), ('009', '2', 63, 72, 87, 98, 64)], ['number', 'class', 'language', 'math', 'english', 'physic', 'chemical']) test.show() test.printSchema() test.select('number', 'class', 'language', 'math', 'english').describe().show() print(\"============ simple_test over ============\") def simple_graph(self): # Create a Vertex DataFrame with unique ID column \"id\" spk = self.spark v = spk.createDataFrame([ (\"a\", \"Alice\", 34), (\"b\", \"Bob\", 36), (\"c\", \"Charlie\", 30), ], [\"id\", \"name\", \"age\"]) # Create an Edge DataFrame with \"src\" and \"dst\" columns e = spk.createDataFrame([ (\"a\", \"b\", \"friend\"), (\"b\", \"c\", \"follow\"), (\"c\", \"b\", \"follow\"), ], [\"src\", \"dst\", \"relationship\"]) # Create a GraphFrame g = GraphFrame(v, e) # Query: Get in-degree of each vertex. g.inDegrees.show() # Query: Count the number of \"follow\" connections in the graph. print(g.edges.filter(\"relationship = 'follow'\").count()) # Run PageRank algorithm, and show results. results = g.pageRank(resetProbability=0.1, maxIter=1) res = results.vertices.select(\"id\", F.bround(\"pagerank\", scale=4).alias('pagerank')) res.orderBy(res.pagerank.desc()).show(5) def stop(self): try: self.sc.stop() except: pass if __name__ == '__main__': appname = \"test_hyc00\" # 任务名称 master = \"spark://192.168.xx.xx:7077\" # 单机模式设置 # master = \"local\" py_spark_client = PySparkClient(appname=appname, master=master) # 简单功能测试 all_words = [\"scala\", \"java\", \"hadoop\", \"spark\", \"akka\", \"spark vs hadoop\", \"akka\", \"spark vs hadoop\", \"pyspark\", \"pyspark and spark\"] py_spark_client.simple_test(words=all_words) # 文档词频统计 logFile = r\"hdfs://192.168.xx.xx:9000/test_data/README.md\" py_spark_client.word_count(log_file=logFile) py_spark_client.simple_graph() # 关闭客户端连接 py_spark_client.stop() 执行方法 可以直接在pycharm中执行，这里pycharm使用的是远程的python环境，这里执行时的内存是默认值 1024.0 MiB 在pycharm中执行可能需要加上变量设置，但使用spark-submit则可以不需要 os.environ[\"PYSPARK_PYTHON\"] = \"/root/anaconda3/envs/ray37/bin/python3.7\" os.environ[\"PYSPARK_DRIVER_PYTHON\"] = \"/root/anaconda3/envs/ray37/bin/python3.7\" 或者执行以下命令执行，这里执行时的内存是spark中配置的 8.0 GiB ./bin/spark-submit --master spark://192.168.xx.xx:7077 /home/huangyc/hyc_test/tests/pyspark_test/connenct_test.py 本地连接 除了配置远程服务器的py解释器，还可以配置本地的模式 需要在spark集群中配置host映射，通过vi /etc/hosts命令打开hosts文件，添加本地的主机名映射 # hyc 10.10.0.xx DSE-20191111ZOU 最后执行/etc/init.d/network restart刷新DNS 如果没有的话，可能会报错误 Caused by: java.io.IOException: Failed to connect to DSE-20191111ZOU:65320 Caused by: java.net.UnknownHostException: DSE-20191111ZOU py代码中需要添加以下的环境参数才能连接上spark集群 import os # 配置集群的python环境路径 py_root = \"/root/anaconda3/envs/ray37/bin/python3.7\" os.environ[\"PYSPARK_PYTHON\"] = py_root os.environ[\"PYSPARK_DRIVER_PYTHON\"] = py_root # 配置本地Jdk路径，版本尽量和spark集群的一致 os.environ['JAVA_HOME'] = 'G:\\Java\\jdk1.8.0_201' # 配置本地的spark路径，这里直接从spark集群copy一份下载即可 os.environ[\"SPARK_HOME\"] = r\"E:\\PycharmWS\\remote_spark\\spark-3.0\" class PySparkClient: def __init__(self, appname: str, master: str): conf = SparkConf().setAppName(appname).setMaster(master) # spark资源配置 # 以下的参数不用全部配置，看自己的需求 conf.set(\"spark.driver.maxResultSize\", \"4g\") conf.set(\"spark.executor.num\", \"4\") conf.set(\"spark.executor.memory\", \"2g\") conf.set(\"spark.executor.cores\", \"4\") conf.set(\"spark.cores.max\", \"16\") conf.set(\"spark.driver.memory\", \"2g\") try: self.spark = SparkSession.builder.config(conf=conf).getOrCreate() self.sc = self.spark.sparkContext except: traceback.print_exc() # 返回出错信息 ⚡: 本地的python版本尽量和spark集群上的一致，避免不必要的错误 常见问题 Copyright © narutohyc.com 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-02-18 01:01:52 new Valine({el: \"#vcomments\",appId: 'jQTfSSGRF0zp8yqaaa6bjeVQ-gzGzoHsz',appKey: 'FOXMptWOHC7cU1FxXt0LJj4o',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}